var tipuesearch = {"pages":[{"title":" EXCEED-DM ","text":"EXCEED-DM Developer Info Tanner Trickle","tags":"home","loc":"index.html"},{"title":"control_input.f90 – EXCEED-DM","text":"Contents Modules control_input Source Code control_input.f90 Source Code module control_input !! Collection of variables which specify how the program should run implicit none character ( len = 64 ) :: process = '' character ( len = 64 ) :: calc_mode = '' logical :: timer = . TRUE . !! Optional !! !! If .TRUE. the program will output timing information logical :: quiet = . FALSE . !! Don't print any output logical :: save_binned_rate_if = . FALSE . !! save the 2d differential rate data for !! every i -> f transition !! !! memory intensive logical :: overwrite_output = . FALSE . !! if True the output file will be overwritten NAMELIST / control / timer , & quiet , & process , & calc_mode , & save_binned_rate_if , & overwrite_output contains subroutine load_control ( filename , verbose ) !! Loads the control variables implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = control , iostat = error ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!! ERROR !!' print * print * , '    Problem with control namelist.' print * print * , '!!!!!!!!!!!' print * end if stop end if close ( 100 ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for control parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/control_input.f90.html"},{"title":"core_electrons.f90 – EXCEED-DM","text":"Contents Modules core_electrons Source Code core_electrons.f90 Source Code module core_electrons !! Handles the wave functions and energy levels for core electrons use hdf5 use h5lt use prec use constants use math_mod implicit none integer :: n_atoms !! Number of atoms in the primitive cell integer :: n_core_states !! Total number of core states integer , allocatable :: Z_list (:) !! Dim : [n_atoms] !! !! Proton number / number of electrons real ( dp ), allocatable :: eq_pos_red (:, :) !! Dim : [n_atoms, 3] !! !! Equilibrium position of the atoms in the primitive cell !! in reduced coordinates !! !! Units : None real ( dp ), allocatable :: core_energy (:) !! Dim : [n_core_states] !! !! Energy of the core states !! !! Units : eV integer , allocatable :: core_elec_conf (:, :) !! Dim : [n_core_states, 5] !! !! Electron configuration, each element is !!  core_elec_conf(i, 1) - atom id !!  core_elec_conf(i, 2) - n !!  core_elec_conf(i, 3) - l !!  core_elec_conf(i, 4) - m !!  core_elec_conf(i, 5) - n_s (number of spin states) !! Generated STO parameters integer , allocatable :: core_sto_nj_list (:) !! Dim : [n_core_states] !! !! Number of terms in the analytic STO expansion integer :: core_sto_max_nj !! Maximum value of core_sto_nj_list real ( dp ), allocatable :: core_sto_data (:, :, :) !! Dim : [n_core_states, 4, max(core_sto_nj_list)] !! !! All of the parameters of the STO expansion !!  core_sto_data(i, 1, :) - n_l[j] !!  core_sto_data(i, 2, :) - Z_l[j] !!  core_sto_data(i, 3, :) - N_l[j] !!  core_sto_data(i, 4, :) - C_nl[j] contains subroutine save_core_electrons ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id , group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving core electrons...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'core' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , 'core/n_core_states' , size ( dims1 ), dims1 ,& n_core_states , error ) call h5ltmake_dataset_int_f ( file_id , 'core/n_atoms' , size ( dims1 ), dims1 ,& n_atoms , error ) dims1 = [ n_atoms ] call h5ltmake_dataset_int_f ( file_id , 'core/Z_list' , size ( dims1 ), dims1 ,& Z_list , error ) dims2 = [ n_atoms , 3 ] call h5ltmake_dataset_double_f ( file_id , 'core/eq_pos_red' , size ( dims2 ), dims2 ,& eq_pos_red , error ) dims1 = [ n_core_states ] call h5ltmake_dataset_double_f ( file_id , 'core/core_energy' , size ( dims1 ), dims1 ,& core_energy , error ) dims2 = [ n_core_states , 5 ] call h5ltmake_dataset_int_f ( file_id , 'core/core_elec_config' , size ( dims2 ), dims2 ,& core_elec_conf , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine calc_core_sto_wf_grid ( core_wfc , core_state_idx , n_grid , red_to_xyz ,& shift , k_vec_in , s_cut_in , verbose ) !! computes the core wave functions on a grid, summed over the closest unit cells !! !! if shift == T : x_shift = x_pos_red (equilibrium position) !! else: x_shift = 0 !! core_sto_wf_grid(x) = sum_s core_sto_wf(x - x_shift + s) !! !! where x_i is the atomic equilibrium position implicit none logical , optional :: verbose logical , optional :: shift integer :: n_grid ( 3 ) !! Number of grid points in reduced x coordinates complex ( dp ) :: core_wfc ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) real ( dp ), optional :: k_vec_in ( 3 ) real ( dp ) :: k_vec ( 3 ) integer , optional :: s_cut_in integer :: s_cut integer :: core_state_idx integer :: n1 , n2 , n3 integer :: s1 , s2 , s3 real ( dp ) :: x_red ( 3 ) real ( dp ) :: s_red ( 3 ) real ( dp ) :: x_vec ( 3 ) real ( dp ) :: x_shift_red ( 3 ) real ( dp ) :: x_shift ( 3 ) real ( dp ) :: red_to_xyz ( 3 , 3 ) complex ( dp ) :: core_sto_wf_sum complex ( dp ) :: phase_fac real ( dp ) :: y_vec ( 3 ) !! y = x + r - x_i integer :: s , s_count , n_s real ( dp ), allocatable :: s_red_list (:, :) real ( dp ), allocatable :: s_vec_list (:, :) if ( shift ) then x_shift_red = eq_pos_red ( core_elec_conf ( core_state_idx , 1 ), :) else x_shift_red = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if x_shift = matmul ( red_to_xyz , x_shift_red ) if ( present ( k_vec_in ) ) then k_vec = k_vec_in else k_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if if ( present ( s_cut_in ) ) then s_cut = s_cut_in else s_cut = 1 end if n_s = ( 2 * s_cut + 1 ) ** 3 allocate ( s_red_list ( 3 , n_s )) allocate ( s_vec_list ( 3 , n_s )) s_count = 0 do s1 = - s_cut , s_cut do s2 = - s_cut , s_cut do s3 = - s_cut , s_cut s_count = s_count + 1 s_red_list (:, s_count ) = [ 1.0_dp * s1 , 1.0_dp * s2 , 1.0_dp * s3 ] s_vec_list (:, s_count ) = matmul ( red_to_xyz , s_red_list (:, s_count )) end do end do end do do n3 = 1 , n_grid ( 3 ) do n2 = 1 , n_grid ( 2 ) do n1 = 1 , n_grid ( 1 ) x_red = [( n1 - 1.0_dp ) / n_grid ( 1 ),& ( n2 - 1.0_dp ) / n_grid ( 2 ),& ( n3 - 1.0_dp ) / n_grid ( 3 )] x_vec = matmul ( red_to_xyz , x_red ) core_sto_wf_sum = cmplx ( 0.0_dp , 0.0_dp , dp ) do s = 1 , n_s phase_fac = exp ( ii * dot_product ( k_vec , s_vec_list (:, s ) - x_vec )) y_vec = x_vec - x_shift + s_vec_list (:, s ) core_sto_wf_sum = core_sto_wf_sum + & phase_fac * core_sto_wf ( core_state_idx , y_vec ) end do core_wfc ( n1 , n2 , n3 ) = core_sto_wf_sum end do end do end do end subroutine function core_sto_wf ( core_state_idx , x_vec ) result ( val ) !! Core wave function !! !! Units : eV&#94;(3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: l , m real ( dp ) :: x_vec ( 3 ), x_hat ( 3 ) real ( dp ) :: x_mag complex ( dp ) :: val x_mag = norm2 ( x_vec ) !! avoid |x| = 0 problems if ( x_mag . gt . 1e-8_dp ) then x_hat = x_vec / x_mag else x_hat = [ 0 , 0 , 1 ] end if l = core_elec_conf ( core_state_idx , 3 ) m = core_elec_conf ( core_state_idx , 4 ) val = core_sto_wf_radial ( core_state_idx , x_mag ) * sph_harmonic ( l , m ,& get_theta ( x_hat ), get_phi ( x_hat )) end function function core_sto_wf_FT ( core_state_idx , k_vec ) result ( val ) !! Fourier transform of the core wave function !! !! Units : eV&#94;(-3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: l , m real ( dp ) :: k_vec ( 3 ), k_hat ( 3 ) real ( dp ) :: k_mag complex ( dp ) :: val k_mag = norm2 ( k_vec ) !! avoid |k| = 0 problems if ( k_mag . gt . 1e-8_dp ) then k_hat = k_vec / k_mag else k_hat = [ 0 , 0 , 1 ] end if l = core_elec_conf ( core_state_idx , 3 ) m = core_elec_conf ( core_state_idx , 4 ) val = core_sto_wf_FT_radial ( core_state_idx , k_mag ) * sph_harmonic ( l , m ,& get_theta ( k_hat ), get_phi ( k_hat )) end function function core_sto_wf_radial ( core_state_idx , x_mag ) result ( val ) !! Radial part of the total core wave function, summed over !! the individual sto_wf_radial !! !! Units : eV&#94;(3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: atom , n , l , m integer :: j integer :: n_lj , nj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: x_mag real ( dp ) :: val val = 0.0_dp l = core_elec_conf ( core_state_idx , 3 ) nj = core_sto_nj_list ( core_state_idx ) do j = 1 , nj n_lj = int ( core_sto_data ( core_state_idx , 1 , j )) Z_lj = core_sto_data ( core_state_idx , 2 , j ) N0_lj = core_sto_data ( core_state_idx , 3 , j ) C_lnj = core_sto_data ( core_state_idx , 4 , j ) val = val + C_lnj * sto_wf_radial ( n_lj , N0_lj , Z_lj , x_mag ) end do end function function core_sto_wf_FT_radial ( core_state_idx , k_mag ) result ( chi ) !! Radial part of the total Fourier transformed core wave function, summed over !! the individual sto_wf_FT_radial !! !! Units : eV&#94;(-3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: atom , n , l , m integer :: j integer :: n_lj , nj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: k_mag complex ( dp ) :: chi chi = cmplx ( 0.0_dp , 0.0_dp , dp ) l = core_elec_conf ( core_state_idx , 3 ) nj = core_sto_nj_list ( core_state_idx ) do j = 1 , nj n_lj = int ( core_sto_data ( core_state_idx , 1 , j )) Z_lj = core_sto_data ( core_state_idx , 2 , j ) N0_lj = core_sto_data ( core_state_idx , 3 , j ) C_lnj = core_sto_data ( core_state_idx , 4 , j ) chi = chi + C_lnj * sto_wf_FT_radial ( n_lj , l , N0_lj , Z_lj , k_mag ) end do end function function sto_wf_radial ( n , norm , Z , x_mag ) result ( val ) !! Radial part of the Slater type orbital (STO) wave function !! !! Units : eV&#94;(3/2) implicit none integer :: n real ( dp ) :: norm , Z , x_mag real ( dp ) :: val val = a0 ** ( - 1.5 ) * norm * ( x_mag / a0 ) ** ( n - 1 ) * exp ( - Z * x_mag / a0 ) end function function sto_wf_FT_radial ( n , l , norm , Z , k_mag ) result ( val ) !! Radial part of the fourier transform of a Slater type orbital (STO) wave function !! !! sto_wf_FT = int d&#94;3x sto_wf e&#94;(-ikr) !!           = (sto_wf_FT_radial) * sph_harmonic(k hat) !! !! Reference : https://en.wikipedia.org/wiki/Slater-type_orbital !! !! Units : eV&#94;(-3/2) implicit none integer :: n , l real ( dp ) :: norm , Z , k_mag complex ( dp ) :: val integer :: s real ( dp ) :: omega_s , xi val = cmplx ( 0.0_dp , 0.0_dp , dp ) xi = Z / a0 do s = 0 , floor (( n - l ) / 2.0_dp ) omega_s = ( - 4 * xi ** 2 ) ** ( - s ) * factorial ( n - s ) * & ( factorial ( s ) * factorial ( n - l - 2 * s )) ** ( - 1 ) val = val + omega_s * ( k_mag ** 2 + xi ** 2 ) ** ( s - n - 1 ) end do val = a0 ** ( - 0.5 ) * a0 ** ( - n ) * norm * ( 4 * pi ) * factorial ( n - l ) * & ( 2 * xi ) ** n * ( ii * k_mag / xi ) ** l * val end function subroutine load_core_elec_config ( filename , verbose ) !! Reads the core electron configuration file implicit none logical , optional :: verbose character ( len =* ) :: filename integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims1 ( 1 ) integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Loading core electron configuration...' print * end if inquire ( file = filename , exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_int_f ( file_id , 'n_atoms' , n_atoms , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_core_states' , n_core_states , dims , error ) dims2 = [ n_atoms , 3 ] allocate ( eq_pos_red ( n_atoms , 3 )) call h5ltread_dataset_double_f ( file_id , 'eq_pos_red' , eq_pos_red , dims2 , error ) dims1 = [ n_core_states ] allocate ( core_energy ( n_core_states )) call h5ltread_dataset_double_f ( file_id , 'core_energy' , core_energy , dims1 , error ) dims1 = [ n_atoms ] allocate ( Z_list ( n_atoms )) call h5ltread_dataset_int_f ( file_id , 'Z_list' , Z_list , dims1 , error ) dims2 = [ n_core_states , 5 ] allocate ( core_elec_conf ( n_core_states , 5 )) call h5ltread_dataset_int_f ( file_id , 'core_elec_config' , core_elec_conf , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) call print_core_elec_config ( filename , verbose = verbose ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Core electron configuration file : ' print * , '    ' , trim ( filename ) print * , ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_core_elec_config ( filename , verbose ) implicit none logical , optional :: verbose integer :: n character ( len =* ) :: filename if ( verbose ) then print * , '   Core electron configuration filename : ' , trim ( filename ) print * print * , '   Number of atoms = ' , n_atoms print * , '   Proton numbers = ' , Z_list print * , '   Number of core states = ' , n_core_states print * print * , '   Equilibrium positions (reduced) : ' do n = 1 , n_atoms print * , '       atom # = ' , n , ', ' , eq_pos_red ( n , :) end do print * print * , '   Core electron configuration : ' do n = 1 , n_core_states print * , '       atom = ' , core_elec_conf ( n , 1 ) print * , '       n    = ' , core_elec_conf ( n , 2 ) print * , '       l    = ' , core_elec_conf ( n , 3 ) print * , '       m    = ' , core_elec_conf ( n , 4 ) print * , '       n_s  = ' , core_elec_conf ( n , 5 ) print * print * , '       energy = ' , core_energy ( n ), 'eV' print * end do end if end subroutine subroutine load_core_sto_data ( filename , verbose ) !! Reads the sto wf file to get the relevant !! coefficients for the electron configuration !! specified in the core_elec_conf implicit none character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) integer ( HSIZE_T ) :: dims1 ( 1 ) integer ( HSIZE_T ) :: dims2 ( 2 ) character ( len = 64 ) :: dset_name integer :: error integer :: n , nj real ( dp ), allocatable :: buf (:) dims = [ 1 ] if ( verbose ) then print * , 'Loading STO wf data file...' print * end if inquire ( file = filename , exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) allocate ( core_sto_nj_list ( n_core_states )) !! get the relevant data for each core state do n = 1 , n_core_states dset_name = get_sto_dataset_str ( Z_list ( core_elec_conf ( n , 1 )),& core_elec_conf ( n , 2 ),& core_elec_conf ( n , 3 )) call h5ltread_dataset_int_f ( file_id ,& trim ( dset_name ) // '/nj' ,& core_sto_nj_list ( n ),& dims , error ) end do core_sto_max_nj = maxval ( core_sto_nj_list ) allocate ( core_sto_data ( n_core_states , 4 , core_sto_max_nj )) core_sto_data = 0.0_dp do n = 1 , n_core_states nj = core_sto_nj_list ( n ) dset_name = get_sto_dataset_str ( Z_list ( core_elec_conf ( n , 1 )),& core_elec_conf ( n , 2 ),& core_elec_conf ( n , 3 )) dims1 = [ nj ] allocate ( buf ( nj )) call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/n_lj' , buf , dims1 , error ) core_sto_data ( n , 1 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/Z_lj' , buf , dims1 , error ) core_sto_data ( n , 2 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/N_lj' , buf , dims1 , error ) core_sto_data ( n , 3 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/C_lnj' , buf , dims1 , error ) core_sto_data ( n , 4 , : nj ) = buf deallocate ( buf ) end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) call print_sto_data ( verbose = verbose ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   STO wf data file : ' print * , '    ' , trim ( filename ) print * , ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine function get_sto_dataset_str ( Z , n , l ) result ( dset_name ) !! Returns the name of the dataset for nth element in the !! core electron configuration implicit none integer :: Z , n , l character ( len = 64 ) :: Z_str , n_str , l_str character ( len = 64 ) :: dset_name write ( Z_str , * ) Z Z_str = adjustl ( Z_str ) write ( n_str , * ) n n_str = adjustl ( n_str ) write ( l_str , * ) l l_str = adjustl ( l_str ) dset_name = 'Z_' // trim ( Z_str ) // '/n_' // trim ( n_str ) // '/l_' // trim ( l_str ) end function subroutine print_sto_data ( verbose ) implicit none logical , optional :: verbose integer :: n if ( verbose ) then print * , '   Core electron STO wf parameters : ' do n = 1 , n_core_states print * , '       atom = ' , core_elec_conf ( n , 1 ) print * , '       n    = ' , core_elec_conf ( n , 2 ) print * , '       l    = ' , core_elec_conf ( n , 3 ) print * , '       m    = ' , core_elec_conf ( n , 4 ) print * , '       n_s  = ' , core_elec_conf ( n , 5 ) print * print * , '       n_j = ' , core_sto_nj_list ( n ) print * , '       n_lj = ' , core_sto_data ( n , 1 , :) print * , '       Z_lj = ' , core_sto_data ( n , 2 , :) print * , '       N0_lj = ' , core_sto_data ( n , 3 , :) print * , '       C_lnj = ' , core_sto_data ( n , 4 , :) print * end do end if end subroutine end module","tags":"","loc":"sourcefile/core_electrons.f90.html"},{"title":"DFT_parameters.f90 – EXCEED-DM","text":"Contents Modules DFT_parameters Source Code DFT_parameters.f90 Source Code module DFT_parameters !! Handles the results from DFT calculations that compute the Bloch wave !! function coefficients. !! !! Variables with '_A' are with units of Angstroms use h5lt use hdf5 use prec use constants use units implicit none integer :: n_k !! Number of k points integer :: n_val !! Number of valence bands integer :: n_cond !! Number of conduction bands integer :: n_in_G !! Number of G points in in_G_grid integer , allocatable :: in_G_grid_red (:, :) !! Dim : [n_in_G, 3] !! !! Input grid of G vectors in reduced coordinates real ( dp ) :: a_vecs_A ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : Ang real ( dp ) :: b_vecs_A ( 3 , 3 ) !! Reciprocal lattice vector !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : Ang&#94;(-1) real ( dp ), allocatable :: k_weight (:) !! Dim : [n_k] !! !! Weights of each k point in the k_red grid, must sum to 2 !! !! Units : None real ( dp ), allocatable :: k_grid_red (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in reduced coordinates !! !! Units : None real ( dp ), allocatable :: energy_bands_raw (:, :) !! Dim : [n_k, n_bands] !! !! Raw electron energy eigenvalues !! !! Units : eV !! Generated from input integer :: n_bands !! Number of bands !! !! n_bands = n_cond + n_val real ( dp ) :: q_PW_cut !! plane wave cutoff in expansion !! !! Units : eV real ( dp ) :: E_PW_cut !! energy cooresponding to q_PW_cut !! !! E_PW_cut = q_PW_cut**2/(2*m_elec) !! !! Units : eV real ( dp ) :: a_vecs ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : eV real ( dp ) :: red_to_xyz ( 3 , 3 ) !! Matrix converting reduced cooredinate positions to physical xyz cooredinates !! in eV&#94;(-1) via !! !!      x_xyz = matmul(red_to_xyz, x_red) !! !! red_to_xyz = transpose(a_vecs) !! !! Units : eV&#94;(-1) real ( dp ) :: b_vecs ( 3 , 3 ) !! Reciprocal lattice vector !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : eV real ( dp ) :: k_red_to_xyz ( 3 , 3 ) !! Matrix converting reduced cooredinate momentum to physical xyz cooredinates !! in eV via !! !!      k_xyz = matmul(k_red_to_xyz, k_red) !! !! k_red_to_xyz = transpose(b_vecs) !! !! Units : eV real ( dp ), allocatable :: energy_bands (:, :) !! Dim : [n_k, n_bands] !! !! Scissor corrected electron energy eigenvalues !! !! Units : eV real ( dp ), allocatable :: in_G_grid_xyz (:, :) !! Dim : [n_in_G, 3] !! !! Input grid of G vectors in physical xyz coordinates !! !! Units : eV real ( dp ), allocatable :: k_grid_xyz (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in xyz coordinates !! !! Units : eV contains subroutine save_DFT_parameters ( filename , verbose ) !! Saves some of the DFT input variables to filename implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id , group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) = [ 3 , 3 ] integer :: error if ( verbose ) then print * , 'Saving DFT parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'DFT_parameters' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_val' , size ( dims1 ), dims1 ,& n_val , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_cond' , size ( dims1 ), dims1 ,& n_cond , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_bands' , size ( dims1 ), dims1 ,& n_bands , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_k' , size ( dims1 ), dims1 ,& n_k , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_in_G' , size ( dims1 ), dims1 ,& n_in_G , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/E_PW_cut' , size ( dims1 ), dims1 ,& E_PW_cut , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/q_PW_cut' , size ( dims1 ), dims1 ,& q_PW_cut , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/k_red_to_xyz' , size ( dims2 ), dims2 ,& k_red_to_xyz , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/red_to_xyz' , size ( dims2 ), dims2 ,& red_to_xyz , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine load_DFT_parameters ( filename , verbose ) !! Loads the DFT input file implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: g , k if ( verbose ) then print * , 'Loading DFT input file...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) ! read the data call h5ltread_dataset_int_f ( file_id , 'n_k' , n_k , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_val' , n_val , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_cond' , n_cond , dims , error ) n_bands = n_val + n_cond call h5ltread_dataset_int_f ( file_id , 'n_in_G' , n_in_G , dims , error ) allocate ( in_G_grid_red ( n_in_G , 3 )) dims2 = [ n_in_G , 3 ] call h5ltread_dataset_int_f ( file_id , 'in_G_grid_red' , in_G_grid_red , dims2 , error ) dims2 = [ 3 , 3 ] call h5ltread_dataset_double_f ( file_id , 'a_vecs_A' , a_vecs_A , dims2 , error ) a_vecs = Ang_to_inv_eV * a_vecs_A red_to_xyz = transpose ( a_vecs ) call h5ltread_dataset_double_f ( file_id , 'b_vecs_A' , b_vecs_A , dims2 , error ) b_vecs = inv_Ang_to_eV * b_vecs_A k_red_to_xyz = transpose ( b_vecs ) ! convert reduced coordinates to xyz allocate ( in_G_grid_xyz ( n_in_G , 3 )) do g = 1 , n_in_G in_G_grid_xyz ( g , :) = matmul ( k_red_to_xyz , in_G_grid_red ( g , :)) end do allocate ( k_weight ( n_k )) dims = [ n_k ] call h5ltread_dataset_double_f ( file_id , 'k_weight' , k_weight , dims , error ) allocate ( k_grid_red ( n_k , 3 )) dims2 = [ n_k , 3 ] call h5ltread_dataset_double_f ( file_id , 'k_red' , k_grid_red , dims2 , error ) allocate ( k_grid_xyz ( n_k , 3 )) do k = 1 , n_k k_grid_xyz ( k , :) = matmul ( k_red_to_xyz , k_grid_red ( k , :)) end do allocate ( energy_bands_raw ( n_k , n_bands )) allocate ( energy_bands ( n_k , n_bands )) dims2 = [ n_k , n_bands ] call h5ltread_dataset_double_f ( file_id , 'energy_bands_raw' , energy_bands_raw , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) call check_DFT_parameters ( verbose ) ! find how much the wave function coefficients were expanded call get_PW_cutoffs ( verbose = verbose ) call print_DFT_parameters ( filename , verbose = verbose ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   DFT input file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine check_DFT_parameters ( verbose ) !! Check the values of of the input file to make sure they make sense implicit none logical , optional :: verbose real ( dp ), parameter :: pi = 4.0_dp * datan ( 1.0_dp ) real ( dp ) :: i_3_2pi ( 3 , 3 ) real ( dp ) :: eps_val i_3_2pi = 0.0_dp i_3_2pi ( 1 , 1 ) = 2 * pi i_3_2pi ( 2 , 2 ) = 2 * pi i_3_2pi ( 3 , 3 ) = 2 * pi ! a_i . b_j = 2*pi delta_ij eps_val = abs ( sum ( matmul ( transpose ( k_red_to_xyz ), red_to_xyz ) - i_3_2pi ) / 3.0_dp ) if ( eps_val > 1e-3_dp ) then print * , '!! ERROR !!' print * print * , '   Basis vectors are not orthonormalized correctly. a_i . b_j != 2 pi delta_ij' print * print * , '!!!!!!!!!!!' print * stop end if ! sum_k k_weight(k) = 2 eps_val = sum ( k_weight ) - 2.0_dp if ( eps_val > 1e-3_dp ) then print * , '!! ERROR !!' print * print * , '   Sum of k weights != 2' print * print * , '!!!!!!!!!!!' print * stop end if end subroutine subroutine print_DFT_parameters ( filename , verbose ) !! Prints variables defined in this moudle implicit none character ( len =* ) :: filename logical , optional :: verbose if ( verbose ) then print * , '    DFT input filename : ' , trim ( filename ) print * print * , '    Number of k points    = ' , n_k print * print * , '    Number of valence bands     = ' , n_val print * , '    Number of conduction bands  = ' , n_cond print * print * , '    Number of G points    = ' , n_in_G print * print * , '    Primitive lattice vectors : ' print * , '        a1 = ' , a_vecs_A ( 1 , :), 'Ang' print * , '        a2 = ' , a_vecs_A ( 2 , :), 'Ang' print * , '        a3 = ' , a_vecs_A ( 3 , :), 'Ang' print * print * , '    Reciprocal lattice vectors : ' print * , '        b1 = ' , b_vecs_A ( 1 , :), 'Ang&#94;(-1)' print * , '        b2 = ' , b_vecs_A ( 2 , :), 'Ang&#94;(-1)' print * , '        b3 = ' , b_vecs_A ( 3 , :), 'Ang&#94;(-1)' print * end if end subroutine subroutine get_in_wfc_FT ( filename , band_num , in_wfc_FT ) !! Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array !! with whose elements are the dimensionless block wave function !! coefficients, u_ikG implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id !! HDF5 file ID number for DFT input file integer :: band_num real ( dp ) :: in_wfc_FT_r ( n_k , n_in_G ) !! real part of the bloch wave functions in fourier space real ( dp ) :: in_wfc_FT_c ( n_k , n_in_G ) !! complex part of the bloch wave functions in fourier space complex ( dp ) :: in_wfc_FT ( n_k , n_in_G ) !! Bloch wave functions in reciprocal space integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error character ( len = 64 ) :: dataset_path_r character ( len = 64 ) :: dataset_path_c character ( len = 64 ) :: band_num_str write ( band_num_str , * ) band_num dataset_path_r = 'in_wfc_FT_r/' // trim ( adjustl ( band_num_str )) dataset_path_c = 'in_wfc_FT_c/' // trim ( adjustl ( band_num_str )) dims2 = [ n_k , n_in_G ] call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_r , in_wfc_FT_r , dims2 , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_c , in_wfc_FT_c , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) in_wfc_FT = in_wfc_FT_r + ii * in_wfc_FT_c end subroutine subroutine expand_wfc_FT_for_FFT ( n_grid ,& wfc_FT , wfc_FT_exp ,& verbose ) !! The Fourier components will generally not be defined on a !! uniform grid needed for an FFT. This subroutine puts the !! values of the Bloch coefficients in the correct place use FFT_util implicit none integer :: n_grid ( 3 ) complex ( dp ) :: wfc_FT ( n_in_G ) complex ( dp ) :: wfc_FT_exp ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) logical , optional :: verbose integer :: g integer :: FFT_idx ( 3 ) wfc_FT_exp = ( 0.0_dp , 0.0_dp ) do g = 1 , n_in_G call G_red_to_FFT_G_grid_index ( n_grid , in_G_grid_red ( g , :), FFT_idx ) wfc_FT_exp ( FFT_idx ( 1 ), FFT_idx ( 2 ), FFT_idx ( 3 )) = wfc_FT ( g ) end do end subroutine function in_wfc_at_single_pt ( band_num , x0_red , in_wfc_FT ) result ( wfc ) !! returns the wave function evaluated at a point in !! reduced coordinates at a single point !! !! av_wfc(x0)_k = sum_G e&#94;(i G.x0) wfc(G)_k implicit none integer :: band_num real ( dp ) :: x0_red ( 3 ) real ( dp ) :: x0 ( 3 ) complex ( dp ) :: phase_fac ( n_in_G ) complex ( dp ) :: wfc ( n_k ) complex ( dp ) :: in_wfc_FT ( n_k , n_in_G ) integer :: g x0 = matmul ( red_to_xyz , x0_red ) phase_fac = cmplx ( 0.0_dp , 0.0_dp , dp ) do g = 1 , n_in_G phase_fac ( g ) = exp ( ii * dot_product ( in_G_grid_xyz ( g , :), x0 )) end do wfc = matmul ( in_wfc_FT , phase_fac ) end function subroutine get_PW_cutoffs ( verbose ) !! Calculate the plane wave expansion parameters implicit none logical , optional :: verbose integer :: k , g real ( dp ) :: q_xyz ( 3 ) real ( dp ) :: q_mag q_PW_cut = 0.0_dp E_PW_cut = 0.0_dp do k = 1 , n_k do g = 1 , n_in_G q_xyz = k_grid_xyz ( k , :) + in_G_grid_xyz ( g , :) q_mag = norm2 ( q_xyz ) if ( q_mag . ge . q_PW_cut ) then q_PW_cut = q_mag end if end do end do E_PW_cut = q_PW_cut ** 2 / ( 2.0_dp * m_elec ) if ( verbose ) then print * , '    Plane wave expansion parameters : ' print * , '        E_PW_cut = ' , E_PW_cut , 'eV' print * , '        q_PW_cut = ' , q_PW_cut / 1.0e3_dp , 'keV' print * end if end subroutine subroutine do_scissor_correction ( band_gap , verbose ) implicit none logical , optional :: verbose real ( dp ) :: band_gap real ( dp ) :: scissor_correct scissor_correct = band_gap - & ( minval ( energy_bands_raw (:, n_val + 1 :)) - maxval ( energy_bands_raw (:, : n_val ))) energy_bands = 0.0_dp energy_bands (:, : n_val ) = energy_bands_raw (:, : n_val ) - scissor_correct / 2.0_dp energy_bands (:, n_val + 1 :) = energy_bands_raw (:, n_val + 1 :) + scissor_correct / 2.0_dp if ( verbose ) then print * , 'Performed scisscor correction.' print * end if end subroutine function get_w_max ( i ) result ( w_max ) !! Returns the maximum energy transfer allowed from valence state i implicit none integer :: i real ( dp ) :: w_max w_max = maxval ( energy_bands ) - minval ( energy_bands (:, i )) end function end module","tags":"","loc":"sourcefile/dft_parameters.f90.html"},{"title":"exdm.f90 – EXCEED-DM","text":"Contents Programs exdm Source Code exdm.f90 Source Code program exdm !! EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct !! detection of Dark Matter use iso_fortran_env use mpi use version_control use control_input use timing use io_input use material_input use dme_scatter implicit none integer :: proc_id !! Open MPI, processor ID integer :: n_proc !! Open MPI, number of processors integer :: root_process = 0 !! Open MPI, root processor ID integer :: err !! Open MPI error code logical :: verbose = . FALSE . !! If verbose = .TRUE., print output call MPI_INIT ( err ) call MPI_COMM_RANK ( MPI_COMM_WORLD , proc_id , err ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) if ( proc_id . eq . root_process ) then print * print * , '--------------------' print * print * , '   EXCEED-DM - v' , version print * print * , '--------------------' print * print * , 'Running on ' , n_proc , 'processors' print * , 'Compiled with ' , compiler_version () print * print * , '----------' print * ! prints output information if ( . not . quiet ) then verbose = . TRUE . else verbose = . FALSE . end if time ( 1 ) = MPI_Wtime () end if call get_command_argument ( 1 , nml_input_filename ) ! load inputs call load_control ( nml_input_filename , verbose = verbose ) call load_io ( nml_input_filename , verbose = verbose ) call load_material ( nml_input_filename , verbose = verbose ) ! create the output file if ( proc_id == root_process ) then call create_output_file ( out_filename , overwrite_output , verbose = verbose ) end if ! compute and save data if ( trim ( process ) == 'scatter' ) then call run_dme_scatter ( proc_id , root_process , out_filename , & nml_input_filename , DFT_input_filename , sto_wf_filename , & core_elec_config_filename , n_proc , save_binned_rate_if , verbose = verbose ) else print * , '!!! ERROR !!!' print * print * , '    Process : ' , trim ( process ), ' is not implemented.' print * stop end if ! save input data common to all processes if ( proc_id . eq . root_process ) then if ( verbose ) then print * , 'Saving input data...' print * end if call save_material ( out_filename , verbose = verbose ) if ( verbose ) then print * , '----------' print * end if end if ! Time program if ( proc_id . eq . root_process ) then time ( 2 ) = MPI_Wtime () if ( verbose ) then print * , 'Run time : ' print * , trim ( pretty_time_format ( time ( 2 ) - time ( 1 ))) print * print * , '----------' print * end if end if call MPI_FINALIZE ( err ) end program","tags":"","loc":"sourcefile/exdm.f90.html"},{"title":"FFT_util.f90 – EXCEED-DM","text":"Contents Modules FFT_util Source Code FFT_util.f90 Source Code module FFT_util !! Utilities for computing FFT's use prec use fftw3 implicit none real ( dp ), allocatable :: sym_FFT_G_grid_xyz (:, :, :, :) !! FFT G grid shifted so that both + and - G's are represented contains subroutine set_sym_FFT_G_grid_xyz ( n_grid , k_red_to_xyz , verbose ) !! Symmetric FFT grid. !! !! Standard convention for FFTs is to compute for frequencies 0 -> N-1. !! This subroutine creates a map which takes the larger half of the positive !! frequencies and maps then back to negative values, for a symmetric G grid. implicit none real ( dp ) :: k_red_to_xyz ( 3 , 3 ) logical , optional :: verbose integer :: g1 , g2 , g3 integer :: G_red ( 3 ) integer :: n_grid ( 3 ) allocate ( sym_FFT_G_grid_xyz ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 ), 3 )) do g3 = 1 , n_grid ( 3 ) do g2 = 1 , n_grid ( 2 ) do g1 = 1 , n_grid ( 1 ) G_red = [ g1 - 1 , g2 - 1 , g3 - 1 ] if ( g1 . gt . n_grid ( 1 ) / 2 ) then G_red ( 1 ) = g1 - n_grid ( 1 ) - 1 end if if ( g2 . gt . n_grid ( 2 ) / 2 ) then G_red ( 2 ) = g2 - n_grid ( 2 ) - 1 end if if ( g3 . gt . n_grid ( 3 ) / 2 ) then G_red ( 3 ) = g3 - n_grid ( 3 ) - 1 end if sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) = matmul ( k_red_to_xyz , G_red ) end do end do end do end subroutine subroutine set_fft_plan_forward_3d ( n_grid , fft_plan ) !! sets the FFT plan for an array with dimensinos [ n_grid ] implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_FORWARD , FFTW_PATIENT ) end subroutine subroutine set_fft_plan_backward_3d ( n_grid , fft_plan ) !! sets the FFT plan for an array with dimensinos [ n_grid ] implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_BACKWARD , FFTW_PATIENT ) end subroutine subroutine G_red_to_FFT_G_grid_index ( n_grid , G_red , idx ) !! Given a G_red vector returns the index of that vector in the FFT !! grid. implicit none integer :: idx ( 3 ) integer :: G_red ( 3 ) integer :: n_grid ( 3 ) integer :: i idx = G_red + [ 1 , 1 , 1 ] ! put negative values at the back of the array in FFTW3 convention do i = 1 , 3 if ( G_red ( i ) . lt . 0 ) then idx ( i ) = G_red ( i ) + n_grid ( i ) + 1 end if end do end subroutine end module","tags":"","loc":"sourcefile/fft_util.f90.html"},{"title":"io_input.f90 – EXCEED-DM","text":"Contents Modules io_input Source Code io_input.f90 Source Code module io_input !! Input and output file names implicit none character ( len = 512 ) :: nml_input_filename = '' !! Namelist input filename, character ( len = 512 ) :: DFT_input_filename = '' !! DFT calculations input file character ( len = 64 ) :: run_description = '' !! description of the calculation character ( len = 512 ) :: out_folder = '.' !! Ouput folder character ( len = 512 ) :: out_filename = '' !! Output filename !! !! Setting this variable overrides the settings of out_folder !! and run_description character ( len = 512 ) :: sto_wf_filename = '' !! Input file specifying the Slater type orbital (sto) !! wave function coefficients for the core electron !! states character ( len = 512 ) :: core_elec_config_filename = '' !! File specifying the core electron configuration NAMELIST / io / DFT_input_filename , & run_description , & out_folder , & out_filename , & sto_wf_filename , & core_elec_config_filename contains subroutine load_io ( filename , verbose ) !! Loads the io namelist implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = io , iostat = error ) close ( 100 ) if ( trim ( out_filename ) . eq . '' ) then if ( trim ( run_description ) . eq . '' ) then out_filename = trim ( out_folder ) // '/EXDMout.hdf5' else out_filename = trim ( out_folder ) // '/EXDMout_' // trim ( run_description ) // '.hdf5' end if end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for io parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine recursive subroutine create_output_file ( filename , overwrite_output , verbose ) !! Creates the output file use hdf5 use h5lt use prec implicit none character ( len =* ) :: filename character ( len = 512 ) :: new_filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer :: error logical :: overwrite_output real ( dp ) :: r character ( len = 64 ) :: rand_num_str inquire ( file = filename , exist = file_exists ) if ( ( . not . file_exists ) . or . ( overwrite_output ) ) then call h5open_f ( error ) call h5fcreate_f ( trim ( filename ), H5F_ACC_TRUNC_F , file_id , error ) if ( ( error . ne . 0 ) . and . verbose ) then print * , '!! ERROR !!' print * print * , '   Could not create output file : ' , trim ( filename ) print * print * , '!!!!!!!!!!!' print * stop end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!! WARNING !!' print * print * , '   Output file : ' , trim ( filename ), ' already exists.' print * end if call random_number ( r ) write ( rand_num_str , * ) int ( 10 ** 3 * r ) out_filename = './EXDMout_' // trim ( adjustl ( rand_num_str )) // '.hdf5' if ( verbose ) then print * , '   Attempting to set output filename to : ' , trim ( out_filename ) print * print * , '!!!!!!!!!!!' print * end if call create_output_file ( trim ( out_filename ), . FALSE ., verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/io_input.f90.html"},{"title":"material_input.f90 – EXCEED-DM","text":"Contents Modules material_input Source Code material_input.f90 Source Code module material_input !! Information about the target material. use hdf5 use h5lt use prec use units implicit none character ( len = 64 ) :: mat_name = '' real ( dp ) :: pc_vol_A !! Volume of the unit cell !! !! pc_vol_A = det(a_vecs) !! !! Units : Ang&#94;3 real ( dp ) :: rho_T_g_per_cm3 !! Target density !! !! Units : g/cm&#94;3 real ( dp ) :: m_T_kg = 1.0_dp !! Target mass !! !! Units : kg real ( dp ) :: band_gap = 0.0_dp !! Band gap of the target !! !! Units : eV !! Generated from input real ( dp ) :: pc_vol !! Volume of the primitive cell !! !! Units : eV&#94;(-3) real ( dp ) :: rho_T !! Target density !! !! Units : eV&#94;4 real ( dp ) :: m_T !! Target mass !! !! Units : eV NAMELIST / material / pc_vol_A , & band_gap , & rho_T_g_per_cm3 , & m_T_kg , & mat_name contains subroutine load_material ( filename , verbose ) implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = material , iostat = error ) close ( 100 ) rho_T = g_to_eV * inv_cm_to_eV ** 3 * rho_T_g_per_cm3 m_T = kg_to_eV * m_T_kg pc_vol = Ang_to_inv_eV ** 3 * pc_vol_A else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for material parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_material ( filename , verbose ) !! Saves the material properties implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , '    Saving material parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'material' , group_id , error ) ! ! write data call h5ltmake_dataset_string_f ( file_id , 'material/mat_name' ,& mat_name , error ) call h5ltmake_dataset_double_f ( file_id , 'material/band_gap' , size ( dims1 ), dims1 ,& band_gap , error ) call h5ltmake_dataset_double_f ( file_id , 'material/density' , size ( dims1 ), dims1 ,& rho_T_g_per_cm3 , error ) call h5ltmake_dataset_double_f ( file_id , 'material/target_mass' , size ( dims1 ), dims1 ,& m_T_kg , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/material_input.f90.html"},{"title":"transition.f90 – EXCEED-DM","text":"Contents Modules transition Source Code transition.f90 Source Code module transition !! Hnadles labelling of the transitions that each processor should compute !! for implicit none integer :: n_tran !! Total number of transitions !! !! = n_init*n_fin integer :: n_tran_per_proc !! Number of transitiosn each processor has to calculate integer , allocatable :: tran_to_init_fin_id (:, :) !! Dim : [n_tran, 2] !! !! Each transition (i, f) is given a unique index, and this !! is the map back. For each transition id return the initial !! or final state index integer , allocatable :: job_table (:, :) !! Dim : [n_proc, n_tran_per_proc] !! give each processor a list of transitions to compute for contains subroutine set_job_table ( n_proc , n_init , n_fin , verbose ) implicit none integer :: n_proc integer :: n_init , n_fin logical , optional :: verbose integer :: i , j , tran_id , id , f n_tran = n_init * n_fin allocate ( tran_to_init_fin_id ( n_tran , 2 )) id = 0 do i = 1 , n_init do f = 1 , n_fin id = id + 1 tran_to_init_fin_id ( id , 1 ) = i tran_to_init_fin_id ( id , 2 ) = f end do end do if ( mod ( n_tran , n_proc ) . eq . 0 ) then n_tran_per_proc = n_tran / n_proc else n_tran_per_proc = n_tran / n_proc + 1 end if allocate ( job_table ( n_proc , n_tran_per_proc )) if ( verbose ) then if ( mod ( n_tran , n_proc ) . eq . 0 ) then print * , 'Equal processor load.' print * else if ( n_tran_per_proc . eq . 1 ) then print * , 'Number of processors is greater than the number of i -> f' ,& ' transitions. Consider lowering the number of processors.' print * print * , 'Number of transitions = ' , n_tran print * else print * , 'Unequal processor load. Some processors will be given null jobs.' print * print * , 'Number of transitions = ' , n_tran print * end if print * , 'Number of calculations per processor = ' , n_tran_per_proc print * print * , '----------' print * end if tran_id = 0 do j = 1 , n_tran_per_proc do i = 1 , n_proc tran_id = tran_id + 1 if ( tran_id . gt . n_tran ) then job_table ( i , j ) = 0 else job_table ( i , j ) = tran_id end if end do end do end subroutine end module","tags":"","loc":"sourcefile/transition.f90.html"},{"title":"constants.f90 – EXCEED-DM","text":"Contents Modules constants Source Code constants.f90 Source Code module constants !! Collection of useful constants use prec implicit none real ( dp ), parameter :: m_elec = 51 1.0e3_dp !! Electron mass !! !! Units : eV real ( dp ), parameter :: alpha_EM = 1.0_dp / 13 7.0_dp !! Fine structure constant real ( dp ), parameter :: a0 = 2.681336e-4_dp !! Bohr radius !! !! Units : eV&#94;(-1) real ( dp ), parameter :: pi = 4.0_dp * atan ( 1.0_dp ) complex ( dp ), parameter :: ii = ( 0.0_dp , 1.0_dp ) !! Imaginary unit real ( dp ), parameter :: e_EM = sqrt ( 4 * pi * alpha_EM ) !! Unit of electric charge end module","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"math_mod.f90 – EXCEED-DM","text":"Contents Modules math_mod Source Code math_mod.f90 Source Code module math_mod !! A collection of useful math functions use prec use special_functions use constants implicit none contains function integrate_power_law ( b , x1 , x2 , x_s ) result ( integral ) !! !! = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy !! = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) !! !! The reason this function is non-trivial is because evaluating x**(b + 1) !! when b is large can be problematic. implicit none real ( dp ) :: b real ( dp ) :: x1 , x2 , x_s real ( dp ) :: integral real ( dp ) :: eps eps = 1.0e-8_dp if ( abs ( b + 1.0_dp ) < eps ) then integral = x_s * log ( x2 / x1 ) else integral = ( b + 1.0_dp ) ** ( - 1 ) * x1 * exp ( b * log ( x1 / x_s ) ) * & ( exp ( ( b + 1.0_dp ) * log ( x2 / x1 ) ) - 1.0_dp ) end if end function function power_law_fit ( log_x_pts , log_y_pts ) result ( fit_params ) !! Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x !! !! fit_params = [a, b] implicit none real ( dp ) :: log_x_pts ( 2 ) real ( dp ) :: log_y_pts ( 2 ) real ( dp ) :: fit_params real ( dp ) :: b if ( log_x_pts ( 2 ) > log_x_pts ( 1 ) ) then fit_params = ( log_y_pts ( 2 ) - log_y_pts ( 1 )) / ( log_x_pts ( 2 ) - log_x_pts ( 1 )) else print * , 'ERROR' end if end function function generate_uniform_points_on_sphere ( n_theta , n_phi ) result ( angular_mesh ) !! Generates an (n_thata*n_phi, 2) list of points which are uniformly !! distributed on the sphere implicit none integer :: n_theta , n_phi real ( dp ) :: angular_mesh ( n_theta * n_phi , 2 ) integer :: t , p , i real ( dp ) :: theta , phi i = 1 do t = 1 , n_theta do p = 1 , n_phi theta = acos (& 2.0_dp * (( t - 1.0_dp ) / max ( 1.0_dp , n_theta - 1.0_dp )) - 1.0_dp & ) phi = 2.0_dp * pi * ( p - 1.0_dp ) / ( max ( n_phi - 1.0_dp , 1.0_dp )) angular_mesh ( i , :) = [ theta , phi ] i = i + 1 end do end do end function function Q_func ( x , a , b , Q_max ) result ( Q ) !! Places x in an appropriate bin !! !! Q = min(Q_max, 1 + floor((x - a)/b)) implicit none integer :: Q , Q_max real ( dp ) :: x , a , b Q = min ( Q_max , 1 + floor (( x - a ) / b ) ) end function function factorial ( n ) result ( fact ) implicit none integer :: n , fact , i fact = 1 if ( n . gt . 1 ) then do i = 1 , n fact = fact * i end do end if end function recursive function sph_harmonic ( l , m , theta , phi ) result ( y_lm ) !! Spherical harmonic function with phase convention identical !! to Mathematica implicit none integer :: l , m real ( dp ) :: theta , phi , c_theta real ( dp ) :: legendre_pol real ( dp ) :: norm complex ( dp ) :: y_lm if ( m < 0 ) then y_lm = ( - 1 ) ** m * conjg ( sph_harmonic ( l , - m , theta , phi )) else c_theta = cos ( theta ) norm = sqrt (( 2 * l + 1 ) * factorial ( l - m ) / ( 4.0_dp * pi * factorial ( l + m ))) call lpmv ( 1.0_dp * l , m , c_theta , legendre_pol ) y_lm = norm * exp ( ii * m * phi ) * legendre_pol end if end function function get_phi ( n_hat ) result ( phi ) !! returns the theta value of a unit direction vector, n_hat implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: phi phi = atan2 ( n_hat ( 2 ), n_hat ( 1 )) if ( phi . lt . 0.0_dp ) then phi = phi + 2.0_dp * pi end if end function function get_theta ( n_hat ) result ( theta ) !! returns the theta value of a unit direction vector, n_hat implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: theta theta = acos ( n_hat ( 3 )) end function end module","tags":"","loc":"sourcefile/math_mod.f90.html"},{"title":"prec.f90 – EXCEED-DM","text":"Contents Modules prec Source Code prec.f90 Source Code module prec !! Precision definitions use , intrinsic :: iso_fortran_env , only : dp => real64 !! double precision (dp) definition end module","tags":"","loc":"sourcefile/prec.f90.html"},{"title":"timing.f90 – EXCEED-DM","text":"Contents Modules timing Source Code timing.f90 Source Code module timing !! Useful functions for timing a program use prec implicit none real ( dp ) :: time ( 100 ) !! holds raw timing variables real ( dp ) :: delta_t ( 100 ) !! holds difference in timing variables contains function pretty_time_format ( t ) result ( time_str ) !! Fills time_str with a nicely formatted version of time implicit none real ( dp ) :: t integer :: time_hr integer :: time_min integer :: time_sec character ( len = 512 ) :: time_str if ( t . lt . 1.0_dp ) then write ( time_str , * ) t * 10 ** 3 , 'ms' else time_hr = floor ( t / 360 0.0_dp ) time_min = floor (( t - time_hr * 360 0.0_dp ) / 6 0.0_dp ) time_sec = nint ( t - time_hr * 360 0.0_dp - time_min * 6 0.0_dp ) write ( time_str , * ) time_hr , 'hr ' , time_min , 'min' , time_sec , 's' end if end function end module","tags":"","loc":"sourcefile/timing.f90.html"},{"title":"units.f90 – EXCEED-DM","text":"Contents Modules units Source Code units.f90 Source Code module units !! Unit conversion factors !! !! If a variable has units of x to convert to units y: !! !! var_y = x_to_y * var_x use prec implicit none real ( dp ) :: inv_Ang_to_eV = 197 3.37_dp real ( dp ) :: inv_eV_to_cm = 1.97327e-5_dp real ( dp ) :: Ang_to_inv_eV = 5.068e-4_dp real ( dp ) :: g_to_eV = 5.61e32_dp real ( dp ) :: kg_to_eV = 5.61e35_dp real ( dp ) :: inv_cm_to_eV = 1.97327e-5_dp real ( dp ) :: km_per_sec_to_none = 3.33563e-6_dp end module","tags":"","loc":"sourcefile/units.f90.html"},{"title":"version_control.f90 – EXCEED-DM","text":"Contents Modules version_control Source Code version_control.f90 Source Code module version_control !! Keeps track of the current version of the program implicit none character ( len = 64 ) :: version = \"0.1.0\" end module","tags":"","loc":"sourcefile/version_control.f90.html"},{"title":"dme_scatter.f90 – EXCEED-DM","text":"Contents Modules dme_scatter Source Code dme_scatter.f90 Source Code module dme_scatter !! Perform DM-electron scattering rate calculations use mpi use hdf5 use h5lt use prec use control_input use particle_physics_scatter use numerics_input use in_med_scr use transition use dme_scatter_vc use dme_scatter_cc use dme_scatter_vf use dme_scatter_cf implicit none real ( dp ), allocatable :: binned_rate_t_scatter (:, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_tran_per_proc] !! !! Binned rate allocated on each processor, for each job to compute for !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_if_scatter (:, :, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init, n_fin] !! !! Binned rate between all transitions !! !! Warning : memory intensive !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_i_scatter (:, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init] !! !! Binned rate, summed over final states !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_scatter (:, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time] !! !! Binned rate summed over all transitions !! !! Units : eV&#94;2 real ( dp ), allocatable :: rate_scatter (:, :, :) !! Dim : [n_mX, n_FDM, n_time] !! !! Total rate summed over all transitions !! !! Units : eV&#94;2 character ( len = 64 ) :: calc_modes_list ( 4 ) = [ 'vc' , 'vf' , 'cc' , 'cf' ] contains subroutine run_dme_scatter ( proc_id , root_process , & out_filename , nml_filename , DFT_input_filename , sto_wf_filename , & core_elec_config_filename , n_proc , save_binned_rate_if , verbose ) !! Scattering rate calculation implicit none integer :: proc_id integer :: root_process integer :: n_proc character ( len =* ) :: out_filename character ( len =* ) :: nml_filename character ( len =* ) :: DFT_input_filename character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename logical :: save_binned_rate_if logical , optional :: verbose integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: t , i call load_particle_physics_scatter ( nml_filename , verbose = verbose ) call load_numerics ( nml_filename , verbose = verbose ) call load_in_med_scr ( nml_filename , verbose = verbose ) call set_job_table ( n_proc , n_init , n_fin , verbose = verbose ) ! allocate arrays if ( proc_id == root_process ) then if ( save_binned_rate_if ) then allocate ( binned_rate_if_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_init , n_fin )) binned_rate_if_scatter = 0.0_dp if ( ( n_q_bins + 1 ) * ( n_E_bins + 1 ) * n_mX * n_FDM * n_time * n_init * n_fin * 8.0_dp > 1.0e10_dp ) then if ( verbose ) then print * , '!!! WARNING !!!' print * print * , '   Attempting to store more than 10 GB of data in binned_rate_if. If this is unwanted behavior' print * , '   set save_binned_rate_if = .FALSE. in the control namelist.' print * print * , '!!!!!!!!!!!!!!!' end if end if end if allocate ( binned_rate_i_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_init )) binned_rate_i_scatter = 0.0_dp allocate ( binned_rate_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time )) binned_rate_scatter = 0.0_dp allocate ( rate_scatter ( n_mX , n_FDM , n_time )) rate_scatter = 0.0_dp end if allocate ( binned_rate_t_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_tran_per_proc )) binned_rate_t_scatter = 0.0_dp ! specific calc modes to compute binned_rate_t_scatter ! the subroutines here have one purpose and that is to compute ! the binned rate for a given transition id if ( trim ( calc_mode ) . eq . 'vc' ) then call run_dme_scatter_vc ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'cc' ) then call run_dme_scatter_cc ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & sto_wf_filename , core_elec_config_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'vf' ) then call run_dme_scatter_vf ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & nml_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'cf' ) then call run_dme_scatter_cf ( binned_rate_t_scatter , n_tran_per_proc , sto_wf_filename , & core_elec_config_filename , nml_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( verbose ) then print * , 'Calculation mode : ' , trim ( calc_mode ), ' is not a valid option. Options are : ' do i = 1 , size ( calc_modes_list ) print * , '    ' , trim ( calc_modes_list ( i )) print * end do end if end if ! sends data to the main node if ( proc_id . ne . root_process ) then call MPI_SEND ( binned_rate_t_scatter , & size ( binned_rate_t_scatter ), MPI_DOUBLE , root_process , tag , MPI_COMM_WORLD , err ) end if if ( proc_id . eq . root_process ) then ! add main processors contribution call update_rates ( binned_rate_t_scatter , proc_id ) do i = 1 , n_proc if ( ( i - 1 ) . ne . root_process ) then call MPI_RECV ( binned_rate_t_scatter , & size ( binned_rate_t_scatter ), MPI_DOUBLE , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! add other processors contributions call update_rates ( binned_rate_t_scatter , i - 1 ) end if end do end if ! save data if ( proc_id . eq . root_process ) then call save_particle_physics_scatter ( out_filename , verbose = verbose ) call save_numerics ( out_filename , verbose = verbose ) call save_in_med_scr ( out_filename , verbose = verbose ) call save_rates ( out_filename , verbose = verbose ) end if end subroutine subroutine update_rates ( binned_rate_t , proc_id ) !! updates all the rate arrays with the output !! of a single processors results implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_tran_per_proc ) integer :: i , f , m , t integer :: proc_id integer :: tran_id do i = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , i ) if ( tran_id . ne . 0 ) then if ( save_binned_rate_if ) then binned_rate_if_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 ), & tran_to_init_fin_id ( tran_id , 2 ) ) = & binned_rate_if_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 ), & tran_to_init_fin_id ( tran_id , 2 ) ) + binned_rate_t (:, :, :, :, :, i ) end if binned_rate_i_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 )) = & binned_rate_i_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 )) + binned_rate_t (:, :, :, :, :, i ) binned_rate_scatter = binned_rate_scatter + binned_rate_t (:, :, :, :, :, i ) do t = 1 , n_time do f = 1 , n_FDM do m = 1 , n_mX rate_scatter ( m , f , t ) = rate_scatter ( m , f , t ) + & sum ( binned_rate_t (:, :, m , f , t , i )) end do end do end do end if end do end subroutine ! save data functions subroutine save_rates ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: m , f , t integer :: i , fin character ( len = 64 ) :: m_str , t_str , f_str character ( len = 64 ) :: i_str , fin_str if ( verbose ) then print * , '    Saving scattering rates...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'rates' , group_id , error ) dims2 = [ n_q_bins + 1 , n_E_bins + 1 ] do t = 1 , n_time write ( t_str , * ) t t_str = trim ( adjustl ( t_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ),& group_id , error ) do f = 1 , n_FDM write ( f_str , * ) f f_str = trim ( adjustl ( f_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ),& group_id , error ) do m = 1 , n_mX write ( m_str , * ) m m_str = trim ( adjustl ( m_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/total' , & size ( dims1 ), dims1 ,& rate_scatter ( m , f , t ), error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/total_binned' , & size ( dims2 ), dims2 ,& binned_rate_scatter (:, :, m , f , t ), error ) do i = 1 , n_init write ( i_str , * ) i i_str = trim ( adjustl ( i_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/binned_i' , & size ( dims2 ), dims2 ,& binned_rate_i_scatter (:, :, m , f , t , i ), error ) if ( save_binned_rate_if ) then do fin = 1 , n_fin write ( fin_str , * ) fin fin_str = trim ( adjustl ( fin_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/binned_if' ,& size ( dims2 ), dims2 ,& binned_rate_if_scatter (:, :, m , f , t , i , fin ), error ) end do end if end do end do end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/dme_scatter.f90.html"},{"title":"in_med_scr.f90 – EXCEED-DM","text":"Contents Modules in_med_scr Source Code in_med_scr.f90 Source Code module in_med_scr !! Handle analytic/numeric dielectric or other in medium effects which screen the interaction !! !! rate ~ 1/screen&#94;2 use hdf5 use h5lt use prec use constants implicit none character ( len = 64 ) :: screen_type = '' !!! !! Eq 6 from !!      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 real ( dp ) :: di_e0 real ( dp ) :: di_q_tf real ( dp ) :: di_omega_p real ( dp ) :: di_alpha !!! logical :: include_screen = . TRUE . !! toggle whether screening effects are included or not NAMELIST / in_medium / screen_type ,& di_e0 , & di_q_tf , & di_omega_p , & di_alpha , & include_screen contains subroutine load_in_med_scr ( filename , verbose ) implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = in_medium , iostat = error ) close ( 100 ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for in medium effects : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_in_med_scr ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , '    Saving screening parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'in_med_screening' , group_id , error ) ! ! write data call h5ltmake_dataset_string_f ( file_id , 'in_med_screening/screen_type' ,& screen_type , error ) if ( trim ( screen_type ) == 'analytic' ) then call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_e0' , size ( dims1 ), dims1 ,& di_e0 , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_alpha' , size ( dims1 ), dims1 ,& di_alpha , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_q_tf' , size ( dims1 ), dims1 ,& di_q_tf , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_omega_p' , size ( dims1 ), dims1 ,& di_omega_p , error ) end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine function screening ( q_vec , omega ) result ( scr ) implicit none real ( dp ) :: q_vec ( 3 ) real ( dp ) :: omega real ( dp ) :: scr if ( include_screen ) then if ( trim ( screen_type ) . eq . 'analytic' ) then scr = model_dielectric ( q_vec , omega , & di_e0 , & di_q_tf , & di_alpha , & di_omega_p ) else scr = 1.0_dp end if else scr = 1.0_dp end if end function function model_dielectric ( q_vec , omega ,& e0 , q_tf , alpha , omega_p ) result ( di ) !! Analytic form of the dielectric function !! Eq 6 from !!      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 implicit none real ( dp ) :: di real ( dp ) :: e0 , q_tf , alpha , omega_p real ( dp ) :: q_vec ( 3 ) real ( dp ) :: q_mag real ( dp ) :: omega q_mag = norm2 ( q_vec ) di = 1.0_dp + ( ( e0 - 1.0_dp ) ** ( - 1 ) + & alpha * ( q_mag / q_tf ) ** 2 + & q_mag ** 4 / ( 4 * m_elec ** 2 * omega_p ** 2 ) - & ( omega / omega_p ) ** 2 ) ** ( - 1 ) end function end module","tags":"","loc":"sourcefile/in_med_scr.f90.html"},{"title":"numerics_input.f90 – EXCEED-DM","text":"Contents Modules numerics_input Source Code numerics_input.f90 Source Code module numerics_input !! Variables relating to binning and other numerics use hdf5 use h5lt use prec implicit none real ( dp ) :: q_bin_width = 1.0e3_dp !! width of momuntum bins !! !! Units : eV integer :: n_q_bins = 0 !! Number of q bins, with bin width q_bin_width, to save !! !! Note: momentum transfers greater than n_q_bins*q_bin_width !! will be stored in the last, extra bin real ( dp ) :: E_bin_width = 1.0_dp !! Width of the energy bins !! !! Units : eV integer :: n_E_bins = 0 !! Number of E bins, with bin width E_bin_width, to save !! !! Note: energy transfers greater than n_E_bins*E_bin_width !! will be stored in the last, extra bin integer :: E_bin_threshold = 1 !! smallest E bin added to total rate calculation !! default : 1 - include all bins real ( dp ) :: Ef_max = 6 0.0_dp !! maximum final state energy to include in calculations !! !! Units : eV !! !! TODO : E_cut is a more appropriate name integer :: n_init !! number of initial states integer :: n_fin !! number of final states integer :: n_FFT_grid_input ( 3 ) = [ 0 , 0 , 0 ] !! Default size of the FFT, used to extend core !! calculation by making the size of the FFT larger !! !! Note : only used in calculations which use the FFT real ( dp ) :: q_s_FFT = 215 1.0_dp / 2.0_dp !! Units : eV !! !! q_max_FFT = q_s_FFT*N_FFT !! !! Minimum eigenvalue of k_red_to_xyz matrix !! !! Note : only used in calculations which use the FFT !! !! TODO : do not hard code this in integer :: n_kf_theta = 1 !! Number of theta points in integration of kf !! !! Note : only used in free calculatinos integer :: n_kf_phi = 1 !! Number of phi points in integration of kf !! !! Note : only used in free calculatinos integer :: n_ki_theta = 1 !! Number of theta points in integration of ki !! !! Note : only used in core -> free calculatinos integer :: n_ki_phi = 1 !! Number of phi points in integration of ki !! !! Note : only used in core -> free calculatinos real ( dp ) :: ki_s = 10 0.0_dp !! Scale parameter for k_i momentum to integrate over in core -> free calculation !! !! maximum initial electron momentum  = ki_s * Z * alpha * m_e !! !! Generally want this to be >> Z alpha m_e, the scale factor of the electron wave functions integer :: n_ki = 2 !! Number of radial points in integration of ki real ( dp ) :: ki_min = 1.0e3_dp !! Minimum electron momentum !! !! Units : eV NAMELIST / numerics / q_bin_width , & n_q_bins , & E_bin_width , & n_E_bins , & E_bin_threshold , & Ef_max , & n_init , & n_fin , & q_s_FFT , & n_FFT_grid_input , & n_kf_theta , & n_kf_phi , & n_ki , & n_ki_theta , & n_ki_phi , & ki_s , & ki_min contains subroutine load_numerics ( filename , verbose ) implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics , iostat = error ) close ( 100 ) call print_numerics ( verbose = verbose ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for numerics parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_numerics ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , 'Numerics' print * print * , '   Number of E bins = ' , n_E_bins , ' + 1' print * , '   Energy bin width = ' , E_bin_width , 'eV' print * print * , '   Number of q bins = ' , n_q_bins , ' + 1' print * , '   q bin width      = ' , q_bin_width / 1.0e3_dp , 'keV' print * print * , '----------' print * end if end subroutine subroutine save_numerics ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , '    Saving numerics...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'numerics/n_E_bins' , size ( dims1 ), dims1 ,& n_E_bins + 1 , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_q_bins' , size ( dims1 ), dims1 ,& n_q_bins + 1 , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_init' , size ( dims1 ), dims1 ,& n_init , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_fin' , size ( dims1 ), dims1 ,& n_fin , error ) call h5ltmake_dataset_double_f ( file_id , 'numerics/E_bin_width' , size ( dims1 ), dims1 ,& E_bin_width , error ) call h5ltmake_dataset_double_f ( file_id , 'numerics/q_bin_width' , size ( dims1 ), dims1 ,& q_bin_width , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/E_bin_threshold' , size ( dims1 ), dims1 ,& E_bin_threshold , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/numerics_input.f90.html"},{"title":"particle_physics_scatter.f90 – EXCEED-DM","text":"Contents Modules particle_physics_scatter Source Code particle_physics_scatter.f90 Source Code module particle_physics_scatter !! Particle physics parameters needed for a DM-electron !! scattering rate calculation use hdf5 use h5lt use prec use constants use units implicit none integer :: n_mX = 1 !! Number of masses to compute for real ( dp ) :: log_mmin = 9.0_dp real ( dp ) :: log_mmax = 9.0_dp integer :: n_extra_mX = 0 !! Optional !! !! User can specify extra mass points to add in addition to !! the log-uniform ones chosen integer :: n_FDM = 1 !! Number of mediator types to compute for real ( dp ) :: FDMPower_min = 0.0_dp real ( dp ) :: FDMPower_max = 0.0_dp integer :: n_time = 1 !! Number of time of days to compute for real ( dp ) :: time_day_min = 0.0_dp real ( dp ) :: time_day_max = 0.0_dp real ( dp ) :: percentile_cut = 3.0_dp real ( dp ) :: rhoX_GeV_per_cm3 = 0.4_dp !! Dark matter density !! !! Units : GeV/cm&#94;3 real ( dp ) :: v0_km_per_sec = 23 0.0_dp real ( dp ) :: vE_km_per_sec = 24 0.0_dp real ( dp ) :: vEsc_km_per_sec = 60 0.0_dp real ( dp ) :: thetaE = ( 4 2.0_dp / 18 0.0_dp ) * pi !rad !! Generated !!!!!!! real ( dp ) :: rhoX !! Dark matter density !! !! Units : eV&#94;4 real ( dp ) :: v0 real ( dp ) :: vE real ( dp ) :: vEsc real ( dp ), allocatable :: mX (:) real ( dp ), allocatable :: mX_2 (:) real ( dp ), allocatable :: FDMPowerList (:) real ( dp ), allocatable :: timeOfDayList (:) real ( dp ), allocatable :: vEVecList (:, :) !! Dim : [n_times, 3] real ( dp ) :: g_func_N0 real ( dp ) :: g_func_c1 , g_func_c2 real ( dp ) :: v_max !! = vE + vEsc NAMELIST / particle_physics / n_mX , & log_mmin , & log_mmax , & n_extra_mX , & n_FDM , & FDMPower_min , & FDMPower_max , & n_time , & time_day_min , & time_day_max , & percentile_cut , & rhoX_GeV_per_cm3 , & v0_km_per_sec , & vE_km_per_sec , & vEsc_km_per_sec NAMELIST / extra_mX / mX_2 contains subroutine print_particle_physics_scatter ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , 'Dark Matter properties' print * print * , '   Masses : ' , mX print * print * , '   -d log F_DM / d log q : ' , FDMPowerList print * print * , '   Velocity distribution parameters : ' print * , '       v0   = ' , v0_km_per_sec , ' km/sec' print * , '       vE   = ' , vE_km_per_sec , ' km/sec' print * , '       vEsc = ' , vEsc_km_per_sec , ' km/sec' print * print * , '   Times : ' , timeOfDayList print * print * , '----------' print * end if end subroutine subroutine load_particle_physics_scatter ( filename , verbose ) implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = particle_physics , iostat = error ) rewind ( 100 ) rhoX = inv_cm_to_eV ** 3 * 1.0e9_dp * rhoX_GeV_per_cm3 v0 = km_per_sec_to_none * v0_km_per_sec vE = km_per_sec_to_none * vE_km_per_sec vEsc = km_per_sec_to_none * vEsc_km_per_sec v_max = vE + vEsc if ( n_extra_mX . ne . 0 ) then allocate ( mX_2 ( n_extra_mX )) mX_2 = 1.0e9_dp read ( 100 , nml = extra_mX , iostat = error ) rewind ( 100 ) end if close ( 100 ) call set_g_func_parameters () call set_mX ( verbose ) call set_FDM_powers ( verbose ) call set_time_vE_vec ( verbose ) call print_particle_physics_scatter ( verbose = verbose ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for material parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_particle_physics_scatter ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , '    Saving particle physics parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'particle_physics' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_mX' , size ( dims1 ), dims1 ,& n_mX , error ) call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_FDM' , size ( dims1 ), dims1 ,& n_FDM , error ) call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_time' , size ( dims1 ), dims1 ,& n_time , error ) dims1 = [ n_mX ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/mX' , size ( dims1 ), dims1 ,& mX , error ) dims1 = [ n_FDM ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/FDM_list' , size ( dims1 ), dims1 ,& FDMPowerList , error ) dims1 = [ n_time ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/t_list' , size ( dims1 ), dims1 ,& timeOfDayList , error ) dims2 = [ n_time , 3 ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vE_list' , size ( dims2 ), dims2 ,& vEVecList , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/v0' , size ( dims1 ), dims1 ,& v0 , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vEsc' , size ( dims1 ), dims1 ,& vEsc , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vE' , size ( dims1 ), dims1 ,& vE , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine set_mX ( verbose ) implicit none logical :: verbose integer :: m n_mX = n_mX + n_extra_mX allocate ( mX ( n_mX )) do m = 1 , n_mX - n_extra_mX mX ( m ) = 1 0.0_dp ** ( log_mmin + ( log_mmax - log_mmin ) * & ( m - 1 ) / ( max ( 1 , n_mX - n_extra_mX - 1 ))& ) end do if ( n_extra_mX . ne . 0 ) then mX ( n_mX - n_extra_mX + 1 :) = mX_2 end if end subroutine subroutine set_g_func_parameters () implicit none ! precomputed constants for the g function defined in the physics module g_func_N0 = ( pi * v0 ** 3 ) * ( sqrt ( pi ) * erf ( vEsc / v0 ) - 2 * ( vEsc / v0 ) * exp ( - ( vEsc / v0 ) ** 2 )) g_func_c1 = ( 2 * pi ** 2 * v0 ** 2 / g_func_N0 ) g_func_c2 = exp ( - ( vEsc / v0 ) ** 2 ) end subroutine subroutine set_FDM_powers ( verbose ) implicit none logical :: verbose integer :: f allocate ( FDMPowerList ( n_FDM )) do f = 1 , n_FDM FDMPowerList ( f ) = FDMPower_min + & ( FDMPower_max - FDMPower_min ) * ( f - 1 ) / ( max ( 1 , n_FDM - 1 )) end do end subroutine subroutine set_time_vE_vec ( verbose ) implicit none logical :: verbose integer :: t allocate ( timeOfDayList ( n_time )) allocate ( vEVecList ( n_time , 3 )) do t = 1 , n_time timeOfDayList ( t ) = time_day_min + ( time_day_max - time_day_min ) * & ( t - 1.0_dp ) / ( max ( 1 , n_time - 1 )) vEVecList ( t , 1 ) = vE * sin ( thetaE ) * sin ( 2.0_dp * PI * timeOfDayList ( t )) vEVecList ( t , 2 ) = vE * cos ( thetaE ) * sin ( thetaE ) * ( cos ( 2.0_dp * PI * timeOfDayList ( t )) - 1 ) vEVecList ( t , 3 ) = vE * (( sin ( thetaE ) ** 2 ) * cos ( 2.0_dp * PI * timeOfDayList ( t )) & + cos ( thetaE ) ** 2 ) end do end subroutine function v_minus ( q_vec , mX , vE_vec , omega ) result ( v_m ) !! v_- function !! !! v_- = (1/q)| q_vec . vE + q&#94;2/mX + w | !! !! Note that we will explicitly check that this value is < v_Esc so that !! the g function is always > 0 !! !! Units : None implicit none real ( dp ) :: mX , omega real ( dp ) :: q_mag real ( dp ) :: v_m real ( dp ) :: q_vec ( 3 ) real ( dp ) :: vE_vec ( 3 ) q_mag = norm2 ( q_vec ) v_m = ( 1 / q_mag ) * abs ( dot_product ( q_vec , vE_vec ) + 0.5_dp * q_mag ** 2 / mX + omega ) end function function g_func ( q , v_m ) result ( g_fun ) !! Kinematic function : !! !! g_func = 2*pi*int d&#94;3v f_chi(v) delta(w - w_q) !! !! Units : eV&#94;(-1) implicit none real ( dp ) :: q , v_m real ( dp ) :: g_fun g_fun = ( g_func_c1 / q ) * ( exp ( - ( v_m / v0 ) ** 2 ) - g_func_c2 ) end function function red_mass ( m1 , m2 ) result ( mu ) !! Reduced mass implicit none real ( dp ) :: m1 , m2 , mu mu = m1 * m2 / ( m1 + m2 ) end function function F_med_sq_func ( q_mag , power ) result ( F_med_sq_val ) !! Mediator for factor squared !! !! Units : None implicit none real ( dp ) :: q_mag real ( dp ) :: F_med_sq_val real ( dp ) :: power f_med_sq_val = ( alpha_EM * m_elec / q_mag ) ** ( 2 * power ) end function end module","tags":"","loc":"sourcefile/particle_physics_scatter.f90.html"},{"title":"Zeff_input.f90 – EXCEED-DM","text":"Contents Modules Zeff_input Source Code Zeff_input.f90 Source Code module Zeff_input !! Loads the Zeff paramters for the free calculation use prec use DFT_parameters use core_electrons implicit none character ( len = 64 ) :: Zeff_type = 'one' !! Specify what Zeff to use !! !! - 'one' - all Zeff = 1 !! - 'Eb' - use the binding energy of the (valence) state !! - 'Eb_c' - use the binding energy of the (core) state !! - 'in' - specified by the input real ( dp ) :: n_Eb = 1.0_dp !! n to use when computing Z_eff with the binding energy approximation real ( dp ) :: val_Zeff_in ( 100 ) = 1.0_dp NAMELIST / Zeff / Zeff_type , & n_Eb , & val_Zeff_in contains subroutine load_Zeff_parameters ( filename , verbose ) implicit none character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = Zeff , iostat = error ) close ( 100 ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for Zeff parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine function get_val_Z_eff ( i , k ) result ( Zeff ) !! returns the Z_eff value of the valence state implicit none real ( dp ) :: Zeff integer :: i , k real ( dp ) :: Eb !! binding energy if ( trim ( Zeff_type ) == 'one' ) then Zeff = 1.0_dp else if ( trim ( Zeff_type ) == 'Eb' ) then Eb = maxval ( energy_bands (:, : n_val )) - energy_bands ( k , i ) Zeff = n_Eb * sqrt ( Eb / 1 3.6_dp ) Zeff = max ( Zeff , 1.0_dp ) else if ( trim ( Zeff_type ) == 'Eb_c' ) then Eb = - core_energy ( i ) n_Eb = core_elec_conf ( i , 2 ) Zeff = n_Eb * sqrt ( Eb / 1 3.6_dp ) Zeff = max ( Zeff , 1.0_dp ) else if ( trim ( Zeff_type ) == 'in' ) then Zeff = val_Zeff_in ( i ) end if end function end module","tags":"","loc":"sourcefile/zeff_input.f90.html"},{"title":"calc_dme_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules calc_dme_scatter_cc Source Code calc_dme_scatter_cc.f90 Source Code module calc_dme_scatter_cc !! Holds the subroutine which calculates the binned rate for the cc calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use core_electrons use FFT_util use in_med_scr implicit none contains subroutine dme_scatter_cc_calc ( binned_rate_t ,& wfc_i ,& wfc_FT_f ,& init_id , cond_id , & n_FFT_grid ,& k_cut , & wfc_FFT_plan , Tif_FFT_plan ,& verbose ) implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G ) complex ( dp ) :: wfc_FT_f_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: T_if ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: f_G ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: k_cut integer :: init_id , cond_id integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose integer :: ki , kf integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max , q_max_FFT real ( dp ) :: omega , omega_max , Ei , Ef real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: scr integer :: q_bin_num , E_bin_num integer :: n_FFT real ( dp ) :: f_sq_val b_rate = 0.0_dp wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) T_if = ( 0.0_dp , 0.0_dp ) f_G = ( 0.0_dp , 0.0_dp ) f_sq = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) q_max_FFT = n_FFT_grid ( 1 ) * q_s_FFT Ei = core_energy ( init_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) - minval ( energy_bands (:, n_val + 1 :)) omega = Ef - Ei E_bin_num = Q_func ( omega , band_gap , E_bin_width , n_E_bins + 1 ) if ( ( E_bin_num >= E_bin_threshold ) . and . & ( Ef <= Ef_max ) ) then call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :), wfc_FT_f_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp , wfc_f ) T_if = conjg ( wfc_f ) * wfc_i f_G = ( 0.0_dp , 0.0_dp ) call dfftw_execute_dft ( Tif_fft_plan , T_if , f_G ) f_sq = abs ( f_G ) ** 2 ! particle physics do m = 1 , n_mX omega_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega < omega_max ) then q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& q_max_FFT , & mX ( m ) * v_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) + sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m < vEsc ) then g_func_val = g_func ( q_mag , v_m ) b_rate ( q_bin_num , E_bin_num , m , :, t ) = & b_rate ( q_bin_num , E_bin_num , m , :, t ) + & 2.0_dp * k_weight ( kf ) * & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if end do ! add overall constants do m = 1 , n_mX b_rate (:, :, m , :, :) = ( core_elec_conf ( init_id , 5 ) * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 2 ) * & red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * & ( 1.0_dp * n_FFT ) ** ( - 2 ) * b_rate (:, :, m , :, :) end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_dme_scatter_cc.f90.html"},{"title":"dme_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules dme_scatter_cc Source Code dme_scatter_cc.f90 Source Code module dme_scatter_cc !! Compute the scattering rate from core to conduction states use prec use numerics_input use material_input use DFT_parameters use core_electrons use FFT_util use transition use calc_dme_scatter_cc implicit none contains subroutine run_dme_scatter_cc ( binned_rate_t , n_tran_per_proc , DFT_input_filename , & sto_wf_filename , core_elec_config_filename , out_filename ,& proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t integer :: tran_id integer :: init_id , cond_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename integer :: n_FFT_grid ( 3 ) integer :: n_FFT integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) complex ( dp ), allocatable :: wfc_i (:, :, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) ! calculation setup call load_DFT_parameters ( trim ( DFT_input_filename ), verbose = verbose ) call load_core_elec_config ( trim ( core_elec_config_filename ), verbose = verbose ) call load_core_sto_data ( trim ( sto_wf_filename ), verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) ! doubled to avoid wrapping problems n_FFT_grid ( 1 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 1 )) - minval ( in_G_grid_red (:, 1 ))) + 1 , & n_FFT_grid_input ( 1 )) n_FFT_grid ( 2 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 2 )) - minval ( in_G_grid_red (:, 2 ))) + 1 , & n_FFT_grid_input ( 2 )) n_FFT_grid ( 3 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 3 )) - minval ( in_G_grid_red (:, 3 ))) + 1 , & n_FFT_grid_input ( 3 )) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) if ( verbose ) then print * , 'Dimensions of FFT grid : ' print * , n_FFT_grid print * print * , 'Number of G points in FFT grid = ' , n_FFT print * print * , '----------' print * end if call set_fft_plan_backward_3d ( n_FFT_grid , wfc_fft_plan ) call set_fft_plan_backward_3d ( n_FFT_grid , Tif_fft_plan ) call set_sym_FFT_G_grid_xyz ( n_FFT_grid , k_red_to_xyz , verbose = verbose ) ! time calculation allocate ( wfc_FT_f ( n_k , n_in_G )) allocate ( wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 ))) wfc_i = ( 0.0_dp , 0.0_dp ) ! do calculation if ( verbose ) then print * , 'Calculating rate...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then init_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val call calc_core_sto_wf_grid ( wfc_i , init_id , n_FFT_grid , red_to_xyz , & shift = . TRUE ., verbose = verbose ) wfc_i = sqrt ( pc_vol ) * wfc_i call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) call dme_scatter_cc_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_i , wfc_FT_f , init_id , cond_id , n_FFT_grid , n_k , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) end if end do if ( verbose ) then print * , '----------' print * end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) call save_core_electrons ( out_filename , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/dme_scatter_cc.f90.html"},{"title":"calc_dme_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules calc_dme_scatter_cf Source Code calc_dme_scatter_cf.f90 Source Code module calc_dme_scatter_cf !! Holds the subroutine which calculates the binned rate for the cf calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use in_med_scr use Zeff_input use core_electrons implicit none contains subroutine dme_scatter_cf_calc ( binned_rate_t , init_id , log_omegas , & ki_cut , ki_angular_mesh , kf_angular_mesh , verbose ) implicit none logical , optional :: verbose real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: dRdw ( n_q_bins + 1 , 2 , n_mX , n_FDM , n_time ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) integer :: init_id real ( dp ) :: log_omegas ( 2 ) integer :: ki_cut real ( dp ) :: ki_angular_mesh ( n_ki_theta * n_ki_phi , 2 ) real ( dp ) :: kf_angular_mesh ( n_kf_theta * n_kf_phi , 2 ) real ( dp ) :: Ei , Ef , omega , log_omega real ( dp ) :: omega_1 , omega_2 , E1 , E2 real ( dp ) :: log_omega_bounds ( 2 ) real ( dp ) :: ki_vec ( 3 ), ki_mag , ki_theta , ki_phi real ( dp ) :: ki_max real ( dp ) :: jac_ki real ( dp ) :: kf_vec ( 3 ), kf_mag , kf_theta , kf_phi real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max integer :: q_bin_num real ( dp ) :: v_m , g_func_val real ( dp ) :: Zeff real ( dp ) :: fermi_val , fermi_factor real ( dp ) :: scr real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: f_sq real ( dp ) :: omega_kin_max real ( dp ) :: log_dRdw ( 2 ) real ( dp ) :: fit_params integer :: i , a , b , t , ki , kf , m , q , f , e b_rate = 0.0_dp dRdw = 0.0_dp Ei = core_energy ( init_id ) Zeff = get_val_Z_eff ( init_id , 1 ) ki_max = ki_s * Zeff * alpha_EM * m_elec do m = 1 , n_mX omega_kin_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega_kin_max > 1 0.0_dp ** log_omegas ( 1 ) ) then log_omega_bounds ( 1 ) = log_omegas ( 1 ) log_omega_bounds ( 2 ) = min ( log10 ( omega_kin_max ), log_omegas ( 2 )) do i = 1 , 2 omega = 1 0.0_dp ** log_omega_bounds ( i ) q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = mX ( m ) * v_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) Ef = Ei + omega if ( ( Ef > 0.0_dp ) . and . ( Ef > Ef_max ) ) then kf_mag = sqrt ( 2.0_dp * m_elec * Ef ) fermi_val = 2.0_dp * pi * Zeff * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do ki = 1 , ki_cut ki_mag = ( ki_max / ki_min ) ** (( ki - 1.0_dp ) / ( n_ki - 1.0_dp )) * ki_min jac_ki = ( 1.0_dp / n_ki ) * ki_mag ** 3 * log10 ( ki_max / ki_min ) do a = 1 , n_ki_theta * n_ki_phi ki_theta = ki_angular_mesh ( a , 1 ) ki_phi = ki_angular_mesh ( a , 2 ) ki_vec ( 1 ) = ki_mag * sin ( ki_theta ) * cos ( ki_phi ) ki_vec ( 2 ) = ki_mag * sin ( ki_theta ) * sin ( ki_phi ) ki_vec ( 3 ) = ki_mag * cos ( ki_theta ) f_sq = abs ( core_sto_wf_FT ( init_id , ki_vec )) ** 2 do b = 1 , n_kf_theta * n_kf_phi kf_theta = kf_angular_mesh ( b , 1 ) kf_phi = kf_angular_mesh ( b , 2 ) kf_vec ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) kf_vec ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) kf_vec ( 3 ) = kf_mag * cos ( kf_theta ) q_vec = kf_vec - ki_vec q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) scr = screening ( q_vec , omega ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m . lt . vEsc ) then g_func_val = g_func ( q_mag , v_m ) dRdw ( q_bin_num , i , m , :, t ) = dRdw ( q_bin_num , i , m , :, t ) + & fermi_factor * & F_med_sq * & g_func_val * & f_sq * & jac_ki * & m_elec * kf_mag * scr ** ( - 2 ) end if end do end if end do end do end do end if end do ! add overall constants dRdw (:, :, m , :, :) = ( core_elec_conf ( i , 5 ) * pi ) * ( rhoX / rho_T ) * & ( pc_vol ) ** ( - 1 ) * red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * mX ( m ) ** ( - 1 ) * & ( 2 * pi ) ** ( - 6 ) * ( 4 * pi ) / ( 1.0_dp * n_ki_theta * n_ki_phi ) * & ( 4 * pi ) / ( 1.0_dp * n_kf_theta * n_kf_phi ) * & dRdw (:, :, m , :, :) ! now that dRdw has been computed at the end points we need to interpolate and integrate ! to get the binned rate ! our interpolating function is dRdw = dRdw(1)*(w/w_1)**b ! This procedure is equivalent to saving dRdw and interpolating later do q = 1 , n_q_bins + 1 do t = 1 , n_time do f = 1 , n_FDM if ( ( dRdw ( q , 1 , m , f , t ) > 0.0_dp ) . and . ( dRdw ( q , 2 , m , f , t ) > 0.0_dp ) ) then log_dRdw = log10 ( dRdw ( q , :, m , f , t )) fit_params = power_law_fit ( log_omega_bounds , log_dRdw ) omega_1 = 1 0.0_dp ** log_omega_bounds ( 1 ) omega_2 = 1 0.0_dp ** log_omega_bounds ( 2 ) do e = E_bin_threshold , n_E_bins + 1 E1 = ( e - 1 ) * E_bin_width E2 = e * E_bin_width if ( ( E2 > omega_1 ) & . and . ( E1 < omega_2 ) & . and . ( E1 > 0.0_dp ) ) then b_rate ( q , e , m , f , t ) = 1 0.0_dp ** log_dRdw ( 1 ) * & integrate_power_law ( fit_params , max ( E1 , omega_1 ), & min ( E2 , omega_2 ), omega_1 ) end if end do end if end do end do end do end if end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_dme_scatter_cf.f90.html"},{"title":"dme_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules dme_scatter_cf Source Code dme_scatter_cf.f90 Source Code module dme_scatter_cf !! Compute the scattering rate from core to free states use prec use math_mod use numerics_input use material_input use particle_physics_scatter use core_electrons use transition use Zeff_input use calc_dme_scatter_cf contains subroutine run_dme_scatter_cf ( binned_rate_t , n_tran_per_proc , & sto_wf_filename , core_elec_config_filename , nml_input_filename , & out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) integer :: n_tran_per_proc character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename character ( len =* ) :: nml_input_filename character ( len =* ) :: out_filename integer :: proc_id , root_process logical , optional :: verbose integer :: tran_id , init_id , fin_id integer :: t , i , f real ( dp ) :: log_omega_min , log_omega_max real ( dp ) :: log_omega real ( dp ) :: log_omegas ( 2 ) real ( dp ), allocatable :: log_omega_list (:) real ( dp ), allocatable :: log_omega_table (:, :) real ( dp ) :: ki_angular_mesh ( n_ki_theta * n_ki_phi , 2 ) real ( dp ) :: kf_angular_mesh ( n_kf_theta * n_kf_phi , 2 ) ! calculation setup call load_core_elec_config ( trim ( core_elec_config_filename ), verbose = verbose ) call load_core_sto_data ( trim ( sto_wf_filename ), verbose = verbose ) call load_Zeff_parameters ( trim ( nml_input_filename ), verbose = verbose ) ki_angular_mesh = generate_uniform_points_on_sphere ( n_ki_theta , n_ki_phi ) kf_angular_mesh = generate_uniform_points_on_sphere ( n_kf_theta , n_kf_phi ) ! do calculation ! create array of omega's that each processor will compute the transition rate ! for allocate ( log_omega_table ( n_fin , 2 )) allocate ( log_omega_list ( n_fin + 1 )) log_omega_min = log10 ( Ef_max ) log_omega_max = log10 ( 0.5_dp * v_max ** 2 * maxval ( mX )) if ( log_omega_max > log_omega_min ) then do f = 1 , n_fin + 1 log_omega = log_omega_min + ( log_omega_max - log_omega_min ) * & ( f - 1.0_dp ) / max ( n_fin + 1.0_dp - 1.0_dp , 1.0_dp ) log_omega_list ( f ) = log_omega end do do f = 1 , n_fin do i = 0 , 1 log_omega_table ( f , i + 1 ) = log_omega_list ( f + i ) end do end do if ( verbose ) then print * , 'Calculating rate...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then init_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) log_omegas = log_omega_table ( fin_id , :) call dme_scatter_cf_calc ( binned_rate_t (:, :, :, :, :, t ),& init_id , log_omegas , n_ki , ki_angular_mesh , kf_angular_mesh , verbose = verbose ) end if end do else if ( verbose ) then print * , '!!! WARNING !!!' print * print * , '   No mass in mX is large enough to warrant the c -> f calculation' print * , '   with the specified Ef_max. Skipping c -> f calculation.' print * print * , '!!!!!!!!!!!!!!!' print * end if end if if ( verbose ) then print * , '----------' print * end if if ( proc_id == root_process ) then call save_core_electrons ( out_filename , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/dme_scatter_cf.f90.html"},{"title":"calc_dme_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules calc_dme_scatter_vc Source Code calc_dme_scatter_vc.f90 Source Code module calc_dme_scatter_vc !! Holds the subroutine which calculates the binned rate for the vc calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use FFT_util use in_med_scr implicit none contains subroutine dme_scatter_vc_calc ( binned_rate_t ,& wfc_FT_i , wfc_FT_f ,& val_id , cond_id , & n_FFT_grid ,& k_cut , & wfc_FFT_plan , Tif_FFT_plan ,& verbose ) implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G ) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_i_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_f_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: T_if ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: f_G ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: k_cut integer :: val_id , cond_id integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose integer :: ki , kf integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max , q_max_FFT real ( dp ) :: omega , omega_max , Ei , Ef real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: scr integer :: q_bin_num , E_bin_num integer :: n_FFT real ( dp ) :: f_sq_val b_rate = 0.0_dp wfc_FT_i_exp = ( 0.0_dp , 0.0_dp ) wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_i = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) T_if = ( 0.0_dp , 0.0_dp ) f_G = ( 0.0_dp , 0.0_dp ) f_sq = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) q_max_FFT = n_FFT_grid ( 1 ) * q_s_FFT do ki = 1 , k_cut call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_i ( ki , :), wfc_FT_i_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_i_exp , wfc_i ) Ei = energy_bands ( ki , val_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) omega = Ef - Ei E_bin_num = Q_func ( omega , band_gap , E_bin_width , n_E_bins + 1 ) if ( ( E_bin_num >= E_bin_threshold ) . and . & ( Ef <= Ef_max ) ) then call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :), wfc_FT_f_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp , wfc_f ) T_if = conjg ( wfc_f ) * wfc_i f_G = ( 0.0_dp , 0.0_dp ) call dfftw_execute_dft ( Tif_fft_plan , T_if , f_G ) f_sq = abs ( f_G ) ** 2 ! particle physics do m = 1 , n_mX omega_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega < omega_max ) then q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& q_max_FFT , & mX ( m ) * v_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) - k_grid_xyz ( ki , :) + sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m < vEsc ) then g_func_val = g_func ( q_mag , v_m ) b_rate ( q_bin_num , E_bin_num , m , :, t ) = & b_rate ( q_bin_num , E_bin_num , m , :, t ) + & k_weight ( ki ) * k_weight ( kf ) * & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if end do end do ! add overall constants do m = 1 , n_mX b_rate (:, :, m , :, :) = ( 2 * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 2 ) * & red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * & ( 1.0_dp * n_FFT ) ** ( - 2 ) * b_rate (:, :, m , :, :) end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_dme_scatter_vc.f90.html"},{"title":"dme_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules dme_scatter_vc Source Code dme_scatter_vc.f90 Source Code module dme_scatter_vc !! Compute the scattering rate from valence to conduction states use prec use numerics_input use material_input use DFT_parameters use FFT_util use transition use calc_dme_scatter_vc implicit none contains subroutine run_dme_scatter_vc ( binned_rate_t , n_tran_per_proc , DFT_input_filename , & out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t integer :: tran_id integer :: val_id , cond_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename integer :: n_FFT_grid ( 3 ) integer :: n_FFT integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) complex ( dp ), allocatable :: wfc_FT_i (:, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) ! calculation setup call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) ! doubled to avoid wrapping problems n_FFT_grid ( 1 ) = 2 * ( maxval ( in_G_grid_red (:, 1 )) - minval ( in_G_grid_red (:, 1 ))) + 1 n_FFT_grid ( 2 ) = 2 * ( maxval ( in_G_grid_red (:, 2 )) - minval ( in_G_grid_red (:, 2 ))) + 1 n_FFT_grid ( 3 ) = 2 * ( maxval ( in_G_grid_red (:, 3 )) - minval ( in_G_grid_red (:, 3 ))) + 1 n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) if ( verbose ) then print * , 'Dimensions of FFT grid : ' print * , n_FFT_grid print * print * , 'Number of G points in FFT grid = ' , n_FFT print * print * , '----------' print * end if call set_fft_plan_backward_3d ( n_FFT_grid , wfc_fft_plan ) call set_fft_plan_backward_3d ( n_FFT_grid , Tif_fft_plan ) call set_sym_FFT_G_grid_xyz ( n_FFT_grid , k_red_to_xyz , verbose = verbose ) ! time calculation allocate ( wfc_FT_i ( n_k , n_in_G )) allocate ( wfc_FT_f ( n_k , n_in_G )) ! do calculation if ( verbose ) then print * , 'Calculating rate...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then val_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) call dme_scatter_vc_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_FT_i , wfc_FT_f , val_id , cond_id , n_FFT_grid , n_k , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) end if end do if ( verbose ) then print * , '----------' print * end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/dme_scatter_vc.f90.html"},{"title":"calc_dme_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules calc_dme_scatter_vf Source Code calc_dme_scatter_vf.f90 Source Code module calc_dme_scatter_vf use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use in_med_scr use Zeff_input implicit none contains subroutine dme_scatter_vf_calc ( binned_rate_t ,& wfc_FT_i , val_id , log_omegas , k_cut , angular_mesh , & verbose ) implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: dRdw ( n_q_bins + 1 , 2 , n_mX , n_FDM , n_time ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) integer :: val_id real ( dp ) :: log_omegas ( 2 ) real ( dp ) :: omega_kin_max real ( dp ) :: log_omega_bounds ( 2 ) real ( dp ) :: log_dRdw ( 2 ) integer :: k_cut real ( dp ) :: angular_mesh ( n_kf_theta * n_kf_phi , 2 ) logical , optional :: verbose integer :: i , t , m , f , q , e , g , k , a real ( dp ) :: Zeff real ( dp ) :: kf_theta , kf_phi , kf_mag real ( dp ) :: k_f ( 3 ), k_i ( 3 ) real ( dp ) :: q_min , q_max , q_mag real ( dp ) :: q_vec ( 3 ) integer :: q_bin_num real ( dp ) :: omega , Eik , Ef real ( dp ) :: E1 , E2 real ( dp ) :: omega_1 , omega_2 real ( dp ) :: fit_params real ( dp ) :: v_m , g_func_val real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: f_sq real ( dp ) :: scr real ( dp ) :: fermi_val , fermi_factor real ( dp ) :: log_b_rate b_rate = 0.0_dp dRdw = 0.0_dp do m = 1 , n_mX omega_kin_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega_kin_max > 1 0.0_dp ** log_omegas ( 1 ) ) then log_omega_bounds ( 1 ) = log_omegas ( 1 ) log_omega_bounds ( 2 ) = min ( log10 ( omega_kin_max ), log_omegas ( 2 )) ! compute dRdw at the endpoints, then interpolate and integrate between to get ! binned rate do i = 1 , 2 omega = 1 0.0_dp ** log_omega_bounds ( i ) q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = mX ( m ) * v_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) do k = 1 , k_cut Eik = energy_bands ( k , val_id ) - maxval ( energy_bands (:, : n_val )) Ef = omega + Eik if ( ( Ef . gt . 0.0_dp ) . and . ( Ef . gt . Ef_max ) ) then Zeff = get_val_Z_eff ( val_id , k ) kf_mag = sqrt ( 2 * m_elec * Ef ) fermi_val = 2.0_dp * pi * Zeff * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do a = 1 , n_kf_theta * n_kf_phi kf_theta = angular_mesh ( a , 1 ) kf_phi = angular_mesh ( a , 2 ) k_f ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) k_f ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) k_f ( 3 ) = kf_mag * cos ( kf_theta ) do g = 1 , n_in_G f_sq = wfc_FT_i ( k , g ) * conjg ( wfc_FT_i ( k , g )) k_i = k_grid_xyz ( k , :) + in_G_grid_xyz ( g , :) q_vec = k_f - k_i q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m . lt . vEsc ) then g_func_val = g_func ( q_mag , v_m ) dRdw ( q_bin_num , i , m , :, t ) = & dRdw ( q_bin_num , i , m , :, t ) + & k_weight ( k ) * & f_sq * & fermi_factor * & g_func_val * F_med_sq * & 2.0_dp * m_elec * kf_mag * & scr ** ( - 2 ) end if end do end if end do end do end if end do end do ! overall constants dRdw (:, :, m , :, :) = ( 2 * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 1 ) * (( 4 * pi ) / ( n_kf_theta * n_kf_phi * 1.0_dp )) * & red_mass ( m_elec , mX ( m )) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * ( 2 * pi ) ** ( - 3 ) * dRdw (:, :, m , :, :) ! now that dRdw has been computed at the end points we need to interpolate and integrate ! to get the binned rate ! our interpolating function is dRdw = dRdw(1)*(w/w_1)**b ! This procedure is equivalent to saving dRdw and interpolating later do q = 1 , n_q_bins + 1 do t = 1 , n_time do f = 1 , n_FDM if ( ( dRdw ( q , 1 , m , f , t ) > 0.0_dp ) . and . ( dRdw ( q , 2 , m , f , t ) > 0.0_dp ) ) then log_dRdw = log10 ( dRdw ( q , :, m , f , t )) fit_params = power_law_fit ( log_omega_bounds , log_dRdw ) omega_1 = 1 0.0_dp ** log_omega_bounds ( 1 ) omega_2 = 1 0.0_dp ** log_omega_bounds ( 2 ) do e = E_bin_threshold , n_E_bins + 1 E1 = ( e - 1 ) * E_bin_width E2 = e * E_bin_width if ( ( E2 > omega_1 ) & . and . ( E1 < omega_2 ) & . and . ( E1 > 0.0_dp ) ) then b_rate ( q , e , m , f , t ) = 1 0.0_dp ** log_dRdw ( 1 ) * & integrate_power_law ( fit_params , max ( E1 , omega_1 ), & min ( E2 , omega_2 ), omega_1 ) end if end do end if end do end do end do end if end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_dme_scatter_vf.f90.html"},{"title":"dme_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules dme_scatter_vf Source Code dme_scatter_vf.f90 Source Code module dme_scatter_vf !! Compute the scattering rate from valence to free states use prec use math_mod use numerics_input use material_input use DFT_parameters use particle_physics_scatter use transition use Zeff_input use calc_dme_scatter_vf implicit none contains subroutine run_dme_scatter_vf ( binned_rate_t , n_tran_per_proc , DFT_input_filename ,& nml_input_filename , out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t , f , i integer :: tran_id integer :: val_id , fin_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename character ( len =* ) :: nml_input_filename complex ( dp ), allocatable :: wfc_FT_i (:, :) real ( dp ) :: angular_mesh ( n_kf_theta * n_kf_phi , 2 ) real ( dp ), allocatable :: log_omega_table (:, :) real ( dp ), allocatable :: log_omega_list (:) real ( dp ) :: log_omega_min , log_omega_max real ( dp ) :: log_omega real ( dp ) :: log_omegas ( 2 ) ! calculation setup call load_DFT_parameters ( trim ( DFT_input_filename ), verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) call load_Zeff_parameters ( trim ( nml_input_filename ), verbose = verbose ) angular_mesh = generate_uniform_points_on_sphere ( n_kf_theta , n_kf_phi ) allocate ( wfc_FT_i ( n_k , n_in_G )) ! create array of omega's that each processor will compute the transition rate ! for allocate ( log_omega_table ( n_fin , 2 )) allocate ( log_omega_list ( n_fin + 1 )) log_omega_min = log10 ( Ef_max ) log_omega_max = log10 ( 0.5_dp * v_max ** 2 * maxval ( mX )) if ( log_omega_max > log_omega_min ) then do f = 1 , n_fin + 1 log_omega = log_omega_min + ( log_omega_max - log_omega_min ) * & ( f - 1.0_dp ) / max ( n_fin + 1.0_dp - 1.0_dp , 1.0_dp ) log_omega_list ( f ) = log_omega end do do f = 1 , n_fin do i = 0 , 1 log_omega_table ( f , i + 1 ) = log_omega_list ( f + i ) end do end do if ( verbose ) then print * , 'Calculating rate...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then val_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) log_omegas = log_omega_table ( fin_id , :) call dme_scatter_vf_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_FT_i , val_id , log_omegas , n_k , angular_mesh , verbose = verbose ) end if end do else if ( verbose ) then print * , '!!! WARNING !!!' print * print * , '   No mass in mX is large enough to warrant the v -> f calculation' print * , '   with the specified Ef_max. Skipping v -> f calculation.' print * print * , '!!!!!!!!!!!!!!!' print * end if end if if ( verbose ) then print * , '----------' print * end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/dme_scatter_vf.f90.html"},{"title":"load_control – EXCEED-DM","text":"public subroutine load_control(filename, verbose) Loads the control variables Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_control.html"},{"title":"core_sto_wf – EXCEED-DM","text":"public function core_sto_wf(core_state_idx, x_vec) result(val) Core wave function Units : eV&#94;(3/2)\n avoid |x| = 0 problems Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_vec (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf.html"},{"title":"core_sto_wf_FT – EXCEED-DM","text":"public function core_sto_wf_FT(core_state_idx, k_vec) result(val) Fourier transform of the core wave function Units : eV&#94;(-3/2)\n avoid |k| = 0 problems Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_vec (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_ft.html"},{"title":"core_sto_wf_radial – EXCEED-DM","text":"public function core_sto_wf_radial(core_state_idx, x_mag) result(val) Radial part of the total core wave function, summed over \n the individual sto_wf_radial Units : eV&#94;(3/2) Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_mag Return Value real(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_radial.html"},{"title":"core_sto_wf_FT_radial – EXCEED-DM","text":"public function core_sto_wf_FT_radial(core_state_idx, k_mag) result(chi) Radial part of the total Fourier transformed core wave function, summed over \n the individual sto_wf_FT_radial Units : eV&#94;(-3/2) Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_ft_radial.html"},{"title":"sto_wf_radial – EXCEED-DM","text":"public function sto_wf_radial(n, norm, Z, x_mag) result(val) Radial part of the Slater type orbital (STO) wave function Units : eV&#94;(3/2) Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: x_mag Return Value real(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_radial.html"},{"title":"sto_wf_FT_radial – EXCEED-DM","text":"public function sto_wf_FT_radial(n, l, norm, Z, k_mag) result(val) Radial part of the fourier transform of a Slater type orbital (STO) wave function sto_wf_FT = int d&#94;3x sto_wf e&#94;(-ikr)\n           = (sto_wf_FT_radial) * sph_harmonic(k hat) Reference : https://en.wikipedia.org/wiki/Slater-type_orbital Units : eV&#94;(-3/2) Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_ft_radial.html"},{"title":"get_sto_dataset_str – EXCEED-DM","text":"public function get_sto_dataset_str(Z, n, l) result(dset_name) Returns the name of the dataset for nth element in the\n core electron configuration Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Contents None","tags":"","loc":"proc/get_sto_dataset_str.html"},{"title":"save_core_electrons – EXCEED-DM","text":"public subroutine save_core_electrons(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_core_electrons.html"},{"title":"calc_core_sto_wf_grid – EXCEED-DM","text":"public subroutine calc_core_sto_wf_grid(core_wfc, core_state_idx, n_grid, red_to_xyz, shift, k_vec_in, s_cut_in, verbose) computes the core wave functions on a grid, summed over the closest unit cells if shift == T : x_shift = x_pos_red (equilibrium position)\n else: x_shift = 0\n core_sto_wf_grid(x) = sum_s core_sto_wf(x - x_shift + s) where x_i is the atomic equilibrium position Arguments Type Intent Optional Attributes Name complex(kind=dp) :: core_wfc (n_grid(1),n_grid(2),n_grid(3)) integer :: core_state_idx integer :: n_grid (3) Number of grid points in reduced x coordinates real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: s_cut_in logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_core_sto_wf_grid.html"},{"title":"load_core_elec_config – EXCEED-DM","text":"public subroutine load_core_elec_config(filename, verbose) Reads the core electron configuration file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_core_elec_config.html"},{"title":"print_core_elec_config – EXCEED-DM","text":"public subroutine print_core_elec_config(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/print_core_elec_config.html"},{"title":"load_core_sto_data – EXCEED-DM","text":"public subroutine load_core_sto_data(filename, verbose) Reads the sto wf file to get the relevant\n coefficients for the electron configuration\n specified in the core_elec_conf get the relevant data for each core state Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_core_sto_data.html"},{"title":"print_sto_data – EXCEED-DM","text":"public subroutine print_sto_data(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_sto_data.html"},{"title":"in_wfc_at_single_pt – EXCEED-DM","text":"public function in_wfc_at_single_pt(band_num, x0_red, in_wfc_FT) result(wfc) returns the wave function evaluated at a point in\n reduced coordinates at a single point av_wfc(x0)_k = sum_G e&#94;(i G.x0) wfc(G)_k Arguments Type Intent Optional Attributes Name integer :: band_num real(kind=dp) :: x0_red (3) complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Return Value complex(kind=dp)\n  (n_k) Contents None","tags":"","loc":"proc/in_wfc_at_single_pt.html"},{"title":"get_w_max – EXCEED-DM","text":"public function get_w_max(i) result(w_max) Returns the maximum energy transfer allowed from valence state i Arguments Type Intent Optional Attributes Name integer :: i Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_w_max.html"},{"title":"save_DFT_parameters – EXCEED-DM","text":"public subroutine save_DFT_parameters(filename, verbose) Saves some of the DFT input variables to filename Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_dft_parameters.html"},{"title":"load_DFT_parameters – EXCEED-DM","text":"public subroutine load_DFT_parameters(filename, verbose) Loads the DFT input file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_dft_parameters.html"},{"title":"check_DFT_parameters – EXCEED-DM","text":"public subroutine check_DFT_parameters(verbose) Check the values of of the input file to make sure they make sense Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/check_dft_parameters.html"},{"title":"print_DFT_parameters – EXCEED-DM","text":"public subroutine print_DFT_parameters(filename, verbose) Prints variables defined in this moudle Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/print_dft_parameters.html"},{"title":"get_in_wfc_FT – EXCEED-DM","text":"public subroutine get_in_wfc_FT(filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Bloch wave functions in reciprocal space Contents None","tags":"","loc":"proc/get_in_wfc_ft.html"},{"title":"expand_wfc_FT_for_FFT – EXCEED-DM","text":"public subroutine expand_wfc_FT_for_FFT(n_grid, wfc_FT, wfc_FT_exp, verbose) Uses FFT_util The Fourier components will generally not be defined on a\n uniform grid needed for an FFT. This subroutine puts the \n values of the Bloch coefficients in the correct place Arguments Type Intent Optional Attributes Name integer :: n_grid (3) complex(kind=dp) :: wfc_FT (n_in_G) complex(kind=dp) :: wfc_FT_exp (n_grid(1),n_grid(2),n_grid(3)) logical, optional :: verbose Contents None","tags":"","loc":"proc/expand_wfc_ft_for_fft.html"},{"title":"get_PW_cutoffs – EXCEED-DM","text":"public subroutine get_PW_cutoffs(verbose) Calculate the plane wave expansion parameters Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/get_pw_cutoffs.html"},{"title":"do_scissor_correction – EXCEED-DM","text":"public subroutine do_scissor_correction(band_gap, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: band_gap logical, optional :: verbose Contents None","tags":"","loc":"proc/do_scissor_correction.html"},{"title":"set_sym_FFT_G_grid_xyz – EXCEED-DM","text":"public subroutine set_sym_FFT_G_grid_xyz(n_grid, k_red_to_xyz, verbose) Symmetric FFT grid. Standard convention for FFTs is to compute for frequencies 0 -> N-1. \n This subroutine creates a map which takes the larger half of the positive\n frequencies and maps then back to negative values, for a symmetric G grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Contents None","tags":"","loc":"proc/set_sym_fft_g_grid_xyz.html"},{"title":"set_fft_plan_forward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_forward_3d(n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_forward_3d.html"},{"title":"set_fft_plan_backward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_backward_3d(n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_backward_3d.html"},{"title":"G_red_to_FFT_G_grid_index – EXCEED-DM","text":"public subroutine G_red_to_FFT_G_grid_index(n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \n grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3) Contents None","tags":"","loc":"proc/g_red_to_fft_g_grid_index.html"},{"title":"load_io – EXCEED-DM","text":"public subroutine load_io(filename, verbose) Loads the io namelist Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_io.html"},{"title":"create_output_file – EXCEED-DM","text":"public recursive subroutine create_output_file(filename, overwrite_output, verbose) Uses hdf5 h5lt prec Creates the output file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical :: overwrite_output logical, optional :: verbose Contents None","tags":"","loc":"proc/create_output_file.html"},{"title":"load_material – EXCEED-DM","text":"public subroutine load_material(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_material.html"},{"title":"save_material – EXCEED-DM","text":"public subroutine save_material(filename, verbose) Saves the material properties Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_material.html"},{"title":"set_job_table – EXCEED-DM","text":"public subroutine set_job_table(n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose Contents None","tags":"","loc":"proc/set_job_table.html"},{"title":"integrate_power_law – EXCEED-DM","text":"public function integrate_power_law(b, x1, x2, x_s) result(integral) = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy\n = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) The reason this function is non-trivial is because evaluating x**(b + 1)\n when b is large can be problematic. Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) Contents None","tags":"","loc":"proc/integrate_power_law.html"},{"title":"power_law_fit – EXCEED-DM","text":"public function power_law_fit(log_x_pts, log_y_pts) result(fit_params) Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x fit_params = [a, b] Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/power_law_fit.html"},{"title":"generate_uniform_points_on_sphere – EXCEED-DM","text":"public function generate_uniform_points_on_sphere(n_theta, n_phi) result(angular_mesh) Generates an (n_thata*n_phi, 2) list of points which are uniformly \n distributed on the sphere Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) Contents None","tags":"","loc":"proc/generate_uniform_points_on_sphere.html"},{"title":"Q_func – EXCEED-DM","text":"public function Q_func(x, a, b, Q_max) result(Q) Places x in an appropriate bin Q = min(Q_max, 1 + floor((x - a)/b)) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer Contents None","tags":"","loc":"proc/q_func.html"},{"title":"factorial – EXCEED-DM","text":"public function factorial(n) result(fact) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer Contents None","tags":"","loc":"proc/factorial.html"},{"title":"sph_harmonic – EXCEED-DM","text":"public recursive function sph_harmonic(l, m, theta, phi) result(y_lm) Spherical harmonic function with phase convention identical\n to Mathematica Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sph_harmonic.html"},{"title":"get_phi – EXCEED-DM","text":"public function get_phi(n_hat) result(phi) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_phi.html"},{"title":"get_theta – EXCEED-DM","text":"public function get_theta(n_hat) result(theta) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_theta.html"},{"title":"pretty_time_format – EXCEED-DM","text":"public function pretty_time_format(t) result(time_str) Fills time_str with a nicely formatted version of time Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512) Contents None","tags":"","loc":"proc/pretty_time_format.html"},{"title":"run_dme_scatter – EXCEED-DM","text":"public subroutine run_dme_scatter(proc_id, root_process, out_filename, nml_filename, DFT_input_filename, sto_wf_filename, core_elec_config_filename, n_proc, save_binned_rate_if, verbose) Scattering rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename integer :: n_proc logical :: save_binned_rate_if logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter.html"},{"title":"update_rates – EXCEED-DM","text":"public subroutine update_rates(binned_rate_t, proc_id) updates all the rate arrays with the output \n of a single processors results Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time,n_tran_per_proc) integer :: proc_id Contents None","tags":"","loc":"proc/update_rates.html"},{"title":"save_rates – EXCEED-DM","text":"public subroutine save_rates(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_rates.html"},{"title":"screening – EXCEED-DM","text":"public function screening(q_vec, omega) result(scr) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/screening.html"},{"title":"model_dielectric – EXCEED-DM","text":"public function model_dielectric(q_vec, omega, e0, q_tf, alpha, omega_p) result(di) Analytic form of the dielectric function\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega real(kind=dp) :: e0 real(kind=dp) :: q_tf real(kind=dp) :: alpha real(kind=dp) :: omega_p Return Value real(kind=dp) Contents None","tags":"","loc":"proc/model_dielectric.html"},{"title":"load_in_med_scr – EXCEED-DM","text":"public subroutine load_in_med_scr(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_in_med_scr.html"},{"title":"save_in_med_scr – EXCEED-DM","text":"public subroutine save_in_med_scr(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_in_med_scr.html"},{"title":"load_numerics – EXCEED-DM","text":"public subroutine load_numerics(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_numerics.html"},{"title":"print_numerics – EXCEED-DM","text":"public subroutine print_numerics(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_numerics.html"},{"title":"save_numerics – EXCEED-DM","text":"public subroutine save_numerics(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_numerics.html"},{"title":"v_minus – EXCEED-DM","text":"public function v_minus(q_vec, mX, vE_vec, omega) result(v_m) v_- function v_- = (1/q)| q_vec . vE + q&#94;2/mX + w | Note that we will explicitly check that this value is < v_Esc so that \n the g function is always > 0 Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/v_minus.html"},{"title":"g_func – EXCEED-DM","text":"public function g_func(q, v_m) result(g_fun) Kinematic function : g_func = 2 pi int d&#94;3v f_chi(v) delta(w - w_q) Units : eV&#94;(-1) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m Return Value real(kind=dp) Contents None","tags":"","loc":"proc/g_func.html"},{"title":"red_mass – EXCEED-DM","text":"public function red_mass(m1, m2) result(mu) Reduced mass Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) Contents None","tags":"","loc":"proc/red_mass.html"},{"title":"F_med_sq_func – EXCEED-DM","text":"public function F_med_sq_func(q_mag, power) result(F_med_sq_val) Mediator for factor squared Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp) Contents None","tags":"","loc":"proc/f_med_sq_func.html"},{"title":"print_particle_physics_scatter – EXCEED-DM","text":"public subroutine print_particle_physics_scatter(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_particle_physics_scatter.html"},{"title":"load_particle_physics_scatter – EXCEED-DM","text":"public subroutine load_particle_physics_scatter(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_particle_physics_scatter.html"},{"title":"save_particle_physics_scatter – EXCEED-DM","text":"public subroutine save_particle_physics_scatter(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_particle_physics_scatter.html"},{"title":"set_mX – EXCEED-DM","text":"public subroutine set_mX(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_mx.html"},{"title":"set_g_func_parameters – EXCEED-DM","text":"public subroutine set_g_func_parameters() Arguments None Contents None","tags":"","loc":"proc/set_g_func_parameters.html"},{"title":"set_FDM_powers – EXCEED-DM","text":"public subroutine set_FDM_powers(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_fdm_powers.html"},{"title":"set_time_vE_vec – EXCEED-DM","text":"public subroutine set_time_vE_vec(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_time_ve_vec.html"},{"title":"get_val_Z_eff – EXCEED-DM","text":"public function get_val_Z_eff(i, k) result(Zeff) returns the Z_eff value of the valence state Arguments Type Intent Optional Attributes Name integer :: i integer :: k Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_val_z_eff.html"},{"title":"load_Zeff_parameters – EXCEED-DM","text":"public subroutine load_Zeff_parameters(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_zeff_parameters.html"},{"title":"dme_scatter_cc_calc – EXCEED-DM","text":"public subroutine dme_scatter_cc_calc(binned_rate_t, wfc_i, wfc_FT_f, init_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: init_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_cc_calc.html"},{"title":"run_dme_scatter_cc – EXCEED-DM","text":"public subroutine run_dme_scatter_cc(binned_rate_t, n_tran_per_proc, DFT_input_filename, sto_wf_filename, core_elec_config_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_cc.html"},{"title":"dme_scatter_cf_calc – EXCEED-DM","text":"public subroutine dme_scatter_cf_calc(binned_rate_t, init_id, log_omegas, ki_cut, ki_angular_mesh, kf_angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) integer :: init_id real(kind=dp) :: log_omegas (2) integer :: ki_cut real(kind=dp) :: ki_angular_mesh (n_ki_theta*n_ki_phi,2) real(kind=dp) :: kf_angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_cf_calc.html"},{"title":"run_dme_scatter_cf – EXCEED-DM","text":"public subroutine run_dme_scatter_cf(binned_rate_t, n_tran_per_proc, sto_wf_filename, core_elec_config_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_cf.html"},{"title":"dme_scatter_vc_calc – EXCEED-DM","text":"public subroutine dme_scatter_vc_calc(binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_vc_calc.html"},{"title":"run_dme_scatter_vc – EXCEED-DM","text":"public subroutine run_dme_scatter_vc(binned_rate_t, n_tran_per_proc, DFT_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_vc.html"},{"title":"dme_scatter_vf_calc – EXCEED-DM","text":"public subroutine dme_scatter_vf_calc(binned_rate_t, wfc_FT_i, val_id, log_omegas, k_cut, angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) integer :: val_id real(kind=dp) :: log_omegas (2) integer :: k_cut real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_vf_calc.html"},{"title":"run_dme_scatter_vf – EXCEED-DM","text":"public subroutine run_dme_scatter_vf(binned_rate_t, n_tran_per_proc, DFT_input_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_vf.html"},{"title":"control_input – EXCEED-DM","text":"Collection of variables which specify how the program should run Contents Variables process calc_mode timer quiet save_binned_rate_if overwrite_output Subroutines load_control Variables Type Visibility Attributes Name Initial character(len=64), public :: process = '' character(len=64), public :: calc_mode = '' logical, public :: timer = .TRUE. Optional If .TRUE. the program will output timing information logical, public :: quiet = .FALSE. Don't print any output logical, public :: save_binned_rate_if = .FALSE. save the 2d differential rate data for \n every i -> f transition memory intensive logical, public :: overwrite_output = .FALSE. if True the output file will be overwritten Subroutines public subroutine load_control (filename, verbose) Loads the control variables Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/control_input.html"},{"title":"core_electrons – EXCEED-DM","text":"Handles the wave functions and energy levels for core electrons Uses hdf5 h5lt prec constants math_mod Contents Variables n_atoms n_core_states Z_list eq_pos_red core_energy core_elec_conf core_sto_nj_list core_sto_max_nj core_sto_data Functions core_sto_wf core_sto_wf_FT core_sto_wf_radial core_sto_wf_FT_radial sto_wf_radial sto_wf_FT_radial get_sto_dataset_str Subroutines save_core_electrons calc_core_sto_wf_grid load_core_elec_config print_core_elec_config load_core_sto_data print_sto_data Variables Type Visibility Attributes Name Initial integer, public :: n_atoms Number of atoms in the primitive cell integer, public :: n_core_states Total number of core states integer, public, allocatable :: Z_list (:) Dim : [n_atoms] Proton number / number of electrons real(kind=dp), public, allocatable :: eq_pos_red (:,:) Dim : [n_atoms, 3] Equilibrium position of the atoms in the primitive cell\n in reduced coordinates Units : None real(kind=dp), public, allocatable :: core_energy (:) Dim : [n_core_states] Energy of the core states Units : eV integer, public, allocatable :: core_elec_conf (:,:) Dim : [n_core_states, 5] Electron configuration, each element is\n  core_elec_conf(i, 1) - atom id\n  core_elec_conf(i, 2) - n\n  core_elec_conf(i, 3) - l\n  core_elec_conf(i, 4) - m\n  core_elec_conf(i, 5) - n_s (number of spin states) Generated STO parameters integer, public, allocatable :: core_sto_nj_list (:) Dim : [n_core_states] Number of terms in the analytic STO expansion integer, public :: core_sto_max_nj Maximum value of core_sto_nj_list real(kind=dp), public, allocatable :: core_sto_data (:,:,:) Dim : [n_core_states, 4, max(core_sto_nj_list)] All of the parameters of the STO expansion\n  core_sto_data(i, 1, :) - n_l[j]\n  core_sto_data(i, 2, :) - Z_l[j]\n  core_sto_data(i, 3, :) - N_l[j]\n  core_sto_data(i, 4, :) - C_nl[j] Functions public function core_sto_wf (core_state_idx, x_vec) result(val) Core wave function Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_vec (3) Return Value complex(kind=dp) public function core_sto_wf_FT (core_state_idx, k_vec) result(val) Fourier transform of the core wave function Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_vec (3) Return Value complex(kind=dp) public function core_sto_wf_radial (core_state_idx, x_mag) result(val) Radial part of the total core wave function, summed over \n the individual sto_wf_radial Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_mag Return Value real(kind=dp) public function core_sto_wf_FT_radial (core_state_idx, k_mag) result(chi) Radial part of the total Fourier transformed core wave function, summed over \n the individual sto_wf_FT_radial Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_mag Return Value complex(kind=dp) public function sto_wf_radial (n, norm, Z, x_mag) result(val) Radial part of the Slater type orbital (STO) wave function Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: x_mag Return Value real(kind=dp) public function sto_wf_FT_radial (n, l, norm, Z, k_mag) result(val) Radial part of the fourier transform of a Slater type orbital (STO) wave function Read more… Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) public function get_sto_dataset_str (Z, n, l) result(dset_name) Returns the name of the dataset for nth element in the\n core electron configuration Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Subroutines public subroutine save_core_electrons (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine calc_core_sto_wf_grid (core_wfc, core_state_idx, n_grid, red_to_xyz, shift, k_vec_in, s_cut_in, verbose) computes the core wave functions on a grid, summed over the closest unit cells Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: core_wfc (n_grid(1),n_grid(2),n_grid(3)) integer :: core_state_idx integer :: n_grid (3) Number of grid points in reduced x coordinates real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: s_cut_in logical, optional :: verbose public subroutine load_core_elec_config (filename, verbose) Reads the core electron configuration file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_core_elec_config (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine load_core_sto_data (filename, verbose) Reads the sto wf file to get the relevant\n coefficients for the electron configuration\n specified in the core_elec_conf Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_sto_data (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose","tags":"","loc":"module/core_electrons.html"},{"title":"DFT_parameters – EXCEED-DM","text":"Handles the results from DFT calculations that compute the Bloch wave \n function coefficients. Variables with '_A' are with units of Angstroms Uses h5lt hdf5 prec constants units Contents Variables n_k n_val n_cond n_in_G in_G_grid_red a_vecs_A b_vecs_A k_weight k_grid_red energy_bands_raw n_bands q_PW_cut E_PW_cut a_vecs red_to_xyz b_vecs k_red_to_xyz energy_bands in_G_grid_xyz k_grid_xyz Functions in_wfc_at_single_pt get_w_max Subroutines save_DFT_parameters load_DFT_parameters check_DFT_parameters print_DFT_parameters get_in_wfc_FT expand_wfc_FT_for_FFT get_PW_cutoffs do_scissor_correction Variables Type Visibility Attributes Name Initial integer, public :: n_k Number of k points integer, public :: n_val Number of valence bands integer, public :: n_cond Number of conduction bands integer, public :: n_in_G Number of G points in in_G_grid integer, public, allocatable :: in_G_grid_red (:,:) Dim : [n_in_G, 3] Input grid of G vectors in reduced coordinates real(kind=dp), public :: a_vecs_A (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : Ang real(kind=dp), public :: b_vecs_A (3,3) Reciprocal lattice vector (i, :) is the ith reciprocal lattice vector Units : Ang&#94;(-1) real(kind=dp), public, allocatable :: k_weight (:) Dim : [n_k] Weights of each k point in the k_red grid, must sum to 2 Units : None real(kind=dp), public, allocatable :: k_grid_red (:,:) Dim : [n_k, 3] List of k vectors in reduced coordinates Units : None real(kind=dp), public, allocatable :: energy_bands_raw (:,:) Dim : [n_k, n_bands] Raw electron energy eigenvalues Units : eV Generated from input integer, public :: n_bands Number of bands n_bands = n_cond + n_val real(kind=dp), public :: q_PW_cut plane wave cutoff in expansion Units : eV real(kind=dp), public :: E_PW_cut energy cooresponding to q_PW_cut E_PW_cut = q_PW_cut* 2/(2 m_elec) Units : eV real(kind=dp), public :: a_vecs (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : eV real(kind=dp), public :: red_to_xyz (3,3) Matrix converting reduced cooredinate positions to physical xyz cooredinates\n in eV&#94;(-1) via x_xyz = matmul(red_to_xyz, x_red) red_to_xyz = transpose(a_vecs) Units : eV&#94;(-1) real(kind=dp), public :: b_vecs (3,3) Reciprocal lattice vector (i, :) is the ith reciprocal lattice vector Units : eV real(kind=dp), public :: k_red_to_xyz (3,3) Matrix converting reduced cooredinate momentum to physical xyz cooredinates\n in eV via k_xyz = matmul(k_red_to_xyz, k_red) k_red_to_xyz = transpose(b_vecs) Units : eV real(kind=dp), public, allocatable :: energy_bands (:,:) Dim : [n_k, n_bands] Scissor corrected electron energy eigenvalues Units : eV real(kind=dp), public, allocatable :: in_G_grid_xyz (:,:) Dim : [n_in_G, 3] Input grid of G vectors in physical xyz coordinates Units : eV real(kind=dp), public, allocatable :: k_grid_xyz (:,:) Dim : [n_k, 3] List of k vectors in xyz coordinates Units : eV Functions public function in_wfc_at_single_pt (band_num, x0_red, in_wfc_FT) result(wfc) returns the wave function evaluated at a point in\n reduced coordinates at a single point Read more… Arguments Type Intent Optional Attributes Name integer :: band_num real(kind=dp) :: x0_red (3) complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Return Value complex(kind=dp)\n  (n_k) public function get_w_max (i) result(w_max) Returns the maximum energy transfer allowed from valence state i Arguments Type Intent Optional Attributes Name integer :: i Return Value real(kind=dp) Subroutines public subroutine save_DFT_parameters (filename, verbose) Saves some of the DFT input variables to filename Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine load_DFT_parameters (filename, verbose) Loads the DFT input file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine check_DFT_parameters (verbose) Check the values of of the input file to make sure they make sense Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine print_DFT_parameters (filename, verbose) Prints variables defined in this moudle Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine get_in_wfc_FT (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Bloch wave functions in reciprocal space public subroutine expand_wfc_FT_for_FFT (n_grid, wfc_FT, wfc_FT_exp, verbose) The Fourier components will generally not be defined on a\n uniform grid needed for an FFT. This subroutine puts the \n values of the Bloch coefficients in the correct place Arguments Type Intent Optional Attributes Name integer :: n_grid (3) complex(kind=dp) :: wfc_FT (n_in_G) complex(kind=dp) :: wfc_FT_exp (n_grid(1),n_grid(2),n_grid(3)) logical, optional :: verbose public subroutine get_PW_cutoffs (verbose) Calculate the plane wave expansion parameters Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine do_scissor_correction (band_gap, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: band_gap logical, optional :: verbose","tags":"","loc":"module/dft_parameters.html"},{"title":"FFT_util – EXCEED-DM","text":"Utilities for computing FFT's Uses prec fftw3 Contents Variables sym_FFT_G_grid_xyz Subroutines set_sym_FFT_G_grid_xyz set_fft_plan_forward_3d set_fft_plan_backward_3d G_red_to_FFT_G_grid_index Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: sym_FFT_G_grid_xyz (:,:,:,:) FFT G grid shifted so that both + and - G's are represented Subroutines public subroutine set_sym_FFT_G_grid_xyz (n_grid, k_red_to_xyz, verbose) Symmetric FFT grid. Read more… Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose public subroutine set_fft_plan_forward_3d (n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine set_fft_plan_backward_3d (n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine G_red_to_FFT_G_grid_index (n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \n grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3)","tags":"","loc":"module/fft_util.html"},{"title":"io_input – EXCEED-DM","text":"Input and output file names Contents Variables nml_input_filename DFT_input_filename run_description out_folder out_filename sto_wf_filename core_elec_config_filename Subroutines load_io create_output_file Variables Type Visibility Attributes Name Initial character(len=512), public :: nml_input_filename = '' Namelist input filename, character(len=512), public :: DFT_input_filename = '' DFT calculations input file character(len=64), public :: run_description = '' description of the calculation character(len=512), public :: out_folder = '.' Ouput folder character(len=512), public :: out_filename = '' Output filename Setting this variable overrides the settings of out_folder\n and run_description character(len=512), public :: sto_wf_filename = '' Input file specifying the Slater type orbital (sto)\n wave function coefficients for the core electron\n states character(len=512), public :: core_elec_config_filename = '' File specifying the core electron configuration Subroutines public subroutine load_io (filename, verbose) Loads the io namelist Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public recursive subroutine create_output_file (filename, overwrite_output, verbose) Creates the output file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical :: overwrite_output logical, optional :: verbose","tags":"","loc":"module/io_input.html"},{"title":"material_input – EXCEED-DM","text":"Information about the target material. Uses hdf5 h5lt prec units Contents Variables mat_name pc_vol_A rho_T_g_per_cm3 m_T_kg band_gap pc_vol rho_T m_T Subroutines load_material save_material Variables Type Visibility Attributes Name Initial character(len=64), public :: mat_name = '' real(kind=dp), public :: pc_vol_A Volume of the unit cell pc_vol_A = det(a_vecs) Units : Ang&#94;3 real(kind=dp), public :: rho_T_g_per_cm3 Target density Units : g/cm&#94;3 real(kind=dp), public :: m_T_kg = 1.0_dp Target mass Units : kg real(kind=dp), public :: band_gap = 0.0_dp Band gap of the target Units : eV Generated from input real(kind=dp), public :: pc_vol Volume of the primitive cell Units : eV&#94;(-3) real(kind=dp), public :: rho_T Target density Units : eV&#94;4 real(kind=dp), public :: m_T Target mass Units : eV Subroutines public subroutine load_material (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_material (filename, verbose) Saves the material properties Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/material_input.html"},{"title":"transition – EXCEED-DM","text":"Hnadles labelling of the transitions that each processor should compute \n for Contents Variables n_tran n_tran_per_proc tran_to_init_fin_id job_table Subroutines set_job_table Variables Type Visibility Attributes Name Initial integer, public :: n_tran Total number of transitions = n_init*n_fin integer, public :: n_tran_per_proc Number of transitiosn each processor has to calculate integer, public, allocatable :: tran_to_init_fin_id (:,:) Dim : [n_tran, 2] Each transition (i, f) is given a unique index, and this \n is the map back. For each transition id return the initial \n or final state index integer, public, allocatable :: job_table (:,:) Dim : [n_proc, n_tran_per_proc]\n give each processor a list of transitions to compute for Subroutines public subroutine set_job_table (n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose","tags":"","loc":"module/transition.html"},{"title":"constants – EXCEED-DM","text":"Collection of useful constants Uses prec Contents Variables m_elec alpha_EM a0 pi ii e_EM Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: m_elec = 511.0e3_dp Electron mass Units : eV real(kind=dp), public, parameter :: alpha_EM = 1.0_dp/137.0_dp Fine structure constant real(kind=dp), public, parameter :: a0 = 2.681336e-4_dp Bohr radius Units : eV&#94;(-1) real(kind=dp), public, parameter :: pi = 4.0_dp*atan(1.0_dp) complex(kind=dp), public, parameter :: ii = (0.0_dp, 1.0_dp) Imaginary unit real(kind=dp), public, parameter :: e_EM = sqrt(4*pi*alpha_EM) Unit of electric charge","tags":"","loc":"module/constants.html"},{"title":"math_mod – EXCEED-DM","text":"A collection of useful math functions Uses prec special_functions constants Contents Functions integrate_power_law power_law_fit generate_uniform_points_on_sphere Q_func factorial sph_harmonic get_phi get_theta Functions public function integrate_power_law (b, x1, x2, x_s) result(integral) = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy\n = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) public function power_law_fit (log_x_pts, log_y_pts) result(fit_params) Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) public function generate_uniform_points_on_sphere (n_theta, n_phi) result(angular_mesh) Generates an (n_thata*n_phi, 2) list of points which are uniformly \n distributed on the sphere Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) public function Q_func (x, a, b, Q_max) result(Q) Places x in an appropriate bin Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer public function factorial (n) result(fact) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer public recursive function sph_harmonic (l, m, theta, phi) result(y_lm) Spherical harmonic function with phase convention identical\n to Mathematica Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) public function get_phi (n_hat) result(phi) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) public function get_theta (n_hat) result(theta) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp)","tags":"","loc":"module/math_mod.html"},{"title":"prec – EXCEED-DM","text":"Precision definitions\n double precision (dp) definition Uses iso_fortran_env Contents None","tags":"","loc":"module/prec.html"},{"title":"timing – EXCEED-DM","text":"Useful functions for timing a program Uses prec Contents Variables time delta_t Functions pretty_time_format Variables Type Visibility Attributes Name Initial real(kind=dp), public :: time (100) holds raw timing variables real(kind=dp), public :: delta_t (100) holds difference in timing variables Functions public function pretty_time_format (t) result(time_str) Fills time_str with a nicely formatted version of time Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512)","tags":"","loc":"module/timing.html"},{"title":"units – EXCEED-DM","text":"Unit conversion factors If a variable has units of x to convert to units y: var_y = x_to_y * var_x Uses prec Contents Variables inv_Ang_to_eV inv_eV_to_cm Ang_to_inv_eV g_to_eV kg_to_eV inv_cm_to_eV km_per_sec_to_none Variables Type Visibility Attributes Name Initial real(kind=dp), public :: inv_Ang_to_eV = 1973.37_dp real(kind=dp), public :: inv_eV_to_cm = 1.97327e-5_dp real(kind=dp), public :: Ang_to_inv_eV = 5.068e-4_dp real(kind=dp), public :: g_to_eV = 5.61e32_dp real(kind=dp), public :: kg_to_eV = 5.61e35_dp real(kind=dp), public :: inv_cm_to_eV = 1.97327e-5_dp real(kind=dp), public :: km_per_sec_to_none = 3.33563e-6_dp","tags":"","loc":"module/units.html"},{"title":"version_control – EXCEED-DM","text":"Keeps track of the current version of the program Contents Variables version Variables Type Visibility Attributes Name Initial character(len=64), public :: version = \"0.1.0\"","tags":"","loc":"module/version_control.html"},{"title":"dme_scatter – EXCEED-DM","text":"Perform DM-electron scattering rate calculations Uses mpi hdf5 h5lt prec control_input particle_physics_scatter numerics_input in_med_scr transition dme_scatter_vc dme_scatter_cc dme_scatter_vf dme_scatter_cf Contents Variables binned_rate_t_scatter binned_rate_if_scatter binned_rate_i_scatter binned_rate_scatter rate_scatter calc_modes_list Subroutines run_dme_scatter update_rates save_rates Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: binned_rate_t_scatter (:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_tran_per_proc] Binned rate allocated on each processor, for each job to compute for Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_if_scatter (:,:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init, n_fin] Binned rate between all transitions Warning : memory intensive Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_i_scatter (:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init] Binned rate, summed over final states Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_scatter (:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time] Binned rate summed over all transitions Units : eV&#94;2 real(kind=dp), public, allocatable :: rate_scatter (:,:,:) Dim : [n_mX, n_FDM, n_time] Total rate summed over all transitions Units : eV&#94;2 character(len=64), public :: calc_modes_list (4) = ['vc', 'vf', 'cc', 'cf'] Subroutines public subroutine run_dme_scatter (proc_id, root_process, out_filename, nml_filename, DFT_input_filename, sto_wf_filename, core_elec_config_filename, n_proc, save_binned_rate_if, verbose) Scattering rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename integer :: n_proc logical :: save_binned_rate_if logical, optional :: verbose public subroutine update_rates (binned_rate_t, proc_id) updates all the rate arrays with the output \n of a single processors results Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time,n_tran_per_proc) integer :: proc_id public subroutine save_rates (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/dme_scatter.html"},{"title":"in_med_scr – EXCEED-DM","text":"Handle analytic/numeric dielectric or other in medium effects which screen the interaction rate ~ 1/screen&#94;2 Uses hdf5 h5lt prec constants Contents Variables screen_type di_e0 di_q_tf di_omega_p di_alpha include_screen Functions screening model_dielectric Subroutines load_in_med_scr save_in_med_scr Variables Type Visibility Attributes Name Initial character(len=64), public :: screen_type = '' !\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 real(kind=dp), public :: di_e0 real(kind=dp), public :: di_q_tf real(kind=dp), public :: di_omega_p real(kind=dp), public :: di_alpha ! logical, public :: include_screen = .TRUE. toggle whether screening effects are included or not Functions public function screening (q_vec, omega) result(scr) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function model_dielectric (q_vec, omega, e0, q_tf, alpha, omega_p) result(di) Analytic form of the dielectric function\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega real(kind=dp) :: e0 real(kind=dp) :: q_tf real(kind=dp) :: alpha real(kind=dp) :: omega_p Return Value real(kind=dp) Subroutines public subroutine load_in_med_scr (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_in_med_scr (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/in_med_scr.html"},{"title":"numerics_input – EXCEED-DM","text":"Variables relating to binning and other numerics Uses hdf5 h5lt prec Contents Variables q_bin_width n_q_bins E_bin_width n_E_bins E_bin_threshold Ef_max n_init n_fin n_FFT_grid_input q_s_FFT n_kf_theta n_kf_phi n_ki_theta n_ki_phi ki_s n_ki ki_min Subroutines load_numerics print_numerics save_numerics Variables Type Visibility Attributes Name Initial real(kind=dp), public :: q_bin_width = 1.0e3_dp width of momuntum bins Units : eV integer, public :: n_q_bins = 0 Number of q bins, with bin width q_bin_width, to save Note: momentum transfers greater than n_q_bins*q_bin_width\n will be stored in the last, extra bin real(kind=dp), public :: E_bin_width = 1.0_dp Width of the energy bins Units : eV integer, public :: n_E_bins = 0 Number of E bins, with bin width E_bin_width, to save Note: energy transfers greater than n_E_bins*E_bin_width\n will be stored in the last, extra bin integer, public :: E_bin_threshold = 1 smallest E bin added to total rate calculation\n default : 1 - include all bins real(kind=dp), public :: Ef_max = 60.0_dp maximum final state energy to include in calculations Units : eV TODO : E_cut is a more appropriate name integer, public :: n_init number of initial states integer, public :: n_fin number of final states integer, public :: n_FFT_grid_input (3) = [0, 0, 0] Default size of the FFT, used to extend core\n calculation by making the size of the FFT larger Note : only used in calculations which use the FFT real(kind=dp), public :: q_s_FFT = 2151.0_dp/2.0_dp Units : eV q_max_FFT = q_s_FFT*N_FFT Minimum eigenvalue of k_red_to_xyz matrix Note : only used in calculations which use the FFT TODO : do not hard code this in integer, public :: n_kf_theta = 1 Number of theta points in integration of kf Note : only used in free calculatinos integer, public :: n_kf_phi = 1 Number of phi points in integration of kf Note : only used in free calculatinos integer, public :: n_ki_theta = 1 Number of theta points in integration of ki Note : only used in core -> free calculatinos integer, public :: n_ki_phi = 1 Number of phi points in integration of ki Note : only used in core -> free calculatinos real(kind=dp), public :: ki_s = 100.0_dp Scale parameter for k_i momentum to integrate over in core -> free calculation maximum initial electron momentum  = ki_s * Z * alpha * m_e Generally want this to be >> Z alpha m_e, the scale factor of the electron wave functions integer, public :: n_ki = 2 Number of radial points in integration of ki real(kind=dp), public :: ki_min = 1.0e3_dp Minimum electron momentum Units : eV Subroutines public subroutine load_numerics (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_numerics (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine save_numerics (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/numerics_input.html"},{"title":"particle_physics_scatter – EXCEED-DM","text":"Particle physics parameters needed for a DM-electron\n scattering rate calculation Uses hdf5 h5lt prec constants units Contents Variables n_mX log_mmin log_mmax n_extra_mX n_FDM FDMPower_min FDMPower_max n_time time_day_min time_day_max percentile_cut rhoX_GeV_per_cm3 v0_km_per_sec vE_km_per_sec vEsc_km_per_sec thetaE rhoX v0 vE vEsc mX mX_2 FDMPowerList timeOfDayList vEVecList g_func_N0 g_func_c1 g_func_c2 v_max Functions v_minus g_func red_mass F_med_sq_func Subroutines print_particle_physics_scatter load_particle_physics_scatter save_particle_physics_scatter set_mX set_g_func_parameters set_FDM_powers set_time_vE_vec Variables Type Visibility Attributes Name Initial integer, public :: n_mX = 1 Number of masses to compute for real(kind=dp), public :: log_mmin = 9.0_dp real(kind=dp), public :: log_mmax = 9.0_dp integer, public :: n_extra_mX = 0 Optional User can specify extra mass points to add in addition to \n the log-uniform ones chosen integer, public :: n_FDM = 1 Number of mediator types to compute for real(kind=dp), public :: FDMPower_min = 0.0_dp real(kind=dp), public :: FDMPower_max = 0.0_dp integer, public :: n_time = 1 Number of time of days to compute for real(kind=dp), public :: time_day_min = 0.0_dp real(kind=dp), public :: time_day_max = 0.0_dp real(kind=dp), public :: percentile_cut = 3.0_dp real(kind=dp), public :: rhoX_GeV_per_cm3 = 0.4_dp Dark matter density Units : GeV/cm&#94;3 real(kind=dp), public :: v0_km_per_sec = 230.0_dp real(kind=dp), public :: vE_km_per_sec = 240.0_dp real(kind=dp), public :: vEsc_km_per_sec = 600.0_dp real(kind=dp), public :: thetaE = (42.0_dp/180.0_dp)*pi Generated !!!!!!! real(kind=dp), public :: rhoX Dark matter density Units : eV&#94;4 real(kind=dp), public :: v0 real(kind=dp), public :: vE real(kind=dp), public :: vEsc real(kind=dp), public, allocatable :: mX (:) real(kind=dp), public, allocatable :: mX_2 (:) real(kind=dp), public, allocatable :: FDMPowerList (:) real(kind=dp), public, allocatable :: timeOfDayList (:) real(kind=dp), public, allocatable :: vEVecList (:,:) Dim : [n_times, 3] real(kind=dp), public :: g_func_N0 real(kind=dp), public :: g_func_c1 real(kind=dp), public :: g_func_c2 real(kind=dp), public :: v_max = vE + vEsc Functions public function v_minus (q_vec, mX, vE_vec, omega) result(v_m) v_- function Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function g_func (q, v_m) result(g_fun) Kinematic function : Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m Return Value real(kind=dp) public function red_mass (m1, m2) result(mu) Reduced mass Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) public function F_med_sq_func (q_mag, power) result(F_med_sq_val) Mediator for factor squared Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp) Subroutines public subroutine print_particle_physics_scatter (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_particle_physics_scatter (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_particle_physics_scatter (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine set_mX (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose public subroutine set_g_func_parameters () Arguments None public subroutine set_FDM_powers (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose public subroutine set_time_vE_vec (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose","tags":"","loc":"module/particle_physics_scatter.html"},{"title":"Zeff_input – EXCEED-DM","text":"Loads the Zeff paramters for the free calculation Uses prec DFT_parameters core_electrons Contents Variables Zeff_type n_Eb val_Zeff_in Functions get_val_Z_eff Subroutines load_Zeff_parameters Variables Type Visibility Attributes Name Initial character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use 'one' - all Zeff = 1 'Eb' - use the binding energy of the (valence) state 'Eb_c' - use the binding energy of the (core) state 'in' - specified by the input real(kind=dp), public :: n_Eb = 1.0_dp n to use when computing Z_eff with the binding energy approximation real(kind=dp), public :: val_Zeff_in (100) = 1.0_dp Functions public function get_val_Z_eff (i, k) result(Zeff) returns the Z_eff value of the valence state Arguments Type Intent Optional Attributes Name integer :: i integer :: k Return Value real(kind=dp) Subroutines public subroutine load_Zeff_parameters (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/zeff_input.html"},{"title":"calc_dme_scatter_cc – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the cc calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters core_electrons FFT_util in_med_scr Contents Subroutines dme_scatter_cc_calc Subroutines public subroutine dme_scatter_cc_calc (binned_rate_t, wfc_i, wfc_FT_f, init_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: init_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose","tags":"","loc":"module/calc_dme_scatter_cc.html"},{"title":"dme_scatter_cc – EXCEED-DM","text":"Compute the scattering rate from core to conduction states Uses prec numerics_input material_input DFT_parameters core_electrons FFT_util transition calc_dme_scatter_cc Contents Subroutines run_dme_scatter_cc Subroutines public subroutine run_dme_scatter_cc (binned_rate_t, n_tran_per_proc, DFT_input_filename, sto_wf_filename, core_elec_config_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose","tags":"","loc":"module/dme_scatter_cc.html"},{"title":"calc_dme_scatter_cf – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the cf calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter in_med_scr Zeff_input core_electrons Contents Subroutines dme_scatter_cf_calc Subroutines public subroutine dme_scatter_cf_calc (binned_rate_t, init_id, log_omegas, ki_cut, ki_angular_mesh, kf_angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) integer :: init_id real(kind=dp) :: log_omegas (2) integer :: ki_cut real(kind=dp) :: ki_angular_mesh (n_ki_theta*n_ki_phi,2) real(kind=dp) :: kf_angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose","tags":"","loc":"module/calc_dme_scatter_cf.html"},{"title":"dme_scatter_cf – EXCEED-DM","text":"Compute the scattering rate from core to free states Uses prec math_mod numerics_input material_input particle_physics_scatter core_electrons transition Zeff_input calc_dme_scatter_cf Contents Subroutines run_dme_scatter_cf Subroutines public subroutine run_dme_scatter_cf (binned_rate_t, n_tran_per_proc, sto_wf_filename, core_elec_config_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose","tags":"","loc":"module/dme_scatter_cf.html"},{"title":"calc_dme_scatter_vc – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the vc calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters FFT_util in_med_scr Contents Subroutines dme_scatter_vc_calc Subroutines public subroutine dme_scatter_vc_calc (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose","tags":"","loc":"module/calc_dme_scatter_vc.html"},{"title":"dme_scatter_vc – EXCEED-DM","text":"Compute the scattering rate from valence to conduction states Uses prec numerics_input material_input DFT_parameters FFT_util transition calc_dme_scatter_vc Contents Subroutines run_dme_scatter_vc Subroutines public subroutine run_dme_scatter_vc (binned_rate_t, n_tran_per_proc, DFT_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose","tags":"","loc":"module/dme_scatter_vc.html"},{"title":"calc_dme_scatter_vf – EXCEED-DM","text":"Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters in_med_scr Zeff_input Contents Subroutines dme_scatter_vf_calc Subroutines public subroutine dme_scatter_vf_calc (binned_rate_t, wfc_FT_i, val_id, log_omegas, k_cut, angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) integer :: val_id real(kind=dp) :: log_omegas (2) integer :: k_cut real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose","tags":"","loc":"module/calc_dme_scatter_vf.html"},{"title":"dme_scatter_vf – EXCEED-DM","text":"Compute the scattering rate from valence to free states Uses prec math_mod numerics_input material_input DFT_parameters particle_physics_scatter transition Zeff_input calc_dme_scatter_vf Contents Subroutines run_dme_scatter_vf Subroutines public subroutine run_dme_scatter_vf (binned_rate_t, n_tran_per_proc, DFT_input_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose","tags":"","loc":"module/dme_scatter_vf.html"},{"title":"exdm – EXCEED-DM","text":"Uses iso_fortran_env mpi version_control control_input timing io_input material_input dme_scatter EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct\n detection of Dark Matter Contents Variables proc_id n_proc root_process err verbose Variables Type Attributes Name Initial integer :: proc_id Open MPI, processor ID integer :: n_proc Open MPI, number of processors integer :: root_process = 0 Open MPI, root processor ID integer :: err Open MPI error code logical :: verbose = .FALSE. If verbose = .TRUE., print output","tags":"","loc":"program/exdm.html"}]}