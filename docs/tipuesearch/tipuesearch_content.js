var tipuesearch = {"pages":[{"title":" EXCEED-DM ","text":"EXCEED-DM Developer Info Tanner Trickle","tags":"home","loc":"index.html"},{"title":"control_input.f90 – EXCEED-DM","text":"Contents Modules control_input Source Code control_input.f90 Source Code module control_input !! Collection of variables which specify how the program should run implicit none character ( len = 64 ) :: process = '' character ( len = 64 ) :: calc_mode = '' logical :: timer = . TRUE . !! Optional !! !! If .TRUE. the program will output timing information logical :: quiet = . FALSE . !! Don't print any output logical :: save_binned_rate_if = . FALSE . !! save the 2d differential rate data for !! every i -> f transition !! !! memory intensive logical :: overwrite_output = . FALSE . !! if True the output file will be overwritten NAMELIST / control / timer , & quiet , & process , & calc_mode , & save_binned_rate_if , & overwrite_output contains subroutine print_control ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    -------' print * , '    Control' print * , '    -------' print * print * , '        Physics process  : ' , trim ( process ) print * , '        Calculation mode : ' , trim ( calc_mode ) print * , '        Timing?          : ' , timer print * end if end subroutine subroutine load_control ( filename , verbose ) !! Loads the control variables implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error if ( verbose ) then print * , 'Loading control parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = control , iostat = error ) close ( 100 ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Problem reading control namelist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if call print_control ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for control parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/control_input.f90.html"},{"title":"core_electrons.f90 – EXCEED-DM","text":"Contents Modules core_electrons Source Code core_electrons.f90 Source Code module core_electrons !! Handles the wave functions and energy levels for core electrons use hdf5 use h5lt use prec use constants use math_mod implicit none integer :: n_atoms !! Number of atoms in the primitive cell integer :: n_core_states !! Total number of core states integer , allocatable :: Z_list (:) !! Dim : [n_atoms] !! !! Proton number / number of electrons real ( dp ), allocatable :: eq_pos_red (:, :) !! Dim : [n_atoms, 3] !! !! Equilibrium position of the atoms in the primitive cell !! in reduced coordinates !! !! Units : None real ( dp ), allocatable :: core_energy (:) !! Dim : [n_core_states] !! !! Energy of the core states !! !! Units : eV integer , allocatable :: core_elec_conf (:, :) !! Dim : [n_core_states, 5] !! !! Electron configuration, each element is !!  core_elec_conf(i, 1) - atom id !!  core_elec_conf(i, 2) - n !!  core_elec_conf(i, 3) - l !!  core_elec_conf(i, 4) - m !!  core_elec_conf(i, 5) - n_s (number of spin states) !! Generated STO parameters integer , allocatable :: core_sto_nj_list (:) !! Dim : [n_core_states] !! !! Number of terms in the analytic STO expansion integer :: core_sto_max_nj !! Maximum value of core_sto_nj_list real ( dp ), allocatable :: core_sto_data (:, :, :) !! Dim : [n_core_states, 4, max(core_sto_nj_list)] !! !! All of the parameters of the STO expansion !!  core_sto_data(i, 1, :) - n_l[j] !!  core_sto_data(i, 2, :) - Z_l[j] !!  core_sto_data(i, 3, :) - N_l[j] !!  core_sto_data(i, 4, :) - C_nl[j] contains subroutine save_core_electrons ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id , group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving core electron configuration...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'core' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , 'core/n_core_states' , size ( dims1 ), dims1 ,& n_core_states , error ) call h5ltmake_dataset_int_f ( file_id , 'core/n_atoms' , size ( dims1 ), dims1 ,& n_atoms , error ) dims1 = [ n_atoms ] call h5ltmake_dataset_int_f ( file_id , 'core/Z_list' , size ( dims1 ), dims1 ,& Z_list , error ) dims2 = [ n_atoms , 3 ] call h5ltmake_dataset_double_f ( file_id , 'core/eq_pos_red' , size ( dims2 ), dims2 ,& eq_pos_red , error ) dims1 = [ n_core_states ] call h5ltmake_dataset_double_f ( file_id , 'core/core_energy' , size ( dims1 ), dims1 ,& core_energy , error ) dims2 = [ n_core_states , 5 ] call h5ltmake_dataset_int_f ( file_id , 'core/core_elec_config' , size ( dims2 ), dims2 ,& core_elec_conf , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine calc_core_sto_wf_grid ( core_wfc , core_state_idx , n_grid , red_to_xyz ,& shift , k_vec_in , s_cut_in , verbose ) !! computes the core wave functions on a grid, summed over the closest unit cells !! !! if shift == T : x_shift = x_pos_red (equilibrium position) !! else: x_shift = 0 !! core_sto_wf_grid(x) = sum_s core_sto_wf(x - x_shift + s) !! !! where x_i is the atomic equilibrium position implicit none logical , optional :: verbose logical , optional :: shift integer :: n_grid ( 3 ) !! Number of grid points in reduced x coordinates complex ( dp ) :: core_wfc ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) real ( dp ), optional :: k_vec_in ( 3 ) real ( dp ) :: k_vec ( 3 ) integer , optional :: s_cut_in integer :: s_cut integer :: core_state_idx integer :: n1 , n2 , n3 integer :: s1 , s2 , s3 real ( dp ) :: x_red ( 3 ) real ( dp ) :: s_red ( 3 ) real ( dp ) :: x_vec ( 3 ) real ( dp ) :: x_shift_red ( 3 ) real ( dp ) :: x_shift ( 3 ) real ( dp ) :: red_to_xyz ( 3 , 3 ) complex ( dp ) :: core_sto_wf_sum complex ( dp ) :: phase_fac real ( dp ) :: y_vec ( 3 ) !! y = x + r - x_i integer :: s , s_count , n_s real ( dp ), allocatable :: s_red_list (:, :) real ( dp ), allocatable :: s_vec_list (:, :) if ( shift ) then x_shift_red = eq_pos_red ( core_elec_conf ( core_state_idx , 1 ), :) else x_shift_red = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if x_shift = matmul ( red_to_xyz , x_shift_red ) if ( present ( k_vec_in ) ) then k_vec = k_vec_in else k_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if if ( present ( s_cut_in ) ) then s_cut = s_cut_in else s_cut = 1 end if n_s = ( 2 * s_cut + 1 ) ** 3 allocate ( s_red_list ( 3 , n_s )) allocate ( s_vec_list ( 3 , n_s )) s_count = 0 do s1 = - s_cut , s_cut do s2 = - s_cut , s_cut do s3 = - s_cut , s_cut s_count = s_count + 1 s_red_list (:, s_count ) = [ 1.0_dp * s1 , 1.0_dp * s2 , 1.0_dp * s3 ] s_vec_list (:, s_count ) = matmul ( red_to_xyz , s_red_list (:, s_count )) end do end do end do do n3 = 1 , n_grid ( 3 ) do n2 = 1 , n_grid ( 2 ) do n1 = 1 , n_grid ( 1 ) x_red = [( n1 - 1.0_dp ) / n_grid ( 1 ),& ( n2 - 1.0_dp ) / n_grid ( 2 ),& ( n3 - 1.0_dp ) / n_grid ( 3 )] x_vec = matmul ( red_to_xyz , x_red ) core_sto_wf_sum = cmplx ( 0.0_dp , 0.0_dp , dp ) do s = 1 , n_s phase_fac = exp ( ii * dot_product ( k_vec , s_vec_list (:, s ) - x_vec )) y_vec = x_vec - x_shift + s_vec_list (:, s ) core_sto_wf_sum = core_sto_wf_sum + & phase_fac * core_sto_wf ( core_state_idx , y_vec ) end do core_wfc ( n1 , n2 , n3 ) = core_sto_wf_sum end do end do end do end subroutine function core_sto_wf ( core_state_idx , x_vec ) result ( val ) !! Core wave function !! !! Units : eV&#94;(3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: l , m real ( dp ) :: x_vec ( 3 ), x_hat ( 3 ) real ( dp ) :: x_mag complex ( dp ) :: val x_mag = norm2 ( x_vec ) !! avoid |x| = 0 problems if ( x_mag . gt . 1e-8_dp ) then x_hat = x_vec / x_mag else x_hat = [ 0 , 0 , 1 ] end if l = core_elec_conf ( core_state_idx , 3 ) m = core_elec_conf ( core_state_idx , 4 ) val = core_sto_wf_radial ( core_state_idx , x_mag ) * sph_harmonic ( l , m ,& get_theta ( x_hat ), get_phi ( x_hat )) end function function core_sto_wf_FT ( core_state_idx , k_vec ) result ( val ) !! Fourier transform of the core wave function !! !! Units : eV&#94;(-3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: l , m real ( dp ) :: k_vec ( 3 ), k_hat ( 3 ) real ( dp ) :: k_mag complex ( dp ) :: val k_mag = norm2 ( k_vec ) !! avoid |k| = 0 problems if ( k_mag . gt . 1e-8_dp ) then k_hat = k_vec / k_mag else k_hat = [ 0 , 0 , 1 ] end if l = core_elec_conf ( core_state_idx , 3 ) m = core_elec_conf ( core_state_idx , 4 ) val = core_sto_wf_FT_radial ( core_state_idx , k_mag ) * sph_harmonic ( l , m ,& get_theta ( k_hat ), get_phi ( k_hat )) end function function core_sto_wf_radial ( core_state_idx , x_mag ) result ( val ) !! Radial part of the total core wave function, summed over !! the individual sto_wf_radial !! !! Units : eV&#94;(3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: atom , n , l , m integer :: j integer :: n_lj , nj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: x_mag real ( dp ) :: val val = 0.0_dp l = core_elec_conf ( core_state_idx , 3 ) nj = core_sto_nj_list ( core_state_idx ) do j = 1 , nj n_lj = int ( core_sto_data ( core_state_idx , 1 , j )) Z_lj = core_sto_data ( core_state_idx , 2 , j ) N0_lj = core_sto_data ( core_state_idx , 3 , j ) C_lnj = core_sto_data ( core_state_idx , 4 , j ) val = val + C_lnj * sto_wf_radial ( n_lj , N0_lj , Z_lj , x_mag ) end do end function function core_sto_wf_FT_radial ( core_state_idx , k_mag ) result ( chi ) !! Radial part of the total Fourier transformed core wave function, summed over !! the individual sto_wf_FT_radial !! !! Units : eV&#94;(-3/2) implicit none integer :: core_state_idx !! references a specific element in core_elec_conf integer :: atom , n , l , m integer :: j integer :: n_lj , nj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: k_mag complex ( dp ) :: chi chi = cmplx ( 0.0_dp , 0.0_dp , dp ) l = core_elec_conf ( core_state_idx , 3 ) nj = core_sto_nj_list ( core_state_idx ) do j = 1 , nj n_lj = int ( core_sto_data ( core_state_idx , 1 , j )) Z_lj = core_sto_data ( core_state_idx , 2 , j ) N0_lj = core_sto_data ( core_state_idx , 3 , j ) C_lnj = core_sto_data ( core_state_idx , 4 , j ) chi = chi + C_lnj * sto_wf_FT_radial ( n_lj , l , N0_lj , Z_lj , k_mag ) end do end function function sto_wf_radial ( n , norm , Z , x_mag ) result ( val ) !! Radial part of the Slater type orbital (STO) wave function !! !! Units : eV&#94;(3/2) implicit none integer :: n real ( dp ) :: norm , Z , x_mag real ( dp ) :: val val = a0 ** ( - 1.5 ) * norm * ( x_mag / a0 ) ** ( n - 1 ) * exp ( - Z * x_mag / a0 ) end function function sto_wf_FT_radial ( n , l , norm , Z , k_mag ) result ( val ) !! Radial part of the fourier transform of a Slater type orbital (STO) wave function !! !! sto_wf_FT = int d&#94;3x sto_wf e&#94;(-ikr) !!           = (sto_wf_FT_radial) * sph_harmonic(k hat) !! !! Reference : https://en.wikipedia.org/wiki/Slater-type_orbital !! !! Units : eV&#94;(-3/2) implicit none integer :: n , l real ( dp ) :: norm , Z , k_mag complex ( dp ) :: val integer :: s real ( dp ) :: omega_s , xi val = cmplx ( 0.0_dp , 0.0_dp , dp ) xi = Z / a0 do s = 0 , floor (( n - l ) / 2.0_dp ) omega_s = ( - 4 * xi ** 2 ) ** ( - s ) * factorial ( n - s ) * & ( factorial ( s ) * factorial ( n - l - 2 * s )) ** ( - 1 ) val = val + omega_s * ( k_mag ** 2 + xi ** 2 ) ** ( s - n - 1 ) end do val = a0 ** ( - 0.5 ) * a0 ** ( - n ) * norm * ( 4 * pi ) * factorial ( n - l ) * & ( 2 * xi ) ** n * ( ii * k_mag / xi ) ** l * val end function subroutine load_core_elec_config ( filename , verbose ) !! Reads the core electron configuration file implicit none logical , optional :: verbose character ( len =* ) :: filename integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims1 ( 1 ) integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Loading core electron configuration...' print * end if inquire ( file = filename , exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_int_f ( file_id , 'n_atoms' , n_atoms , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_core_states' , n_core_states , dims , error ) dims2 = [ n_atoms , 3 ] allocate ( eq_pos_red ( n_atoms , 3 )) call h5ltread_dataset_double_f ( file_id , 'eq_pos_red' , eq_pos_red , dims2 , error ) dims1 = [ n_core_states ] allocate ( core_energy ( n_core_states )) call h5ltread_dataset_double_f ( file_id , 'core_energy' , core_energy , dims1 , error ) dims1 = [ n_atoms ] allocate ( Z_list ( n_atoms )) call h5ltread_dataset_int_f ( file_id , 'Z_list' , Z_list , dims1 , error ) dims2 = [ n_core_states , 5 ] allocate ( core_elec_conf ( n_core_states , 5 )) call h5ltread_dataset_int_f ( file_id , 'core_elec_config' , core_elec_conf , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) call print_core_elec_config ( filename , verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Core electron configuration file : ' print * , '    ' , trim ( filename ) print * , '    does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_core_elec_config ( filename , verbose ) implicit none logical , optional :: verbose integer :: n character ( len =* ) :: filename if ( verbose ) then print * , '----------------------------------------' print * , '    ---------------------------' print * , '    Core Electron Configuration' print * , '    ---------------------------' print * print * , '        Core electron configuration filename : ' , trim ( filename ) print * print * , '        Number of atoms = ' , n_atoms print * , '        Proton numbers = ' , Z_list print * , '        Number of core states = ' , n_core_states print * print * , '        Equilibrium positions (reduced) : ' do n = 1 , n_atoms print * , '            atom # = ' , n , ', ' , eq_pos_red ( n , :) end do print * print * , '        Core electron configuration : ' do n = 1 , n_core_states print * , '            atom = ' , core_elec_conf ( n , 1 ) print * , '            n    = ' , core_elec_conf ( n , 2 ) print * , '            l    = ' , core_elec_conf ( n , 3 ) print * , '            m    = ' , core_elec_conf ( n , 4 ) print * , '            n_s  = ' , core_elec_conf ( n , 5 ) print * print * , '            energy = ' , core_energy ( n ), 'eV' print * end do end if end subroutine subroutine load_core_sto_data ( filename , verbose ) !! Reads the sto wf file to get the relevant !! coefficients for the electron configuration !! specified in the core_elec_conf implicit none character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) integer ( HSIZE_T ) :: dims1 ( 1 ) integer ( HSIZE_T ) :: dims2 ( 2 ) character ( len = 64 ) :: dset_name integer :: error integer :: n , nj real ( dp ), allocatable :: buf (:) dims = [ 1 ] if ( verbose ) then print * , 'Loading STO wf data file...' print * end if inquire ( file = filename , exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) allocate ( core_sto_nj_list ( n_core_states )) !! get the relevant data for each core state do n = 1 , n_core_states dset_name = get_sto_dataset_str ( Z_list ( core_elec_conf ( n , 1 )),& core_elec_conf ( n , 2 ),& core_elec_conf ( n , 3 )) call h5ltread_dataset_int_f ( file_id ,& trim ( dset_name ) // '/nj' ,& core_sto_nj_list ( n ),& dims , error ) end do core_sto_max_nj = maxval ( core_sto_nj_list ) allocate ( core_sto_data ( n_core_states , 4 , core_sto_max_nj )) core_sto_data = 0.0_dp do n = 1 , n_core_states nj = core_sto_nj_list ( n ) dset_name = get_sto_dataset_str ( Z_list ( core_elec_conf ( n , 1 )),& core_elec_conf ( n , 2 ),& core_elec_conf ( n , 3 )) dims1 = [ nj ] allocate ( buf ( nj )) call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/n_lj' , buf , dims1 , error ) core_sto_data ( n , 1 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/Z_lj' , buf , dims1 , error ) core_sto_data ( n , 2 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/N_lj' , buf , dims1 , error ) core_sto_data ( n , 3 , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/C_lnj' , buf , dims1 , error ) core_sto_data ( n , 4 , : nj ) = buf deallocate ( buf ) end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) call print_sto_data ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    STO wave function coefficient file : ' print * , '    ' , trim ( filename ) print * , '    does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine function get_sto_dataset_str ( Z , n , l ) result ( dset_name ) !! Returns the name of the dataset for nth element in the !! core electron configuration implicit none integer :: Z , n , l character ( len = 64 ) :: Z_str , n_str , l_str character ( len = 64 ) :: dset_name write ( Z_str , * ) Z Z_str = adjustl ( Z_str ) write ( n_str , * ) n n_str = adjustl ( n_str ) write ( l_str , * ) l l_str = adjustl ( l_str ) dset_name = 'Z_' // trim ( Z_str ) // '/n_' // trim ( n_str ) // '/l_' // trim ( l_str ) end function subroutine print_sto_data ( verbose ) implicit none logical , optional :: verbose integer :: n integer :: a if ( verbose ) then print * , '----------------------------------------' print * , '    -------------------' print * , '    STO WF Coefficients' print * , '    -------------------' print * do n = 1 , n_core_states if ( core_elec_conf ( n , 4 ) == 0 ) then print * , '        atom = ' , core_elec_conf ( n , 1 ) print * , '        n    = ' , core_elec_conf ( n , 2 ) print * , '        l    = ' , core_elec_conf ( n , 3 ) ! print*, '    m    = ', core_elec_conf(n, 4) print * print * , '            Number of coefficients = ' , core_sto_nj_list ( n ) print * , '            n_lj = ' , core_sto_data ( n , 1 , :) print * , '            Z_lj = ' , core_sto_data ( n , 2 , :) print * , '            N0_lj = ' , core_sto_data ( n , 3 , :) print * , '            C_lnj = ' , core_sto_data ( n , 4 , :) print * end if end do end if end subroutine end module","tags":"","loc":"sourcefile/core_electrons.f90.html"},{"title":"DFT_parameters.f90 – EXCEED-DM","text":"Contents Modules DFT_parameters Source Code DFT_parameters.f90 Source Code module DFT_parameters !! Handles the results from DFT calculations that compute the Bloch wave !! function coefficients. !! !! Variables with '_A' are with units of Angstroms use h5lt use hdf5 use prec use constants use units implicit none integer :: n_k !! Number of k points integer :: n_val !! Number of valence bands integer :: n_cond !! Number of conduction bands integer :: n_in_G !! Number of G points in in_G_grid integer , allocatable :: in_G_grid_red (:, :) !! Dim : [n_in_G, 3] !! !! Input grid of G vectors in reduced coordinates real ( dp ) :: a_vecs_A ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : Ang real ( dp ) :: b_vecs_A ( 3 , 3 ) !! Reciprocal lattice vector !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : Ang&#94;(-1) real ( dp ), allocatable :: k_weight (:) !! Dim : [n_k] !! !! Weights of each k point in the k_red grid, must sum to 2 !! !! Units : None real ( dp ), allocatable :: k_grid_red (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in reduced coordinates !! !! Units : None real ( dp ), allocatable :: energy_bands_raw (:, :) !! Dim : [n_k, n_bands] !! !! Raw electron energy eigenvalues !! !! Units : eV !! Generated from input integer :: n_bands !! Number of bands !! !! n_bands = n_cond + n_val real ( dp ) :: q_PW_cut !! plane wave cutoff in expansion !! !! Units : eV real ( dp ) :: E_PW_cut !! energy cooresponding to q_PW_cut !! !! E_PW_cut = q_PW_cut**2/(2*m_elec) !! !! Units : eV real ( dp ) :: a_vecs ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : eV real ( dp ) :: red_to_xyz ( 3 , 3 ) !! Matrix converting reduced cooredinate positions to physical xyz cooredinates !! in eV&#94;(-1) via !! !!      x_xyz = matmul(red_to_xyz, x_red) !! !! red_to_xyz = transpose(a_vecs) !! !! Units : eV&#94;(-1) real ( dp ) :: b_vecs ( 3 , 3 ) !! Reciprocal lattice vector !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : eV real ( dp ) :: k_red_to_xyz ( 3 , 3 ) !! Matrix converting reduced coordinate momentum to physical xyz coordinates !! in eV via !! !!      k_xyz = matmul(k_red_to_xyz, k_red) !! !! k_red_to_xyz = transpose(b_vecs) !! !! Units : eV real ( dp ), allocatable :: energy_bands (:, :) !! Dim : [n_k, n_bands] !! !! Scissor corrected electron energy eigenvalues !! !! Units : eV real ( dp ), allocatable :: in_G_grid_xyz (:, :) !! Dim : [n_in_G, 3] !! !! Input grid of G vectors in physical xyz coordinates !! !! Units : eV real ( dp ), allocatable :: k_grid_xyz (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in xyz coordinates !! !! Units : eV !!! experimental logical :: include_spin = . FALSE . interface get_in_wfc_FT module procedure get_in_wfc_FT_no_spin module procedure get_in_wfc_FT_spin end interface contains subroutine save_DFT_parameters ( filename , verbose ) !! Saves some of the DFT input variables to filename implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id , group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) = [ 3 , 3 ] integer :: error if ( verbose ) then print * , 'Saving DFT parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'DFT_parameters' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_val' , size ( dims1 ), dims1 ,& n_val , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_cond' , size ( dims1 ), dims1 ,& n_cond , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_bands' , size ( dims1 ), dims1 ,& n_bands , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_k' , size ( dims1 ), dims1 ,& n_k , error ) call h5ltmake_dataset_int_f ( file_id , 'DFT_parameters/n_in_G' , size ( dims1 ), dims1 ,& n_in_G , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/E_PW_cut' , size ( dims1 ), dims1 ,& E_PW_cut , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/q_PW_cut' , size ( dims1 ), dims1 ,& q_PW_cut , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/k_red_to_xyz' , size ( dims2 ), dims2 ,& k_red_to_xyz , error ) call h5ltmake_dataset_double_f ( file_id , 'DFT_parameters/red_to_xyz' , size ( dims2 ), dims2 ,& red_to_xyz , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine load_DFT_parameters ( filename , verbose ) !! Loads the DFT input file implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: g , k integer :: wfc_data_rank if ( verbose ) then print * , 'Loading DFT input file...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) ! read the data call h5ltread_dataset_int_f ( file_id , 'n_k' , n_k , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_val' , n_val , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_cond' , n_cond , dims , error ) n_bands = n_val + n_cond call h5ltread_dataset_int_f ( file_id , 'n_in_G' , n_in_G , dims , error ) allocate ( in_G_grid_red ( n_in_G , 3 )) dims2 = [ n_in_G , 3 ] call h5ltread_dataset_int_f ( file_id , 'in_G_grid_red' , in_G_grid_red , dims2 , error ) dims2 = [ 3 , 3 ] call h5ltread_dataset_double_f ( file_id , 'a_vecs_A' , a_vecs_A , dims2 , error ) a_vecs = Ang_to_inv_eV * a_vecs_A red_to_xyz = transpose ( a_vecs ) call h5ltread_dataset_double_f ( file_id , 'b_vecs_A' , b_vecs_A , dims2 , error ) b_vecs = inv_Ang_to_eV * b_vecs_A k_red_to_xyz = transpose ( b_vecs ) ! convert reduced coordinates to xyz allocate ( in_G_grid_xyz ( n_in_G , 3 )) do g = 1 , n_in_G in_G_grid_xyz ( g , :) = matmul ( k_red_to_xyz , in_G_grid_red ( g , :)) end do allocate ( k_weight ( n_k )) dims = [ n_k ] call h5ltread_dataset_double_f ( file_id , 'k_weight' , k_weight , dims , error ) allocate ( k_grid_red ( n_k , 3 )) dims2 = [ n_k , 3 ] call h5ltread_dataset_double_f ( file_id , 'k_red' , k_grid_red , dims2 , error ) allocate ( k_grid_xyz ( n_k , 3 )) do k = 1 , n_k k_grid_xyz ( k , :) = matmul ( k_red_to_xyz , k_grid_red ( k , :)) end do allocate ( energy_bands_raw ( n_k , n_bands )) allocate ( energy_bands ( n_k , n_bands )) dims2 = [ n_k , n_bands ] call h5ltread_dataset_double_f ( file_id , 'energy_bands_raw' , energy_bands_raw , dims2 , error ) call h5ltget_dataset_ndims_f ( file_id , 'in_wfc_FT_c/1' , wfc_data_rank , error ) if ( wfc_data_rank == 3 ) then include_spin = . TRUE . end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) call check_DFT_parameters ( verbose ) call print_DFT_parameters ( filename , verbose = verbose ) ! find how much the wave function coefficients were expanded call get_PW_cutoffs ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for DFT parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine check_DFT_parameters ( verbose ) !! Check the values of of the input file to make sure they make sense implicit none logical , optional :: verbose real ( dp ), parameter :: pi = 4.0_dp * datan ( 1.0_dp ) real ( dp ) :: i_3_2pi ( 3 , 3 ) real ( dp ) :: eps_val if ( verbose ) then print * , 'Running preliminary checks on DFT data...' print * end if i_3_2pi = 0.0_dp i_3_2pi ( 1 , 1 ) = 2 * pi i_3_2pi ( 2 , 2 ) = 2 * pi i_3_2pi ( 3 , 3 ) = 2 * pi ! a_i . b_j = 2*pi delta_ij eps_val = abs ( sum ( matmul ( transpose ( k_red_to_xyz ), red_to_xyz ) - i_3_2pi ) / 3.0_dp ) if ( eps_val > 1e-3_dp ) then print * , '!! ERROR !!' print * print * , '   Basis vectors are not orthonormalized correctly. a_i . b_j != 2 pi delta_ij' print * print * , '!!!!!!!!!!!' print * stop end if ! sum_k k_weight(k) = 2 eps_val = sum ( k_weight ) - 2.0_dp if ( eps_val > 1e-3_dp ) then print * , '!! ERROR !!' print * print * , '   Sum of k weights != 2' print * print * , '!!!!!!!!!!!' print * stop end if end subroutine subroutine print_DFT_parameters ( filename , verbose ) !! Prints variables defined in this moudle implicit none character ( len =* ) :: filename logical , optional :: verbose character ( len = 64 ) :: n_k_str character ( len = 64 ) :: n_in_G_str character ( len = 64 ) :: n_val_str character ( len = 64 ) :: n_cond_str write ( n_k_str , * ) n_k write ( n_val_str , * ) n_val write ( n_cond_str , * ) n_cond write ( n_in_G_str , * ) n_in_G if ( verbose ) then print * , '----------------------------------------' print * , '    ---------' print * , '    DFT Input' print * , '    ---------' print * print * , '        Filename : ' , trim ( filename ) print * print * , '        Primitive lattice vectors (Ang) : ' print * , '            a1 = ' , a_vecs_A ( 1 , :) print * , '            a2 = ' , a_vecs_A ( 2 , :) print * , '            a3 = ' , a_vecs_A ( 3 , :) print * print * , '        Reciprocal lattice vectors Ang&#94;(-1) : ' print * , '            b1 = ' , b_vecs_A ( 1 , :) print * , '            b2 = ' , b_vecs_A ( 2 , :) print * , '            b3 = ' , b_vecs_A ( 3 , :) print * print * , '        Number of valence bands     = ' , trim ( adjustl ( n_val_str )) print * , '        Number of conduction bands  = ' , trim ( adjustl ( n_cond_str )) print * print * , '        Number of k points          = ' , trim ( adjustl ( n_k_str )) print * print * , '        Number of G points          = ' , trim ( adjustl ( n_in_G_str )) print * print * , '        Include spin?               = ' , include_spin print * end if end subroutine subroutine get_in_wfc_FT_no_spin ( filename , band_num , in_wfc_FT ) !! Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array !! with whose elements are the dimensionless block wave function !! coefficients, u_ikG implicit none character ( len =* ) :: filename integer :: band_num complex ( dp ) :: in_wfc_FT (:, :) !! Bloch wave functions in reciprocal space integer ( HID_T ) :: file_id !! HDF5 file ID number for DFT input file real ( dp ) :: in_wfc_FT_r ( n_k , n_in_G ) !! real part of the bloch wave functions in fourier space real ( dp ) :: in_wfc_FT_c ( n_k , n_in_G ) !! complex part of the bloch wave functions in fourier space integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error character ( len = 64 ) :: dataset_path_r character ( len = 64 ) :: dataset_path_c character ( len = 64 ) :: band_num_str write ( band_num_str , * ) band_num dataset_path_r = 'in_wfc_FT_r/' // trim ( adjustl ( band_num_str )) dataset_path_c = 'in_wfc_FT_c/' // trim ( adjustl ( band_num_str )) dims2 = [ n_k , n_in_G ] call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_r , in_wfc_FT_r , dims2 , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_c , in_wfc_FT_c , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) in_wfc_FT = in_wfc_FT_r + ii * in_wfc_FT_c end subroutine subroutine get_in_wfc_FT_spin ( filename , band_num , in_wfc_FT ) !! Reads the input DFT file and sets the [n_k, n_in_G, 2] complex(dp) array !! with whose elements are the dimensionless block wave function !! coefficients, u_{i, k, G, s}, where s is the spin index implicit none character ( len =* ) :: filename integer :: band_num complex ( dp ) :: in_wfc_FT (:, :, :) !! Bloch wave functions in reciprocal space integer ( HID_T ) :: file_id !! HDF5 file ID number for DFT input file real ( dp ) :: in_wfc_FT_r ( n_k , n_in_G , 2 ) !! real part of the bloch wave functions in fourier space real ( dp ) :: in_wfc_FT_c ( n_k , n_in_G , 2 ) !! complex part of the bloch wave functions in fourier space integer ( HSIZE_T ) :: dims3 ( 3 ) integer :: error character ( len = 64 ) :: dataset_path_r character ( len = 64 ) :: dataset_path_c character ( len = 64 ) :: band_num_str write ( band_num_str , * ) band_num dataset_path_r = 'in_wfc_FT_r/' // trim ( adjustl ( band_num_str )) dataset_path_c = 'in_wfc_FT_c/' // trim ( adjustl ( band_num_str )) dims3 = [ n_k , n_in_G , 2 ] call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_r , in_wfc_FT_r , dims3 , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_c , in_wfc_FT_c , dims3 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) in_wfc_FT = in_wfc_FT_r + ii * in_wfc_FT_c end subroutine subroutine expand_wfc_FT_for_FFT ( n_grid ,& wfc_FT , wfc_FT_exp ,& verbose ) !! The Fourier components will generally not be defined on a !! uniform grid needed for an FFT. This subroutine puts the !! values of the Bloch coefficients in the correct place use FFT_util implicit none integer :: n_grid ( 3 ) complex ( dp ) :: wfc_FT ( n_in_G ) complex ( dp ) :: wfc_FT_exp ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) logical , optional :: verbose integer :: g integer :: FFT_idx ( 3 ) wfc_FT_exp = ( 0.0_dp , 0.0_dp ) do g = 1 , n_in_G call G_red_to_FFT_G_grid_index ( n_grid , in_G_grid_red ( g , :), FFT_idx ) wfc_FT_exp ( FFT_idx ( 1 ), FFT_idx ( 2 ), FFT_idx ( 3 )) = wfc_FT ( g ) end do end subroutine function in_wfc_at_single_pt ( band_num , x0_red , in_wfc_FT ) result ( wfc ) !! returns the wave function evaluated at a point in !! reduced coordinates at a single point !! !! av_wfc(x0)_k = sum_G e&#94;(i G.x0) wfc(G)_k implicit none integer :: band_num real ( dp ) :: x0_red ( 3 ) real ( dp ) :: x0 ( 3 ) complex ( dp ) :: phase_fac ( n_in_G ) complex ( dp ) :: wfc ( n_k ) complex ( dp ) :: in_wfc_FT ( n_k , n_in_G ) integer :: g x0 = matmul ( red_to_xyz , x0_red ) phase_fac = cmplx ( 0.0_dp , 0.0_dp , dp ) do g = 1 , n_in_G phase_fac ( g ) = exp ( ii * dot_product ( in_G_grid_xyz ( g , :), x0 )) end do wfc = matmul ( in_wfc_FT , phase_fac ) end function subroutine get_PW_cutoffs ( verbose ) !! Calculate the plane wave expansion parameters implicit none logical , optional :: verbose integer :: k , g real ( dp ) :: q_xyz ( 3 ) real ( dp ) :: q_mag q_PW_cut = 0.0_dp E_PW_cut = 0.0_dp do k = 1 , n_k do g = 1 , n_in_G q_xyz = k_grid_xyz ( k , :) + in_G_grid_xyz ( g , :) q_mag = norm2 ( q_xyz ) if ( q_mag . ge . q_PW_cut ) then q_PW_cut = q_mag end if end do end do E_PW_cut = q_PW_cut ** 2 / ( 2.0_dp * m_elec ) if ( verbose ) then print * , '        Plane wave expansion parameters : ' print * , '            E_PW_cut = ' , E_PW_cut , 'eV' print * , '            q_PW_cut = ' , q_PW_cut / 1.0e3_dp , 'keV' print * end if end subroutine subroutine do_scissor_correction ( band_gap , verbose ) implicit none logical , optional :: verbose real ( dp ) :: band_gap real ( dp ) :: scissor_correct scissor_correct = band_gap - & ( minval ( energy_bands_raw (:, n_val + 1 :)) - maxval ( energy_bands_raw (:, : n_val ))) energy_bands = 0.0_dp energy_bands (:, : n_val ) = energy_bands_raw (:, : n_val ) - scissor_correct / 2.0_dp energy_bands (:, n_val + 1 :) = energy_bands_raw (:, n_val + 1 :) + scissor_correct / 2.0_dp if ( verbose ) then print * , 'Performed scissor correction.' print * end if end subroutine function get_w_max ( i ) result ( w_max ) !! Returns the maximum energy transfer allowed from valence state i implicit none integer :: i real ( dp ) :: w_max w_max = maxval ( energy_bands ) - minval ( energy_bands (:, i )) end function end module","tags":"","loc":"sourcefile/dft_parameters.f90.html"},{"title":"exdm.f90 – EXCEED-DM","text":"Contents Programs exdm Source Code exdm.f90 Source Code program exdm !! EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct !! detection of Dark Matter use iso_fortran_env use mpi use version_control use control_input use timing use io_input use material_input use dme_absorption use exdm_scatter implicit none integer :: proc_id !! Open MPI, processor ID integer :: n_proc !! Open MPI, number of processors character ( len = 64 ) :: n_proc_str !! Number of processors in string format integer :: root_process = 0 !! Open MPI, root processor ID integer :: err !! Open MPI error code logical :: verbose = . FALSE . !! If verbose = .TRUE., print output call MPI_INIT ( err ) call MPI_COMM_RANK ( MPI_COMM_WORLD , proc_id , err ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) if ( proc_id . eq . root_process ) then write ( n_proc_str , * ) n_proc print * print * , '----------------------------------------' print * print * , '    EXCEED-DM - v' , version print * print * , '    Running on ' , trim ( adjustl ( n_proc_str )), ' processors' print * , '    Compiled with ' , compiler_version () print * print * , '----------------------------------------' print * ! prints output information if ( . not . quiet ) then verbose = . TRUE . else verbose = . FALSE . end if time ( 1 ) = MPI_Wtime () end if call get_command_argument ( 1 , nml_input_filename ) ! load inputs call load_control ( nml_input_filename , verbose = verbose ) call load_io ( nml_input_filename , verbose = verbose ) call load_material ( nml_input_filename , verbose = verbose ) ! create the output file if ( proc_id == root_process ) then call create_output_file ( out_filename , overwrite_output , verbose = verbose ) end if ! compute and save data if ( trim ( process ) == 'scatter' ) then call run_dme_scatter ( proc_id , root_process , out_filename , & nml_input_filename , DFT_input_filename , sto_wf_filename , & core_elec_config_filename , n_proc , save_binned_rate_if , verbose = verbose ) else if ( trim ( process ) == 'absorption' ) then call run_dme_absorption ( proc_id , root_process , out_filename , & nml_input_filename , DFT_input_filename , n_proc , verbose = verbose ) else print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Process : ' , trim ( process ), ' is not implemented.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * stop end if ! save input data common to all processes if ( proc_id . eq . root_process ) then call save_material ( out_filename , verbose = verbose ) end if ! Time program if ( proc_id . eq . root_process ) then time ( 2 ) = MPI_Wtime () if ( verbose ) then print * , '----------------------------------------' print * , '    ------' print * , '    Timing' print * , '    ------' print * print * , '        Run time : ' print * , '        ' , trim ( pretty_time_format ( time ( 2 ) - time ( 1 ))) print * print * , '----------------------------------------' print * end if end if call MPI_FINALIZE ( err ) end program","tags":"","loc":"sourcefile/exdm.f90.html"},{"title":"FFT_util.f90 – EXCEED-DM","text":"Contents Modules FFT_util Source Code FFT_util.f90 Source Code module FFT_util !! Utilities for computing FFT's use prec use fftw3 implicit none real ( dp ), allocatable :: sym_FFT_G_grid_xyz (:, :, :, :) !! FFT G grid shifted so that both + and - G's are represented contains function get_sym_FFT_G_grid_red ( n_grid , G_ind_vec , verbose ) result ( G_red ) implicit none integer :: n_grid ( 3 ) integer :: G_red ( 3 ) integer :: G_ind_vec ( 3 ) integer :: g1 , g2 , g3 logical , optional :: verbose g1 = G_ind_vec ( 1 ) g2 = G_ind_vec ( 2 ) g3 = G_ind_vec ( 3 ) G_red = [ g1 - 1 , g2 - 1 , g3 - 1 ] if ( g1 . gt . n_grid ( 1 ) / 2 ) then G_red ( 1 ) = g1 - n_grid ( 1 ) - 1 end if if ( g2 . gt . n_grid ( 2 ) / 2 ) then G_red ( 2 ) = g2 - n_grid ( 2 ) - 1 end if if ( g3 . gt . n_grid ( 3 ) / 2 ) then G_red ( 3 ) = g3 - n_grid ( 3 ) - 1 end if end function function get_sym_FFT_G_grid_xyz ( n_grid , G_ind_vec , k_red_to_xyz , verbose ) result ( G_xyz ) implicit none integer :: n_grid ( 3 ) integer :: G_red ( 3 ) integer :: G_ind_vec ( 3 ) integer :: g1 , g2 , g3 real ( dp ) :: k_red_to_xyz ( 3 , 3 ) real ( dp ) :: G_xyz ( 3 ) logical , optional :: verbose g1 = G_ind_vec ( 1 ) g2 = G_ind_vec ( 2 ) g3 = G_ind_vec ( 3 ) G_red = [ g1 - 1 , g2 - 1 , g3 - 1 ] if ( g1 . gt . n_grid ( 1 ) / 2 ) then G_red ( 1 ) = g1 - n_grid ( 1 ) - 1 end if if ( g2 . gt . n_grid ( 2 ) / 2 ) then G_red ( 2 ) = g2 - n_grid ( 2 ) - 1 end if if ( g3 . gt . n_grid ( 3 ) / 2 ) then G_red ( 3 ) = g3 - n_grid ( 3 ) - 1 end if G_xyz = matmul ( k_red_to_xyz , G_red ) end function subroutine set_sym_FFT_G_grid_xyz ( n_grid , k_red_to_xyz , verbose ) !! Symmetric FFT grid. !! !! Standard convention for FFTs is to compute for frequencies 0 -> N-1. !! This subroutine creates a map which takes the larger half of the positive !! frequencies and maps then back to negative values, for a symmetric G grid. implicit none real ( dp ) :: k_red_to_xyz ( 3 , 3 ) logical , optional :: verbose integer :: g1 , g2 , g3 integer :: G_red ( 3 ) integer :: n_grid ( 3 ) allocate ( sym_FFT_G_grid_xyz ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 ), 3 )) do g3 = 1 , n_grid ( 3 ) do g2 = 1 , n_grid ( 2 ) do g1 = 1 , n_grid ( 1 ) G_red = [ g1 - 1 , g2 - 1 , g3 - 1 ] if ( g1 . gt . n_grid ( 1 ) / 2 ) then G_red ( 1 ) = g1 - n_grid ( 1 ) - 1 end if if ( g2 . gt . n_grid ( 2 ) / 2 ) then G_red ( 2 ) = g2 - n_grid ( 2 ) - 1 end if if ( g3 . gt . n_grid ( 3 ) / 2 ) then G_red ( 3 ) = g3 - n_grid ( 3 ) - 1 end if sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) = matmul ( k_red_to_xyz , G_red ) end do end do end do end subroutine subroutine set_fft_plan_forward_3d ( n_grid , fft_plan ) !! sets the FFT plan for an array with dimensinos [ n_grid ] implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_FORWARD , FFTW_PATIENT ) end subroutine subroutine set_fft_plan_backward_3d ( n_grid , fft_plan ) !! sets the FFT plan for an array with dimensinos [ n_grid ] implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_BACKWARD , FFTW_PATIENT ) end subroutine subroutine G_red_to_FFT_G_grid_index ( n_grid , G_red , idx ) !! Given a G_red vector returns the index of that vector in the FFT !! grid. implicit none integer :: idx ( 3 ) integer :: G_red ( 3 ) integer :: n_grid ( 3 ) integer :: i idx = G_red + [ 1 , 1 , 1 ] ! put negative values at the back of the array in FFTW3 convention do i = 1 , 3 if ( G_red ( i ) . lt . 0 ) then idx ( i ) = G_red ( i ) + n_grid ( i ) + 1 end if end do end subroutine end module","tags":"","loc":"sourcefile/fft_util.f90.html"},{"title":"io_input.f90 – EXCEED-DM","text":"Contents Modules io_input Source Code io_input.f90 Source Code module io_input !! Input and output file names implicit none character ( len = 512 ) :: nml_input_filename = '' !! Namelist input filename, character ( len = 512 ) :: DFT_input_filename = '' !! DFT calculations input file character ( len = 64 ) :: run_description = '' !! description of the calculation character ( len = 512 ) :: out_folder = '.' !! Ouput folder character ( len = 512 ) :: out_filename = '' !! Output filename !! !! Setting this variable overrides the settings of out_folder !! and run_description character ( len = 512 ) :: sto_wf_filename = '' !! Input file specifying the Slater type orbital (sto) !! wave function coefficients for the core electron !! states character ( len = 512 ) :: core_elec_config_filename = '' !! File specifying the core electron configuration character ( len = 512 ) :: dielectric_filename = '' !! File specifying the dielectric function. If the dielectric !! will be computed this will be where the computed values are !! stored. If this file already exists, the dielectric function !! will be loaded from this file. NAMELIST / io / DFT_input_filename , & run_description , & out_folder , & out_filename , & sto_wf_filename , & core_elec_config_filename , & dielectric_filename contains subroutine print_io ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    ---' print * , '    I/O' print * , '    ---' print * print * , '        DFT input            : ' , trim ( DFT_input_filename ) print * , '        STO coefficients     : ' , trim ( sto_wf_filename ) print * , '        Core electron config : ' , trim ( core_elec_config_filename ) print * , '        Dielectric           : ' , trim ( dielectric_filename ) print * end if end subroutine subroutine load_io ( filename , verbose ) !! Loads the io namelist implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error if ( verbose ) then print * , 'Loading IO parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = io , iostat = error ) close ( 100 ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Problem reading IO namelist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if if ( trim ( out_filename ) . eq . '' ) then if ( trim ( run_description ) . eq . '' ) then out_filename = trim ( out_folder ) // '/EXDMout.hdf5' else out_filename = trim ( out_folder ) // '/EXDMout_' // trim ( run_description ) // '.hdf5' end if end if call print_io ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for IO parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine recursive subroutine create_output_file ( filename , overwrite_output , verbose ) !! Creates the output file use hdf5 use h5lt use prec implicit none character ( len =* ) :: filename character ( len = 512 ) :: new_filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer :: error logical :: overwrite_output real ( dp ) :: r character ( len = 64 ) :: rand_num_str if ( verbose ) then print * , 'Creating output file...' print * end if inquire ( file = filename , exist = file_exists ) if ( ( . not . file_exists ) . or . ( overwrite_output ) ) then call h5open_f ( error ) call h5fcreate_f ( trim ( filename ), H5F_ACC_TRUNC_F , file_id , error ) if ( ( error . ne . 0 ) . and . verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '   Could not create output file : ' , trim ( filename ) print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * stop end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '~~~ WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * print * , '   Output file : ' , trim ( filename ), ' already exists.' print * end if call random_number ( r ) write ( rand_num_str , * ) int ( 10 ** 3 * r ) out_filename = './EXDMout_' // trim ( adjustl ( rand_num_str )) // '.hdf5' if ( verbose ) then print * , '   Attempting to set output filename to : ' , trim ( out_filename ) print * print * , '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * end if call create_output_file ( trim ( out_filename ), . FALSE ., verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/io_input.f90.html"},{"title":"material_input.f90 – EXCEED-DM","text":"Contents Modules material_input Source Code material_input.f90 Source Code module material_input !! Information about the target material. use hdf5 use h5lt use prec use units implicit none character ( len = 64 ) :: mat_name = '' real ( dp ) :: pc_vol_A !! Volume of the unit cell !! !! pc_vol_A = det(a_vecs) !! !! Units : Ang&#94;3 real ( dp ) :: rho_T_g_per_cm3 !! Target density !! !! Units : g/cm&#94;3 real ( dp ) :: m_T_kg = 1.0_dp !! Target mass !! !! Units : kg real ( dp ) :: band_gap = 0.0_dp !! Band gap of the target !! !! Units : eV !! Generated from input real ( dp ) :: pc_vol !! Volume of the primitive cell !! !! Units : eV&#94;(-3) real ( dp ) :: rho_T !! Target density !! !! Units : eV&#94;4 real ( dp ) :: m_T !! Target mass !! !! Units : eV NAMELIST / material / pc_vol_A , & band_gap , & rho_T_g_per_cm3 , & m_T_kg , & mat_name contains subroutine print_material ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    --------' print * , '    Material' print * , '    --------' print * print * , '        Name      : ' , trim ( mat_name ) print * , '        Band gap  : ' , band_gap , ' eV' print * , '        Density   : ' , rho_T_g_per_cm3 , ' g/cm&#94;3' print * , '        PC volume : ' , pc_vol_A , ' Ang&#94;3' print * end if end subroutine subroutine load_material ( filename , verbose ) implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error if ( verbose ) then print * , 'Loading material parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = material , iostat = error ) close ( 100 ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Problem reading material namelist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if rho_T = g_to_eV * inv_cm_to_eV ** 3 * rho_T_g_per_cm3 m_T = kg_to_eV * m_T_kg pc_vol = Ang_to_inv_eV ** 3 * pc_vol_A call print_material ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for material parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_material ( filename , verbose ) !! Saves the material properties implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving material parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'material' , group_id , error ) ! ! write data call h5ltmake_dataset_string_f ( file_id , 'material/mat_name' ,& mat_name , error ) call h5ltmake_dataset_double_f ( file_id , 'material/band_gap' , size ( dims1 ), dims1 ,& band_gap , error ) call h5ltmake_dataset_double_f ( file_id , 'material/density' , size ( dims1 ), dims1 ,& rho_T_g_per_cm3 , error ) call h5ltmake_dataset_double_f ( file_id , 'material/target_mass' , size ( dims1 ), dims1 ,& m_T_kg , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/material_input.f90.html"},{"title":"transition.f90 – EXCEED-DM","text":"Contents Modules transition Source Code transition.f90 Source Code module transition !! Handles labelling of the transitions that each processor should compute !! for implicit none integer :: n_tran !! Total number of transitions !! !! = n_init*n_fin integer :: n_tran_per_proc !! Number of transitiosn each processor has to calculate integer , allocatable :: tran_to_init_fin_id (:, :) !! Dim : [n_tran, 2] !! !! Each transition (i, f) is given a unique index, and this !! is the map back. For each transition id return the initial !! or final state index integer , allocatable :: job_table (:, :) !! Dim : [n_proc, n_tran_per_proc] !! give each processor a list of transitions to compute for contains subroutine set_job_table ( n_proc , n_init , n_fin , verbose ) implicit none integer :: n_proc integer :: n_init , n_fin logical , optional :: verbose integer :: i , j , tran_id , id , f if ( verbose ) then print * , 'Configuring jobs for processors...' print * end if n_tran = n_init * n_fin allocate ( tran_to_init_fin_id ( n_tran , 2 )) id = 0 do i = 1 , n_init do f = 1 , n_fin id = id + 1 tran_to_init_fin_id ( id , 1 ) = i tran_to_init_fin_id ( id , 2 ) = f end do end do if ( mod ( n_tran , n_proc ) . eq . 0 ) then n_tran_per_proc = n_tran / n_proc else n_tran_per_proc = n_tran / n_proc + 1 end if allocate ( job_table ( n_proc , n_tran_per_proc )) tran_id = 0 do j = 1 , n_tran_per_proc do i = 1 , n_proc tran_id = tran_id + 1 if ( tran_id . gt . n_tran ) then job_table ( i , j ) = 0 else job_table ( i , j ) = tran_id end if end do end do if ( verbose ) then print * , '----------------------------------------' print * if ( mod ( n_tran , n_proc ) . eq . 0 ) then print * , '    Equal processor load.' print * else if ( n_tran_per_proc . eq . 1 ) then print * , '    Number of processors is greater than the number of i -> f' ,& '    transitions. Consider lowering the number of processors.' print * print * , '    Number of transitions = ' , n_tran print * else print * , '    Unequal processor load. Some processors will be given null jobs.' print * print * , '    Number of transitions = ' , n_tran print * end if print * , '    Number of calculations per processor = ' , n_tran_per_proc print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/transition.f90.html"},{"title":"absorption_input.f90 – EXCEED-DM","text":"Contents Modules absorption_input Source Code absorption_input.f90 Source Code module absorption_input !! Load parameters relevant for absorption calculations use hdf5 use h5lt use prec implicit none integer :: n_omega = 1 !! Number of omega/mass points to compute for real ( dp ) :: log_omega_min = - 2.0_dp real ( dp ) :: log_omega_max = 2.0_dp integer :: n_width_b = 1 integer :: n_width_a = 1 integer :: n_width_max = 0 integer :: n_widths !! n_width_a*n_width_b real ( dp ) :: width_a_min = 0.0_dp real ( dp ) :: width_a_max = 0.0_dp real ( dp ) :: log_width_b_min = - 6.0_dp real ( dp ) :: log_width_b_max = - 1.0_dp real ( dp ) :: width_max_min = 10 0.0_dp real ( dp ) :: width_max_max = 10 0.0_dp real ( dp ) :: sigma_gamma = 3 NAMELIST / absorption / n_omega , & log_omega_min , & log_omega_max , & n_width_a , & width_a_min , & width_a_max , & n_width_b , & log_width_b_min , & log_width_b_max , & n_width_max , & width_max_min , & width_max_max , & sigma_gamma !!! real ( dp ), allocatable :: omega_list (:) !! Dim : [n_omega] real ( dp ), allocatable :: delta_list (:, :) !! Dim : [n_omega, n_widths] real ( dp ), allocatable :: width_info (:, :) !! Dim : [n_widths, 2] !! !! Width parameters, [a, b] contains subroutine save_absorption_input ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving absorption input...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'abs_input' , group_id , error ) ! ! write data dims1 = [ n_omega ] call h5ltmake_dataset_double_f ( file_id , 'abs_input/omega_list' , size ( dims1 ), dims1 ,& omega_list , error ) ! dims2 = [n_omega, n_widths] ! call h5ltmake_dataset_double_f(file_id, 'abs_input/delta_list', size(dims1), dims1,& !     delta_list, error) dims2 = [ n_widths , 3 ] call h5ltmake_dataset_double_f ( file_id , 'abs_input/width_info' , size ( dims2 ), dims2 ,& width_info , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_absorption_input ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , 'Absorption parameters : ' print * print * , '   Number of omega            = ' , n_omega print * , '   Number of width parameters = ' , n_widths print * print * , '   Minimum omega = ' , minval ( omega_list ), 'eV' print * , '   Maximum omega = ' , maxval ( omega_list ), 'eV' print * print * , '----------' print * end if end subroutine subroutine load_absorption_input ( filename , verbose ) !! Load the absorption inputs implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error integer :: i , a , b , j , c real ( dp ) :: log_omega real ( dp ) :: a_param , b_param , width , width_max_param if ( verbose ) then print * , 'Loading absorption parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = absorption , iostat = error ) close ( 100 ) n_widths = n_width_a * n_width_b * ( n_width_max + 1 ) allocate ( omega_list ( n_omega )) omega_list = 1 0.0_dp ** log_omega_min allocate ( delta_list ( n_omega , n_widths )) delta_list = 0.0_dp allocate ( width_info ( n_widths , 3 )) width_info = 0.0_dp do i = 1 , n_omega log_omega = log_omega_min + ( log_omega_max - log_omega_min ) * & ( i - 1.0_dp ) / max ( 1.0_dp , n_omega - 1.0_dp ) omega_list ( i ) = 1 0.0_dp ** log_omega j = 1 do a = 1 , n_width_a a_param = width_a_min + ( width_a_max - width_a_min ) * ( a - 1.0_dp ) / & max ( 1.0_dp , n_width_a - 1.0_dp ) do b = 1 , n_width_b b_param = log_width_b_min + ( log_width_b_max - log_width_b_min ) * ( b - 1.0_dp ) / & max ( 1.0_dp , n_width_b - 1.0_dp ) do c = 1 , n_width_max + 1 if ( c == n_width_max + 1 ) then width_max_param = 1.0e3_dp else width_max_param = width_max_min + ( width_max_max - width_max_min ) * ( c - 1.0_dp ) / & max ( 1.0_dp , n_width_max - 1.0_dp ) end if if ( i == 1 ) then width_info ( j , 1 ) = a_param width_info ( j , 2 ) = 1 0.0_dp ** b_param width_info ( j , 3 ) = width_max_param end if delta_list ( i , j ) = min ( width_max_param , a_param + ( 1 0.0_dp ** b_param ) * omega_list ( i ) ) j = j + 1 end do end do end do end do call print_absorption_input ( verbose = verbose ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for absorption parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/absorption_input.f90.html"},{"title":"calc_PI.f90 – EXCEED-DM","text":"Contents Modules calc_PI Source Code calc_PI.f90 Source Code module calc_PI !! Computes self-energies needed for absorption calculations use mpi use hdf5 use h5lt use prec use constants use material_input use absorption_input use DFT_parameters use transition implicit none complex ( dp ), allocatable :: pi_vv (:, :) !! Dim : [n_omega, n_widths] !! !! self energy with two v&#94;2 insertions !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_11_mat (:, :, :, :) !! Dim : [3, 3, n_omega, n_widths] !! !! self energy, without q_vec's !! !! Pi_11 = (q/m_elec) . Pi_11_mat . (q/m_elec) !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_v1 (:, :, :) !! Dim : [3, n_omega, n_widths] !! !! self energy Pi_{v&#94;2, 1} !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_1v (:, :, :) !! Dim : [3, n_omega, n_widths] !! !! self energy Pi_{1, v&#94;2} = Pi_{v&#94;2, 1}&#94;*(-delta) !! !! Units : eV&#94;2 !real(dp), allocatable :: im_pi_vv(:, :) !    !! Dim : [n_omega, n_widths] !    !! !    !! imaginary part of self energy with two v&#94;2 insertions !    !! !    !! Units : None !real(dp), allocatable :: im_pi_11_mat(:, :, :, :) !    !! Dim : [3, 3, n_omega, n_widths] !    !! !    !! imaginary part of self energy (without q vectors) !    !! !    !! Units : eV&#94;(-2) complex ( dp ), allocatable :: pi_vv_t (:, :, :) !! Dim : [n_omega, n_widths, n_tran_per_proc] !! !! self energy with two v&#94;2 insertions !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_11_mat_t (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! self energy, without q_vec's !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_v1_t (:, :, :, :) !! Dim : [3, n_omega, n_widths, n_tran_per_proc] !! !! self energy Pi_{v&#94;2, 1} !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_1v_t (:, :, :, :) !! Dim : [3, n_omega, n_widths, n_tran_per_proc] !! !! self energy Pi_{1, v&#94;2} = Pi_{v&#94;2, 1}&#94;*(-delta) !! !! Units : eV&#94;2 !real(dp), allocatable :: im_pi_vv_t(:, :, :) !    !! Dim : [n_omega, n_widths, n_tran_per_proc] !    !! !    !! imaginary part of self energy with two v&#94;2 insertions !    !! !    !! Units : None !real(dp), allocatable :: im_pi_11_mat_t(:, :, :, :, :) !    !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !    !! !    !! imaginary part of self energy (without q vectors) !    !! !    !! Units : eV&#94;(-2) contains subroutine compute_self_energies ( nml_filename , tran_form , & tran_form_vec , omega_iipk , n_init , n_fin , n_k , n_proc , & proc_id , root_process , verbose ) implicit none character ( len =* ) :: nml_filename integer :: n_init , n_fin , n_k integer :: n_proc , proc_id , root_process integer :: t , init_id , fin_id , tran_id integer :: i complex ( dp ) :: tran_form ( n_init , n_fin , n_k ) complex ( dp ) :: tran_form_vec ( 3 , n_init , n_fin , n_k ) real ( dp ) :: omega_iipk ( n_init , n_fin , n_k ) complex ( dp ) :: tran_form_k ( n_k ) complex ( dp ) :: tran_form_vec_k ( 3 , n_k ) real ( dp ) :: omega_iipk_k ( n_k ) integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err logical , optional :: verbose if ( verbose ) then print * , 'Calculating self energies...' print * end if ! initialize variables allocate ( pi_vv_t ( n_omega , n_widths , n_tran_per_proc )) pi_vv_t = ( 0.0_dp , 0.0_dp ) allocate ( pi_11_mat_t ( 3 , 3 , n_omega , n_widths , n_tran_per_proc )) pi_11_mat_t = ( 0.0_dp , 0.0_dp ) allocate ( pi_1v_t ( 3 , n_omega , n_widths , n_tran_per_proc )) pi_1v_t = ( 0.0_dp , 0.0_dp ) allocate ( pi_v1_t ( 3 , n_omega , n_widths , n_tran_per_proc )) pi_v1_t = ( 0.0_dp , 0.0_dp ) ! allocate(im_pi_vv_t(n_omega, n_widths, n_tran_per_proc)) ! im_pi_vv_t = 0.0_dp ! allocate(im_pi_11_mat_t(3, 3, n_omega, n_widths, n_tran_per_proc)) ! im_pi_11_mat_t = 0.0_dp if ( proc_id == root_process ) then allocate ( pi_vv ( n_omega , n_widths )) pi_vv = ( 0.0_dp , 0.0_dp ) allocate ( pi_11_mat ( 3 , 3 , n_omega , n_widths )) pi_11_mat = ( 0.0_dp , 0.0_dp ) allocate ( pi_1v ( 3 , n_omega , n_widths )) pi_1v = ( 0.0_dp , 0.0_dp ) allocate ( pi_v1 ( 3 , n_omega , n_widths )) pi_v1 = ( 0.0_dp , 0.0_dp ) ! allocate(im_pi_vv(n_omega, n_widths)) ! im_pi_vv = 0.0_dp ! allocate(im_pi_11_mat(3, 3, n_omega, n_widths)) ! im_pi_11_mat = 0.0_dp end if ! each processor computes do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then init_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) tran_form_k = tran_form ( init_id , fin_id , :) tran_form_vec_k = tran_form_vec (:, init_id , fin_id , :) omega_iipk_k = omega_iipk ( init_id , fin_id , :) call calc_pi_vv ( pi_vv_t (:, :, t ), tran_form_k , omega_iipk_k ) call calc_pi_11_mat ( pi_11_mat_t (:, :, :, :, t ), tran_form_vec_k , & omega_iipk_k ) call calc_pi_1v ( pi_1v_t (:, :, :, t ), tran_form_k , tran_form_vec_k , & omega_iipk_k ) call calc_pi_v1 ( pi_v1_t (:, :, :, t ), tran_form_k , tran_form_vec_k , & omega_iipk_k ) ! call calc_im_pi_vv(im_pi_vv_t(:, :, t), tran_form_k, omega_iipk_k) ! call calc_im_pi_11_mat(im_pi_11_mat_t(:, :, :, :, t), tran_form_vec_k, & !     omega_iipk_k) end if end do ! sum together again if ( proc_id . ne . root_process ) then call MPI_SEND ( pi_vv_t , & size ( pi_vv_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( pi_11_mat_t , & size ( pi_11_mat_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( pi_1v_t , & size ( pi_1v_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( pi_v1_t , & size ( pi_v1_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) ! call MPI_SEND(im_pi_vv_t, & !    size(im_pi_vv_t), MPI_DOUBLE, root_process, tag, MPI_COMM_WORLD, err) ! call MPI_SEND(im_pi_11_mat_t, & !    size(im_pi_11_mat_t), MPI_DOUBLE, root_process, tag, MPI_COMM_WORLD, err) end if if ( proc_id . eq . root_process ) then ! add main processors contribution pi_vv = pi_vv + sum ( pi_vv_t , 3 ) pi_11_mat = pi_11_mat + sum ( pi_11_mat_t , 5 ) pi_1v = pi_1v + sum ( pi_1v_t , 4 ) pi_v1 = pi_v1 + sum ( pi_v1_t , 4 ) ! im_pi_vv = im_pi_vv + sum(im_pi_vv_t, 3) ! im_pi_11_mat = im_pi_11_mat + sum(im_pi_11_mat_t, 5) do i = 1 , n_proc if ( ( i - 1 ) . ne . root_process ) then call MPI_RECV ( pi_vv_t , & size ( pi_vv_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( pi_11_mat_t , & size ( pi_11_mat_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( pi_1v_t , & size ( pi_1v_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( pi_v1_t , & size ( pi_v1_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! call MPI_RECV(im_pi_vv_t, & !    size(im_pi_vv_t), MPI_DOUBLE, i - 1, MPI_ANY_TAG, MPI_COMM_WORLD, status, err) ! call MPI_RECV(im_pi_11_mat_t, & !    size(im_pi_11_mat_t), MPI_DOUBLE, i - 1, MPI_ANY_TAG, MPI_COMM_WORLD, status, err) ! add other processors contributions pi_vv = pi_vv + sum ( pi_vv_t , 3 ) pi_11_mat = pi_11_mat + sum ( pi_11_mat_t , 5 ) pi_1v = pi_1v + sum ( pi_1v_t , 4 ) pi_v1 = pi_v1 + sum ( pi_v1_t , 4 ) ! im_pi_vv = im_pi_vv + sum(im_pi_vv_t, 3) ! im_pi_11_mat = im_pi_11_mat + sum(im_pi_11_mat_t, 5) end if end do end if if ( verbose ) then print * , '----------' print * end if end subroutine subroutine save_self_energies ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer ( HSIZE_T ) :: dims3 ( 3 ) integer :: error integer :: m , f , t integer :: i , fin character ( len = 64 ) :: i_str , fin_str if ( verbose ) then print * , 'Saving self energies...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'self_energies' , group_id , error ) do i = 1 , n_widths write ( i_str , * ) i i_str = trim ( adjustl ( i_str )) call h5gcreate_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ),& group_id , error ) dims1 = [ n_omega ] call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_vv_r' , & size ( dims1 ), dims1 ,& real ( pi_vv (:, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_vv_c' , & size ( dims1 ), dims1 ,& aimag ( pi_vv (:, i )), error ) dims3 = [ 3 , 3 , n_omega ] call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_11_mat_r' , & size ( dims3 ), dims3 ,& real ( pi_11_mat (:, :, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_11_mat_c' , & size ( dims3 ), dims3 ,& aimag ( pi_11_mat (:, :, :, i )), error ) dims2 = [ 3 , n_omega ] call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_1v_r' , & size ( dims2 ), dims2 ,& real ( pi_1v (:, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_1v_c' , & size ( dims2 ), dims2 ,& aimag ( pi_1v (:, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_v1_r' , & size ( dims2 ), dims2 ,& real ( pi_v1 (:, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( i_str ) // & '/pi_v1_c' , & size ( dims2 ), dims2 ,& aimag ( pi_v1 (:, :, i )), error ) end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine ! subroutine calc_im_pi_11_mat(im_pi_11_mat, tran_form_vec_t, omega_iipk_t) !     implicit none !     real(dp) :: im_pi_11_mat(3, 3, n_omega, n_widths) !     complex(dp) :: outer_ff(3, 3, n_k) !     complex(dp) :: tran_form_vec_t(3, n_k) !     real(dp) :: omega_iipk_t(n_k) !     integer :: k, w, p, i, j !     real(dp) :: omega, width, omega_k !     do k = 1, n_k !         do i = 1, 3 !             do j = 1, 3 !                 outer_ff(i, j, k) = conjg(tran_form_vec_t(i, k))*tran_form_vec_t(j, k) !             end do !         end do !     end do !     do p = 1, n_widths !         do w = 1, n_omega !             omega = omega_list(w) !             width = delta_list(w, p) !             do k = 1, n_k !                 omega_k = omega_iipk_t(k) !                 ! im_pi_11_mat(:, :, w, p) = im_pi_11_mat(:, :, w, p) + & !                 !    (pc_vol)**(-1)*k_weight(k)*& !                 !    (4.0_dp*omega_k**2*width)*& !                 !    ( ( omega**2 - omega_k**2 )**2 + ( 2.0_dp*omega_k*width )**2 )**(-1)*& !                 !    outer_ff(:, :, k) !                 im_pi_11_mat(:, :, w, p) = im_pi_11_mat(:, :, w, p) + & !                    (pc_vol)**(-1)*k_weight(k)*& !                    (width)*& !                    (& !                     ( ( omega - omega_k )**2 + ( width )**2 )**(-1) + & !                     ( ( omega + omega_k )**2 + ( width )**2 )**(-1) & !                    )*& !                    outer_ff(:, :, k) !             end do !         end do !     end do ! end subroutine ! subroutine calc_im_pi_vv(im_pi_vv, tran_form_t, omega_iipk_t) !     implicit none !     real(dp) :: im_pi_vv(n_omega, n_widths) !     complex(dp) :: tran_form_t(n_k) !     real(dp) :: omega_iipk_t(n_k) !     integer :: k, w, p !     real(dp) :: omega, width, omega_k !     do p = 1, n_widths !         do w = 1, n_omega !             omega = omega_list(w) !             width = delta_list(w, p) !             print*, 'omega = ', omega !             print*, 'width = ', width !             do k = 1, n_k !                 omega_k = omega_iipk_t(k) !                 ! im_pi_vv(w, p) = im_pi_vv(w, p) - & !                 !    (pc_vol)**(-1)*k_weight(k)*& !                 !    (4.0_dp*omega_k**2*width)*& !                 !    ( ( omega**2 - omega_k**2 )**2 + ( 2.0_dp*omega_k*width )**2 )**(-1)*& !                 !    abs(tran_form_t(k))**2 !                 im_pi_vv(w, p) = im_pi_vv(w, p) - & !                    (pc_vol)**(-1)*k_weight(k)*& !                    (width)*& !                    (& !                     ( ( omega - omega_k )**2 + ( width )**2 )**(-1) + & !                     ( ( omega + omega_k )**2 + ( width )**2 )**(-1) & !                    )*& !                    abs(tran_form_t(k))**2 !             end do !         end do !     end do ! end subroutine subroutine calc_pi_vv ( pi_vv , tran_form_t , omega_iipk_t ) implicit none complex ( dp ) :: pi_vv ( n_omega , n_widths ) complex ( dp ) :: tran_form_t ( n_k ) real ( dp ) :: omega_iipk_t ( n_k ) integer :: k , w , p real ( dp ) :: omega , width , omega_k do p = 1 , n_widths do w = 1 , n_omega omega = omega_list ( w ) width = delta_list ( w , p ) do k = 1 , n_k omega_k = omega_iipk_t ( k ) if ( abs ( omega - omega_k ) < sigma_gamma * width ) then pi_vv ( w , p ) = pi_vv ( w , p ) + & ( pc_vol ) ** ( - 1 ) * k_weight ( k ) * & (& ( omega - omega_k + ii * width ) ** ( - 1 ) - & ( omega + omega_k - ii * width ) ** ( - 1 ) & ) * & abs ( tran_form_t ( k )) ** 2 * ( 1.0_dp / 2.0_dp ) ** 2 end if end do end do end do end subroutine subroutine calc_pi_11_mat ( pi_11_mat , tran_form_vec_t , omega_iipk_t ) implicit none complex ( dp ) :: pi_11_mat ( 3 , 3 , n_omega , n_widths ) complex ( dp ) :: outer_ff ( 3 , 3 , n_k ) complex ( dp ) :: tran_form_vec_t ( 3 , n_k ) real ( dp ) :: omega_iipk_t ( n_k ) integer :: k , w , p , i , j real ( dp ) :: omega , width , omega_k do k = 1 , n_k do i = 1 , 3 do j = 1 , 3 omega_k = omega_iipk_t ( k ) outer_ff ( i , j , k ) = ( m_elec / omega_k ) ** 2 * conjg ( tran_form_vec_t ( i , k )) * tran_form_vec_t ( j , k ) end do end do end do do p = 1 , n_widths do w = 1 , n_omega omega = omega_list ( w ) width = delta_list ( w , p ) do k = 1 , n_k omega_k = omega_iipk_t ( k ) if ( abs ( omega - omega_k ) < sigma_gamma * width ) then pi_11_mat (:, :, w , p ) = pi_11_mat (:, :, w , p ) + & ( pc_vol ) ** ( - 1 ) * k_weight ( k ) * & ( & ( omega - omega_k + ii * width ) ** ( - 1 ) - & ( omega + omega_k - ii * width ) ** ( - 1 ) & ) * & outer_ff (:, :, k ) end if end do end do end do end subroutine subroutine calc_pi_v1 ( pi_v1 , tran_form_t , tran_form_vec_t , omega_iipk_t ) implicit none complex ( dp ) :: pi_v1 ( 3 , n_omega , n_widths ) complex ( dp ) :: tran_form_t ( n_k ) complex ( dp ) :: tran_form_vec_t ( 3 , n_k ) real ( dp ) :: omega_iipk_t ( n_k ) integer :: k , w , p real ( dp ) :: omega , width , omega_k do p = 1 , n_widths do w = 1 , n_omega omega = omega_list ( w ) width = delta_list ( w , p ) do k = 1 , n_k omega_k = omega_iipk_t ( k ) if ( abs ( omega - omega_k ) < sigma_gamma * width ) then pi_v1 (:, w , p ) = pi_v1 (:, w , p ) + & ( pc_vol ) ** ( - 1 ) * k_weight ( k ) * & (& ( omega - omega_k + ii * width ) ** ( - 1 ) * & conjg ( tran_form_vec_t (:, k )) * tran_form_t ( k ) + & ( omega + omega_k - ii * width ) ** ( - 1 ) * & conjg ( tran_form_t ( k )) * tran_form_vec_t (:, k ) & ) * ( 1.0_dp / 2.0_dp ) * ( m_elec / omega_k ) end if end do end do end do end subroutine subroutine calc_pi_1v ( pi_1v , tran_form_t , tran_form_vec_t , omega_iipk_t ) implicit none complex ( dp ) :: pi_1v ( 3 , n_omega , n_widths ) complex ( dp ) :: tran_form_t ( n_k ) complex ( dp ) :: tran_form_vec_t ( 3 , n_k ) real ( dp ) :: omega_iipk_t ( n_k ) integer :: k , w , p real ( dp ) :: omega , width , omega_k do p = 1 , n_widths do w = 1 , n_omega omega = omega_list ( w ) width = delta_list ( w , p ) do k = 1 , n_k omega_k = omega_iipk_t ( k ) if ( abs ( omega - omega_k ) < sigma_gamma * width ) then pi_1v (:, w , p ) = pi_1v (:, w , p ) + & ( pc_vol ) ** ( - 1 ) * k_weight ( k ) * & (& ( omega - omega_k + ii * width ) ** ( - 1 ) * & conjg ( tran_form_t ( k )) * tran_form_vec_t (:, k ) + & ( omega + omega_k - ii * width ) ** ( - 1 ) * & conjg ( tran_form_vec_t (:, k )) * tran_form_t ( k )& ) * ( 1.0_dp / 2.0_dp ) * ( m_elec / omega_k ) end if end do end do end do end subroutine end module","tags":"","loc":"sourcefile/calc_pi.f90.html"},{"title":"dme_absorption.f90 – EXCEED-DM","text":"Contents Modules dme_absorption Source Code dme_absorption.f90 Source Code module dme_absorption !! Perform DM absorption rate calculations !! !! Note : currently specific to vc transitions use mpi use hdf5 use h5lt use prec use control_input use numerics_input use material_input use transition use DFT_parameters use particle_physics_abs use tran_form_calc use calc_PI use rate_calc_vector use rate_calc_ps use rate_calc_scalar implicit none !! building blocks of all absorption calculations complex ( dp ), allocatable :: tran_form (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Scalar transition form factor for absorption calculations !! !! = <f| (p/m_e)&#94;2 |i> !! !! Units : None complex ( dp ), allocatable :: tran_form_vec (:, :, :, :) !! Dim : [3, n_init, n_fin, n_k] !! !! Vector transition form factor for absorption calculations !! !! = <f| (p_vec/m_e)  |i> !! !! Units : None real ( dp ), allocatable :: omega_iipk (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Energy difference of the transition from i -> f at k !! !! Units : None complex ( dp ), allocatable :: tran_form_t (:, :) !! Dim : [n_tran_per_proc, n_k] !! !! Scalar transition form factor for absorption calculations !! !! Units : None complex ( dp ), allocatable :: tran_form_vec_t (:, :, :) !! Dim : [3, n_tran_per_proc, n_k] !! !! Vector transition form factor for absorption calculations !! !! Units : None real ( dp ), allocatable :: omega_iipk_t (:, :) !! Dim : [n_tran_per_proc, n_k] !! !! Energy difference of the transition from i -> f at k !! !! Units : None real ( dp ), allocatable :: abs_rate (:, :, :) !! Dim : [n_omega, n_widths, n_times] !! !! Absorption rate per kg-year !! !! Units : None contains subroutine run_dme_absorption ( proc_id , root_process , & out_filename , nml_filename , DFT_input_filename , & n_proc , verbose ) !! Absorption rate calculation implicit none integer :: proc_id integer :: root_process integer :: n_proc character ( len =* ) :: out_filename character ( len =* ) :: nml_filename character ( len =* ) :: DFT_input_filename logical , optional :: verbose integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: t , tran_id , val_id , cond_id , i complex ( dp ), allocatable :: wfc_FT_i (:, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) call load_numerics ( nml_filename , verbose = verbose ) call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) call load_absorption_input ( nml_filename , verbose = verbose ) call set_job_table ( n_proc , n_init , n_fin , verbose = verbose ) allocate ( tran_form_t ( n_tran_per_proc , n_k )) tran_form_t = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_vec_t ( 3 , n_tran_per_proc , n_k )) tran_form_vec_t = ( 0.0_dp , 0.0_dp ) allocate ( omega_iipk_t ( n_tran_per_proc , n_k )) omega_iipk_t = 0.0_dp ! these arrays are small enough for each processor to hold their ! own copy... allocate ( tran_form ( n_init , n_fin , n_k )) tran_form = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_vec ( 3 , n_init , n_fin , n_k )) tran_form_vec = ( 0.0_dp , 0.0_dp ) allocate ( omega_iipk ( n_init , n_fin , n_k )) omega_iipk = 0.0_dp allocate ( wfc_FT_i ( n_k , n_in_G )) allocate ( wfc_FT_f ( n_k , n_in_G )) ! compute tran_form data do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then val_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) call calc_tran_form ( tran_form_t ( t , :), tran_form_vec_t (:, t , :), & omega_iipk_t ( t , :), val_id , cond_id , wfc_FT_i , wfc_FT_f , verbose = verbose ) end if end do ! update the transition form factors if ( proc_id . ne . root_process ) then call MPI_SEND ( tran_form_t , & size ( tran_form_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_vec_t , & size ( tran_form_vec_t ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( omega_iipk_t , & size ( omega_iipk_t ), MPI_DOUBLE , root_process , tag , MPI_COMM_WORLD , err ) end if if ( proc_id == root_process ) then ! add main processors contribution call update_tran_form ( tran_form_t , tran_form_vec_t , omega_iipk_t , proc_id , verbose = verbose ) do i = 1 , n_proc if ( ( i - 1 ) . ne . root_process ) then call MPI_RECV ( tran_form_t , & size ( tran_form_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_vec_t , & size ( tran_form_vec_t ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( omega_iipk_t , & size ( omega_iipk_t ), MPI_DOUBLE , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! add other processors contributions call update_tran_form ( tran_form_t , tran_form_vec_t , omega_iipk_t , i - 1 , verbose = verbose ) end if end do end if ! save the transition form factors if ( proc_id == root_process ) then call save_numerics ( out_filename , verbose = verbose ) call save_DFT_parameters ( out_filename , verbose = verbose ) call save_absorption_input ( out_filename , verbose = verbose ) call save_tran_form ( out_filename , verbose = verbose ) end if ! send the full summed dataset back out to each processor if ( proc_id == root_process ) then do i = 1 , n_proc if ( ( i - 1 ) . ne . root_process ) then call MPI_SEND ( tran_form , & size ( tran_form ), MPI_DOUBLE_COMPLEX , i - 1 , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_vec , & size ( tran_form_vec ), MPI_DOUBLE_COMPLEX , i - 1 , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( omega_iipk , & size ( omega_iipk ), MPI_DOUBLE , i - 1 , tag , MPI_COMM_WORLD , err ) end if end do end if ! recv the full dataset from the main processor if ( proc_id /= root_process ) then call MPI_RECV ( tran_form , & size ( tran_form ), MPI_DOUBLE_COMPLEX , root_process , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_vec , & size ( tran_form_vec ), MPI_DOUBLE_COMPLEX , root_process , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( omega_iipk , & size ( omega_iipk ), MPI_DOUBLE , root_process , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) end if ! compute Pi's call compute_self_energies ( nml_filename , tran_form , & tran_form_vec , omega_iipk , n_init , n_fin , n_k , n_proc , & proc_id , root_process , verbose = verbose ) if ( proc_id == root_process ) then call save_self_energies ( out_filename , verbose = verbose ) end if if ( proc_id == root_process ) then call load_particle_physics_abs ( nml_filename , verbose = verbose ) ! compute rate for different models allocate ( abs_rate ( n_omega , n_widths , n_time )) abs_rate = 0.0_dp if ( trim ( calc_mode ) == 'vector' ) then call calc_rate_vector ( pi_11_mat , abs_rate , verbose = verbose ) else if ( trim ( calc_mode ) == 'ps' ) then call calc_rate_ps ( pi_11_mat , abs_rate , verbose = verbose ) else if ( trim ( calc_mode ) == 'scalar' ) then call calc_rate_scalar ( pi_11_mat , pi_1v , pi_v1 , pi_vv , abs_rate , & verbose = verbose ) end if call save_abs_rate ( out_filename , verbose = verbose ) end if end subroutine subroutine save_abs_rate ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: p , t integer :: i , fin character ( len = 64 ) :: t_str , p_str if ( verbose ) then print * , '    Saving absorption rate...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'abs_rate' , group_id , error ) do t = 1 , n_time write ( t_str , * ) t t_str = trim ( adjustl ( t_str )) call h5gcreate_f ( file_id ,& 'abs_rate' // & '/t_' // trim ( t_str ),& group_id , error ) do p = 1 , n_widths write ( p_str , * ) p p_str = trim ( adjustl ( p_str )) dims1 = [ n_omega ] call h5ltmake_dataset_double_f ( file_id ,& 'abs_rate' // & '/t_' // trim ( t_str ) // & '/width_' // trim ( p_str ),& size ( dims1 ), dims1 ,& abs_rate (:, p , t ), error ) end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_tran_form ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: m , f , t integer :: i , fin character ( len = 64 ) :: i_str , fin_str if ( verbose ) then print * , 'Saving absorption transition form factors...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'tran_form_data' , group_id , error ) do i = 1 , n_init write ( i_str , * ) i i_str = trim ( adjustl ( i_str )) call h5gcreate_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ),& group_id , error ) do fin = 1 , n_fin write ( fin_str , * ) fin fin_str = trim ( adjustl ( fin_str )) call h5gcreate_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ),& group_id , error ) dims1 = [ n_k ] call h5ltmake_dataset_double_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/tran_form_r' , & size ( dims1 ), dims1 ,& real ( tran_form ( i , fin , :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/tran_form_c' , & size ( dims1 ), dims1 ,& aimag ( tran_form ( i , fin , :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/omega_iip' , & size ( dims1 ), dims1 ,& omega_iipk ( i , fin , :), error ) dims2 = [ 3 , n_k ] call h5ltmake_dataset_double_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/tran_form_vec_r' , & size ( dims2 ), dims2 ,& real ( tran_form_vec (:, i , fin , :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'tran_form_data' // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/tran_form_vec_c' , & size ( dims2 ), dims2 ,& aimag ( tran_form_vec (:, i , fin , :)), error ) end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------' print * end if else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine subroutine update_tran_form ( tran_form_t , tran_form_vec_t , omega_iipk_t , proc_id , verbose ) implicit none complex ( dp ) :: tran_form_t ( n_tran_per_proc , n_k ) complex ( dp ) :: tran_form_vec_t ( 3 , n_tran_per_proc , n_k ) real ( dp ) :: omega_iipk_t ( n_tran_per_proc , n_k ) integer :: t , tran_id , init_id , fin_id , proc_id logical , optional :: verbose do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) init_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) if ( tran_id . ne . 0 ) then tran_form ( init_id , fin_id , :) = tran_form_t ( t , :) tran_form_vec (:, init_id , fin_id , :) = tran_form_vec_t (:, t , :) omega_iipk ( init_id , fin_id , :) = omega_iipk_t ( t , :) end if end do end subroutine end module","tags":"","loc":"sourcefile/dme_absorption.f90.html"},{"title":"particle_physics_abs.f90 – EXCEED-DM","text":"Contents Modules particle_physics_abs Source Code particle_physics_abs.f90 Source Code module particle_physics_abs !! Relevant particle physics parameters for an absorption !! calculation use prec use constants use units use math_mod implicit none real ( dp ) :: rhoX_GeV_per_cm3 = 0.4_dp !! Dark matter density !! !! Units : GeV/cm&#94;3 real ( dp ) :: v0_km_per_sec = 23 0.0_dp real ( dp ) :: vE_km_per_sec = 24 0.0_dp real ( dp ) :: vEsc_km_per_sec = 60 0.0_dp real ( dp ) :: thetaE = ( 4 2.0_dp / 18 0.0_dp ) * pi !rad !! Generated !!!!!!! real ( dp ) :: rhoX !! Dark matter density !! !! Units : eV&#94;4 real ( dp ) :: v0 real ( dp ) :: vE real ( dp ) :: vEsc real ( dp ) :: vel_dist_N0 integer :: n_v_mag , n_v_theta , n_v_phi integer :: n_time = 1 real ( dp ) :: time_day_min = 0.0_dp real ( dp ) :: time_day_max = 1.0_dp real ( dp ), allocatable :: time_of_day (:) real ( dp ), allocatable :: vE_vec_list (:, :) NAMELIST / particle_physics_a / v0_km_per_sec , & vE_km_per_sec , & vEsc_km_per_sec , & rhoX_GeV_per_cm3 , & thetaE , & n_time , & time_day_min , & time_day_max , & n_v_mag , & n_v_theta , & n_v_phi contains subroutine print_particle_physics_abs ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , 'Dark Matter properties' print * print * , '   Velocity distribution parameters : ' print * , '       v0   = ' , v0_km_per_sec , ' km/sec' print * , '       vE   = ' , vE_km_per_sec , ' km/sec' print * , '       vEsc = ' , vEsc_km_per_sec , ' km/sec' print * print * , '   Velocity integral parameters : ' print * , '       n_v_mag = ' , n_v_mag print * , '       n_v_theta = ' , n_v_theta print * , '       n_v_phi = ' , n_v_phi print * print * , '   Times : ' , time_of_day (:) print * print * , '----------' print * end if end subroutine subroutine load_particle_physics_abs ( filename , verbose ) implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error integer :: t inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = particle_physics_a , iostat = error ) close ( 100 ) rhoX = inv_cm_to_eV ** 3 * 1.0e9_dp * rhoX_GeV_per_cm3 v0 = km_per_sec_to_none * v0_km_per_sec vE = km_per_sec_to_none * vE_km_per_sec vEsc = km_per_sec_to_none * vEsc_km_per_sec allocate ( time_of_day ( n_time )) allocate ( vE_vec_list ( n_time , 3 )) do t = 1 , n_time time_of_day ( t ) = time_day_min + ( time_day_max - time_day_min ) * & ( t - 1.0_dp ) / ( max ( 1 , n_time - 1 )) vE_vec_list ( t , 1 ) = vE * sin ( thetaE ) * sin ( 2.0_dp * PI * time_of_day ( t )) vE_vec_list ( t , 2 ) = vE * cos ( thetaE ) * sin ( thetaE ) * ( cos ( 2.0_dp * pi * time_of_day ( t )) - 1 ) vE_vec_list ( t , 3 ) = vE * (( sin ( thetaE ) ** 2 ) * cos ( 2.0_dp * pi * time_of_day ( t )) & + cos ( thetaE ) ** 2 ) end do call print_particle_physics_abs ( verbose = verbose ) vel_dist_N0 = ( pi * v0 ** 3 ) * ( sqrt ( pi ) * erf ( vEsc / v0 ) - 2 * ( vEsc / v0 ) * exp ( - ( vEsc / v0 ) ** 2 )) call check_mb_dist_normalization ( n_v_mag , n_v_theta , n_v_phi , & boost_vec_in = vE * [ 0 , 0 , 1 ], verbose = verbose ) else if ( verbose ) then print * , '!! ERROR !!' print * print * , '   Input file for particle physics (absorption) parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!' print * end if stop end if end subroutine function mb_vel_distribution ( v_vec , boost_vec_in ) result ( mb_val ) !! Maxwell boltzmann distribution, boosted with boost_vec implicit none real ( dp ) :: v_vec ( 3 ) real ( dp ) :: v_mag real ( dp ), optional :: boost_vec_in ( 3 ) real ( dp ) :: boost_vec ( 3 ) real ( dp ) :: mb_val real ( dp ) :: v_p ( 3 ), v_p_mag ! boost the distribution if ( present ( boost_vec_in ) ) then boost_vec = boost_vec_in else boost_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if v_p = v_vec + boost_vec v_p_mag = norm2 ( v_p ) if ( v_p_mag < vEsc ) then mb_val = ( vel_dist_N0 ) ** ( - 1 ) * exp ( - ( v_p_mag / v0 ) ** 2 ) else mb_val = 0.0_dp end if end function subroutine check_mb_dist_normalization ( n_v_mag , n_v_theta , n_v_phi , boost_vec_in , verbose ) !! make sure the mb distribution integrates to 1 !! !! good indicator of whether the mesh is large enough to integrate over implicit none integer :: v , t , p integer :: n_v_mag , n_v_theta , n_v_phi real ( dp ) :: v_mag_list ( n_v_mag ) real ( dp ) :: v_angular_mesh ( n_v_theta * n_v_phi , 2 ) real ( dp ) :: int_val real ( dp ), optional :: boost_vec_in ( 3 ) real ( dp ) :: boost_vec ( 3 ) real ( dp ) :: v_vec ( 3 ) real ( dp ) :: v_mag , v_theta , v_phi real ( dp ) :: v_max logical , optional :: verbose if ( present ( boost_vec_in ) ) then boost_vec = boost_vec_in else boost_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if v_angular_mesh = generate_uniform_points_on_sphere ( n_v_theta , n_v_phi ) v_max = vEsc + norm2 ( boost_vec ) do v = 1 , n_v_mag v_mag_list ( v ) = v_max * ( v - 1.0_dp ) / max ( 1.0_dp , n_v_mag - 1.0_dp ) end do int_val = 0.0_dp do v = 1 , n_v_mag do t = 1 , n_v_theta * n_v_phi v_mag = v_mag_list ( v ) v_theta = v_angular_mesh ( t , 1 ) v_phi = v_angular_mesh ( t , 2 ) v_vec ( 1 ) = v_mag * sin ( v_theta ) * cos ( v_phi ) v_vec ( 2 ) = v_mag * sin ( v_theta ) * sin ( v_phi ) v_vec ( 3 ) = v_mag * cos ( v_theta ) int_val = int_val + v_mag ** 2 * ( 4.0_dp * pi * v_max ) * ( 1.0_dp * n_v_mag * n_v_theta * n_v_phi ) ** ( - 1 ) * & mb_vel_distribution ( v_vec , boost_vec_in = boost_vec ) end do end do if ( verbose ) then print * , '    Integral of MB velocity distrubution : ' , int_val print * end if end subroutine end module","tags":"","loc":"sourcefile/particle_physics_abs.f90.html"},{"title":"tran_form_calc.f90 – EXCEED-DM","text":"Contents Modules tran_form_calc Source Code tran_form_calc.f90 Source Code module tran_form_calc !! Compute the transition form factors use prec use constants use DFT_parameters implicit none contains subroutine calc_tran_form ( tran_form , tran_form_vec , omega_k , & val_id , cond_id , wfc_FT_i , wfc_FT_f , verbose ) implicit none complex ( dp ) :: tran_form ( n_k ) complex ( dp ) :: tran_form_vec ( 3 , n_k ) real ( dp ) :: omega_k ( n_k ) integer :: val_id , cond_id complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G ) logical , optional :: verbose integer :: k , g real ( dp ) :: p_vec ( 3 ) real ( dp ) :: p_sq tran_form = ( 0.0_dp , 0.0_dp ) tran_form_vec = ( 0.0_dp , 0.0_dp ) omega_k = 0.0_dp do k = 1 , n_k omega_k ( k ) = energy_bands ( k , cond_id ) - energy_bands ( k , val_id ) do g = 1 , n_in_G p_vec = k_grid_xyz ( k , :) + in_G_grid_xyz ( g , :) p_sq = dot_product ( p_vec , p_vec ) tran_form ( k ) = tran_form ( k ) + & ( p_sq / m_elec ** 2 ) * conjg ( wfc_FT_f ( k , g )) * wfc_FT_i ( k , g ) tran_form_vec (:, k ) = tran_form_vec (:, k ) + & ( p_vec / m_elec ) * conjg ( wfc_FT_f ( k , g )) * wfc_FT_i ( k , g ) end do end do end subroutine end module","tags":"","loc":"sourcefile/tran_form_calc.f90.html"},{"title":"rate_calc_ps.f90 – EXCEED-DM","text":"Contents Modules rate_calc_ps Source Code rate_calc_ps.f90 Source Code module rate_calc_ps !! Given the self energies, compute the absorption rate of !! pseudoscalar DM use prec use constants use particle_physics_abs use absorption_input use material_input implicit none contains subroutine calc_rate_ps ( pi_11_mat , abs_rate , verbose ) implicit none complex ( dp ) :: pi_11_mat ( 3 , 3 , n_omega , n_widths ) real ( dp ) :: abs_rate ( n_omega , n_widths , n_time ) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_angular_mesh ( n_v_theta * n_v_phi , 2 ) real ( dp ) :: v_mag , v_theta , v_phi , v_max real ( dp ) :: v_mag_list ( n_v_mag ) real ( dp ) :: v_vec ( 3 ) real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val v_max = vEsc + vE do v = 1 , n_v_mag v_mag_list ( v ) = v_max * ( v - 1.0_dp ) / max ( 1.0_dp , n_v_mag - 1.0_dp ) end do v_angular_mesh = generate_uniform_points_on_sphere ( n_v_theta , n_v_phi ) do w = 1 , n_omega omega = omega_list ( w ) do p = 1 , n_widths do t = 1 , n_time ve_vec = vE_vec_list ( t , :) av_rate = 0.0_dp ! velocity integral do v = 1 , n_v_mag do a = 1 , n_v_theta * n_v_phi v_mag = v_mag_list ( v ) v_theta = v_angular_mesh ( a , 1 ) v_phi = v_angular_mesh ( a , 2 ) v_vec ( 1 ) = v_mag * sin ( v_theta ) * cos ( v_phi ) v_vec ( 2 ) = v_mag * sin ( v_theta ) * sin ( v_phi ) v_vec ( 3 ) = v_mag * cos ( v_theta ) q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then pi_c = aimag ( dot_product ( q_vec / m_elec , matmul ( pi_11_mat (:, :, w , p ), q_vec / m_elec ) )) gam = - ( omega ) ** ( - 1 ) * ( 3.0_dp * omega ** 4 ) * & ( 4.0_dp * m_elec ** 2 * q_mag ** 2 ) ** ( - 1 ) * & pi_c rate = ( rhoX / rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * v_max ) * ( 1.0_dp * n_v_mag * n_v_theta * n_v_phi ) ** ( - 1 ) * & rate * mb_val end if end do end do ! pi_c = m_elec**(-2)*(1/3.0_dp)*aimag(pi_11_mat(1, 1, w, p) + pi_11_mat(2, 2, w, p) + pi_11_mat(3, 3, w, p)) ! gam = -(omega)**(-1)*(3.0_dp*omega**4)*& !     ( 4.0_dp*m_elec**2 )**(-1)*& !     pi_c ! rate = (rhoX/rho_T)*(omega)**(-1)*gam ! av_rate = rate abs_rate ( w , p , t ) = av_rate end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_ps.f90.html"},{"title":"rate_calc_scalar.f90 – EXCEED-DM","text":"Contents Modules rate_calc_scalar Source Code rate_calc_scalar.f90 Source Code module rate_calc_scalar !! Given the self energies, compute the absorption rate of !! scalar DM use prec use constants use particle_physics_abs use absorption_input use material_input implicit none contains subroutine calc_rate_scalar ( pi_11_mat , pi_1v , pi_v1 , pi_vv , abs_rate , verbose ) implicit none complex ( dp ) :: pi_11_mat ( 3 , 3 , n_omega , n_widths ) complex ( dp ) :: pi_1v ( 3 , n_omega , n_widths ) complex ( dp ) :: pi_v1 ( 3 , n_omega , n_widths ) complex ( dp ) :: pi_vv ( n_omega , n_widths ) real ( dp ) :: abs_rate ( n_omega , n_widths , n_time ) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_angular_mesh ( n_v_theta * n_v_phi , 2 ) real ( dp ) :: v_mag , v_theta , v_phi , v_max real ( dp ) :: v_mag_list ( n_v_mag ) real ( dp ) :: v_vec ( 3 ) real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: pi_11 real ( dp ) :: pi_1v_val , pi_v1_val real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val v_max = vEsc + vE do v = 1 , n_v_mag v_mag_list ( v ) = v_max * ( v - 1.0_dp ) / max ( 1.0_dp , n_v_mag - 1.0_dp ) end do v_angular_mesh = generate_uniform_points_on_sphere ( n_v_theta , n_v_phi ) do w = 1 , n_omega omega = omega_list ( w ) do p = 1 , n_widths do t = 1 , n_time ve_vec = vE_vec_list ( t , :) av_rate = 0.0_dp ! velocity integral do v = 1 , n_v_mag do a = 1 , n_v_theta * n_v_phi v_mag = v_mag_list ( v ) v_theta = v_angular_mesh ( a , 1 ) v_phi = v_angular_mesh ( a , 2 ) v_vec ( 1 ) = v_mag * sin ( v_theta ) * cos ( v_phi ) v_vec ( 2 ) = v_mag * sin ( v_theta ) * sin ( v_phi ) v_vec ( 3 ) = v_mag * cos ( v_theta ) q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then pi_11 = dot_product ( q_vec / m_elec , matmul ( pi_11_mat (:, :, w , p ), q_vec / m_elec ) ) pi_1v_val = dot_product ( q_vec / m_elec , pi_1v (:, w , p ) ) pi_v1_val = dot_product ( q_vec / m_elec , pi_v1 (:, w , p ) ) gam = - ( omega ) ** ( - 1 ) * aimag (& pi_vv ( w , p ) + & ( e_EM ) ** ( - 2 ) * ( q_mag ** 2 - e_EM ** 2 * pi_v1_val ) * & ( q_mag ** 2 - e_EM ** 2 * pi_1v_val ) * & ( q_mag ** 2 - e_EM ** 2 * pi_11 ) ** ( - 1 )& ) rate = ( rhoX / rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * v_max ) * ( 1.0_dp * n_v_mag * n_v_theta * n_v_phi ) ** ( - 1 ) * & rate * mb_val end if end do end do abs_rate ( w , p , t ) = av_rate end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_scalar.f90.html"},{"title":"rate_calc_vector.f90 – EXCEED-DM","text":"Contents Modules rate_calc_vector Source Code rate_calc_vector.f90 Source Code module rate_calc_vector !! Given the self energies, compute the absorption rate of vector DM use prec use constants use particle_physics_abs use absorption_input use material_input implicit none contains subroutine calc_rate_vector ( pi_11_mat , abs_rate , verbose ) implicit none complex ( dp ) :: pi_11_mat ( 3 , 3 , n_omega , n_widths ) real ( dp ) :: abs_rate ( n_omega , n_widths , n_time ) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_angular_mesh ( n_v_theta * n_v_phi , 2 ) real ( dp ) :: v_mag , v_theta , v_phi , v_max real ( dp ) :: v_mag_list ( n_v_mag ) real ( dp ) :: v_vec ( 3 ) real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val v_max = vEsc + vE do v = 1 , n_v_mag v_mag_list ( v ) = v_max * ( v - 1.0_dp ) / max ( 1.0_dp , n_v_mag - 1.0_dp ) end do v_angular_mesh = generate_uniform_points_on_sphere ( n_v_theta , n_v_phi ) do w = 1 , n_omega omega = omega_list ( w ) do p = 1 , n_widths do t = 1 , n_time ve_vec = vE_vec_list ( t , :) av_rate = 0.0_dp ! velocity integral do v = 1 , n_v_mag do a = 1 , n_v_theta * n_v_phi v_mag = v_mag_list ( v ) v_theta = v_angular_mesh ( a , 1 ) v_phi = v_angular_mesh ( a , 2 ) v_vec ( 1 ) = v_mag * sin ( v_theta ) * cos ( v_phi ) v_vec ( 2 ) = v_mag * sin ( v_theta ) * sin ( v_phi ) v_vec ( 3 ) = v_mag * cos ( v_theta ) q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then pi_r = real ( dot_product ( q_vec / m_elec , matmul ( pi_11_mat (:, :, w , p ), q_vec / m_elec ) )) pi_c = aimag ( dot_product ( q_vec / m_elec , matmul ( pi_11_mat (:, :, w , p ), q_vec / m_elec ) )) gam = - ( omega ) ** ( - 1 ) * ( q_mag ** 2 * omega ** 2 ) * & ( ( q_mag ** 2 - e_EM ** 2 * pi_r ) ** 2 + ( e_EM ** 2 * pi_c ) ** 2 ) ** ( - 1 ) * & pi_c rate = ( rhoX / rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * v_max ) * ( 1.0_dp * n_v_mag * n_v_theta * n_v_phi ) ** ( - 1 ) * & rate * mb_val end if end do end do abs_rate ( w , p , t ) = av_rate end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_vector.f90.html"},{"title":"constants.f90 – EXCEED-DM","text":"Contents Modules constants Source Code constants.f90 Source Code module constants !! Collection of useful constants use prec implicit none real ( dp ), parameter :: m_elec = 51 1.0e3_dp !! Electron mass !! !! Units : eV real ( dp ), parameter :: alpha_EM = 1.0_dp / 13 7.0_dp !! Fine structure constant real ( dp ), parameter :: a0 = 2.681336e-4_dp !! Bohr radius !! !! Units : eV&#94;(-1) real ( dp ), parameter :: pi = 4.0_dp * atan ( 1.0_dp ) complex ( dp ), parameter :: ii = ( 0.0_dp , 1.0_dp ) !! Imaginary unit real ( dp ), parameter :: e_EM = sqrt ( 4 * pi * alpha_EM ) !! Unit of electric charge end module","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"math_mod.f90 – EXCEED-DM","text":"Contents Modules math_mod Source Code math_mod.f90 Source Code module math_mod !! A collection of useful math functions use prec use special_functions use constants implicit none contains function pauli_spin_matrix ( i ) result ( mat ) !! Returns the ith Pauli spin matrix. Assume 0th Pauli matrix is the identity implicit none integer :: i complex ( dp ) :: mat ( 2 , 2 ) mat = ( 0.0_dp , 0.0_dp ) select case ( i ) case ( 0 ) mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 1.0_dp , 0.0_dp ) case ( 1 ) mat ( 1 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 1.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 0.0_dp , 0.0_dp ) case ( 2 ) mat ( 1 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 1 , 2 ) = - ii mat ( 2 , 1 ) = ii mat ( 2 , 2 ) = ( 0.0_dp , 0.0_dp ) case ( 3 ) mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( - 1.0_dp , 0.0_dp ) case default mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 1.0_dp , 0.0_dp ) end select end function function integrate_power_law ( b , x1 , x2 , x_s ) result ( integral ) !! !! = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy !! = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) !! !! The reason this function is non-trivial is because evaluating x**(b + 1) !! when b is large can be problematic. implicit none real ( dp ) :: b real ( dp ) :: x1 , x2 , x_s real ( dp ) :: integral real ( dp ) :: eps eps = 1.0e-8_dp if ( abs ( b + 1.0_dp ) < eps ) then integral = x_s * log ( x2 / x1 ) else integral = ( b + 1.0_dp ) ** ( - 1 ) * x1 * exp ( b * log ( x1 / x_s ) ) * & ( exp ( ( b + 1.0_dp ) * log ( x2 / x1 ) ) - 1.0_dp ) end if end function function power_law_fit ( log_x_pts , log_y_pts ) result ( fit_params ) !! Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x !! !! fit_params = [a, b] implicit none real ( dp ) :: log_x_pts ( 2 ) real ( dp ) :: log_y_pts ( 2 ) real ( dp ) :: fit_params real ( dp ) :: b if ( log_x_pts ( 2 ) > log_x_pts ( 1 ) ) then fit_params = ( log_y_pts ( 2 ) - log_y_pts ( 1 )) / ( log_x_pts ( 2 ) - log_x_pts ( 1 )) else print * , 'ERROR' end if end function function generate_uniform_points_on_sphere ( n_theta , n_phi ) result ( angular_mesh ) !! Generates an (n_thata*n_phi, 2) list of points which are uniformly !! distributed on the sphere implicit none integer :: n_theta , n_phi real ( dp ) :: angular_mesh ( n_theta * n_phi , 2 ) integer :: t , p , i real ( dp ) :: theta , phi i = 1 do t = 1 , n_theta do p = 1 , n_phi theta = acos (& 2.0_dp * (( t - 1.0_dp ) / max ( 1.0_dp , n_theta - 1.0_dp )) - 1.0_dp & ) phi = 2.0_dp * pi * ( p - 1.0_dp ) / ( max ( n_phi - 1.0_dp , 1.0_dp )) angular_mesh ( i , :) = [ theta , phi ] i = i + 1 end do end do end function function Q_func ( x , a , b , Q_max ) result ( Q ) !! Places x in an appropriate bin !! !! Q = min(Q_max, 1 + floor((x - a)/b)) implicit none integer :: Q , Q_max real ( dp ) :: x , a , b Q = min ( Q_max , 1 + floor (( x - a ) / b ) ) end function function factorial ( n ) result ( fact ) implicit none integer :: n , fact , i fact = 1 if ( n . gt . 1 ) then do i = 1 , n fact = fact * i end do end if end function recursive function sph_harmonic ( l , m , theta , phi ) result ( y_lm ) !! Spherical harmonic function with phase convention identical !! to Mathematica implicit none integer :: l , m real ( dp ) :: theta , phi , c_theta real ( dp ) :: legendre_pol real ( dp ) :: norm complex ( dp ) :: y_lm if ( m < 0 ) then y_lm = ( - 1 ) ** m * conjg ( sph_harmonic ( l , - m , theta , phi )) else c_theta = cos ( theta ) norm = sqrt (( 2 * l + 1 ) * factorial ( l - m ) / ( 4.0_dp * pi * factorial ( l + m ))) call lpmv ( 1.0_dp * l , m , c_theta , legendre_pol ) y_lm = norm * exp ( ii * m * phi ) * legendre_pol end if end function function get_phi ( n_hat ) result ( phi ) !! returns the theta value of a unit direction vector, n_hat implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: phi phi = atan2 ( n_hat ( 2 ), n_hat ( 1 )) if ( phi . lt . 0.0_dp ) then phi = phi + 2.0_dp * pi end if end function function get_theta ( n_hat ) result ( theta ) !! returns the theta value of a unit direction vector, n_hat implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: theta theta = acos ( n_hat ( 3 )) end function end module","tags":"","loc":"sourcefile/math_mod.f90.html"},{"title":"prec.f90 – EXCEED-DM","text":"Contents Modules prec Source Code prec.f90 Source Code module prec !! Precision definitions use , intrinsic :: iso_fortran_env , only : dp => real64 !! double precision (dp) definition end module","tags":"","loc":"sourcefile/prec.f90.html"},{"title":"timing.f90 – EXCEED-DM","text":"Contents Modules timing Source Code timing.f90 Source Code module timing !! Useful functions for timing a program use prec implicit none real ( dp ) :: time ( 100 ) !! holds raw timing variables real ( dp ) :: delta_t ( 100 ) !! holds difference in timing variables contains function pretty_time_format ( t ) result ( time_str ) !! Fills time_str with a nicely formatted version of time implicit none real ( dp ) :: t integer :: time_hr integer :: time_min integer :: time_sec character ( len = 512 ) :: time_str if ( t . lt . 1.0_dp ) then write ( time_str , * ) t * 10 ** 3 , 'ms' else time_hr = floor ( t / 360 0.0_dp ) time_min = floor (( t - time_hr * 360 0.0_dp ) / 6 0.0_dp ) time_sec = nint ( t - time_hr * 360 0.0_dp - time_min * 6 0.0_dp ) write ( time_str , * ) time_hr , 'hr ' , time_min , 'min' , time_sec , 's' end if end function end module","tags":"","loc":"sourcefile/timing.f90.html"},{"title":"units.f90 – EXCEED-DM","text":"Contents Modules units Source Code units.f90 Source Code module units !! Unit conversion factors !! !! If a variable has units of x to convert to units y: !! !! var_y = x_to_y * var_x use prec implicit none real ( dp ) :: inv_Ang_to_eV = 197 3.37_dp real ( dp ) :: inv_eV_to_cm = 1.97327e-5_dp real ( dp ) :: Ang_to_inv_eV = 5.068e-4_dp real ( dp ) :: g_to_eV = 5.61e32_dp real ( dp ) :: kg_to_eV = 5.61e35_dp real ( dp ) :: inv_cm_to_eV = 1.97327e-5_dp real ( dp ) :: km_per_sec_to_none = 3.33563e-6_dp end module","tags":"","loc":"sourcefile/units.f90.html"},{"title":"calc_dielectric.f90 – EXCEED-DM","text":"Contents Modules calc_dielectric Source Code calc_dielectric.f90 Source Code module calc_dielectric !! Compute the dielectric tensor from Pi_11 from valence -> conduction transitions. use mpi use hdf5 use h5lt use prec use constants use math_mod use material_input use DFT_parameters use FFT_util use io_input use transition_form_factor use di_transition use dielectric_input use di_grid implicit none complex ( dp ), allocatable :: dielec (:, :, :, :) !! Dim : [ n_omega_bins + 1, n_q_bins + 1, n_q_theta_bins + 1, n_q_phi_bins + 1 ] !! !! eps(omega, q) = 1 - \\frac{e&#94;2}{q&#94;2} Pi_11(q, omega) !! !! Pi_11 = (1/V) sum_{II'} \\frac{1}{omega - omega_{I'} - omega_{I} + i delta} !!      |<I'| e&#94;{i q x} |I>|&#94;2 !! !! Units : None complex ( dp ), allocatable :: dielec_t (:, :, :, :, :) !! Dim : [ n_tran_per_proc, n_omega_bins + 1, n_q_bins + 1, n_q_theta_bins + 1, n_q_phi_bins + 1 ] !! !! Each processors contribution to the dielectric !! !! Units : None contains subroutine check_dielectric_memory ( verbose ) !! Checks to see if the dielectric is going to take up too !! much memory. implicit none logical , optional :: verbose if ( 1 6.0_dp * ( di_n_q_bins ) * & ( di_n_q_phi_bins ) * & ( di_n_q_theta_bins ) * & ( di_n_omega_bins ) * & ( di_n_tran_per_proc ) >= 1.0e10_dp ) then if ( verbose ) then print * , '~~~ WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * print * , '    Attempting to store more than 10 GB of dielectric data on a single processor.' print * , '    Try increasing the number of processors or decreasing the number ' print * , '    of energy/momentum bins in the dielectric namelist.' print * print * , '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * end if end if end subroutine subroutine run_dielectric_calc ( nml_filename , filename , DFT_input_filename ,& proc_id , root_process , n_proc , verbose ) !! Compute the dielectric binned in energy and momentum transfer. implicit none character ( len =* ) :: filename character ( len =* ) :: nml_filename character ( len =* ) :: DFT_input_filename logical , optional :: verbose integer :: proc_id , root_process integer :: n_proc integer :: tran_id integer :: val_id , cond_id integer :: n_FFT_grid ( 3 ) integer :: n_FFT integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) complex ( dp ), allocatable :: wfc_FT_i (:, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) integer :: t , i integer :: n_q_grid ( 3 ) real ( dp ) :: q_grid_min ( 3 ) integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err if ( verbose ) then print * , 'Starting dielectric calculation...' print * end if !! load inputs ! call load_dielectric_input(nml_filename, verbose = verbose) call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) call di_set_job_table ( n_proc , di_n_init , di_n_fin , verbose = verbose ) ! doubled to avoid wrapping problems n_FFT_grid ( 1 ) = 2 * ( maxval ( in_G_grid_red (:, 1 )) - minval ( in_G_grid_red (:, 1 ))) + 1 n_FFT_grid ( 2 ) = 2 * ( maxval ( in_G_grid_red (:, 2 )) - minval ( in_G_grid_red (:, 2 ))) + 1 n_FFT_grid ( 3 ) = 2 * ( maxval ( in_G_grid_red (:, 3 )) - minval ( in_G_grid_red (:, 3 ))) + 1 n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) if ( verbose ) then print * , '----------------------------------------' print * , '    --------------' print * , '    Dielectric FFT' print * , '    --------------' print * print * , '        Dimensions of FFT grid : ' print * , '        ' , n_FFT_grid print * print * , '        Number of G points in FFT grid = ' , n_FFT print * print * , '----------------------------------------' print * end if call set_fft_plan_backward_3d ( n_FFT_grid , wfc_fft_plan ) call set_fft_plan_backward_3d ( n_FFT_grid , Tif_fft_plan ) call define_q_grid ( di_q_bin_width * di_n_q_bins , & k_red_to_xyz , n_q_grid , q_grid_min , n_k_vec , n_FFT_grid , verbose = . TRUE .) if ( verbose ) then print * , 'n_q_grid = ' , n_q_grid print * , 'q_grid_min = ' , q_grid_min end if !! Don't need this here, get G vector from function in FFT_util. !! Less than ideal because we don't precompute the G vectors, but !! we avoid reallocating the array in FFT_util twice. ! call set_sym_FFT_G_grid_xyz(n_FFT_grid, k_red_to_xyz, verbose = verbose) !! time calculation? if ( . not . load_dielectric_from_file ) then !! hard part of calculation starts here call check_dielectric_memory ( verbose = verbose ) !! allocate memory if ( proc_id == root_process ) then allocate ( dielec ( di_n_omega_bins , di_n_q_bins , & di_n_q_theta_bins , di_n_q_phi_bins )) !! factor of 1 in the dielectric formula dielec = ( 1.0_dp , 0.0_dp ) end if !! initialize variables allocate ( dielec_t ( di_n_tran_per_proc , di_n_omega_bins , di_n_q_bins , & di_n_q_theta_bins , di_n_q_phi_bins )) dielec_t = ( 0.0_dp , 0.0_dp ) allocate ( wfc_FT_i ( n_k , n_in_G )) allocate ( wfc_FT_f ( n_k , n_in_G )) !! do calculation for each job do t = 1 , di_n_tran_per_proc tran_id = di_job_table ( proc_id + 1 , t ) !! only compute what the processor should be !! computing if ( tran_id > 0 ) then val_id = di_tran_to_init_fin_id ( tran_id , 1 ) cond_id = di_tran_to_init_fin_id ( tran_id , 2 ) + n_val call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) !! do the calculation for an individual job call compute_dielectric ( dielec_t ( t , :, :, :, :), & val_id , cond_id , wfc_FT_i , wfc_FT_f , n_FFT_grid , n_k , & wfc_FFT_plan , Tif_FFT_plan , n_q_grid , q_grid_min , & n_k_vec , verbose = verbose ) ! !! TESTING!!!! ! call compute_dielectric(dielec_t(t, :, :, :, :), & ! val_id, cond_id, wfc_FT_i, wfc_FT_f, n_FFT_grid, 1, & !     wfc_FFT_plan, Tif_FFT_plan, verbose = verbose) end if end do !! collect and sum results from all the processors, MPI part if ( proc_id /= root_process ) then !! send to main processor call MPI_SEND ( dielec_t , & size ( dielec_t ), MPI_DOUBLE_COMPLEX , & root_process , tag , MPI_COMM_WORLD , err ) end if if ( proc_id == root_process ) then !! add the main processors contribution dielec = dielec + sum ( dielec_t , 1 ) !! receive the other processors contributions do i = 1 , n_proc if ( i - 1 /= root_process ) then call MPI_RECV ( dielec_t , & size ( dielec_t ), MPI_DOUBLE_COMPLEX , & i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) dielec = dielec + sum ( dielec_t , 1 ) end if end do end if !! save dielectric data if ( proc_id == root_process ) then call save_dielectric ( filename , verbose = verbose ) end if end if end subroutine subroutine compute_dielectric ( di , val_id , cond_id , wfc_FT_i , wfc_FT_f , n_FFT_grid , & k_cut , wfc_FFT_plan , Tif_FFT_plan , n_q_grid , q_grid_min , & n_k_vec , verbose ) !! Compute the contribution to the dimensionless dielectric !! from a given i -> f transition. implicit none integer :: n_k_vec ( 3 ) integer :: n_q_grid ( 3 ) real ( dp ) :: q_grid_min ( 3 ) complex ( dp ) :: di (:, :, :, :) complex ( dp ) :: di_unbinned ( di_n_omega_bins , n_q_grid ( 1 ), n_q_grid ( 2 ), n_q_grid ( 3 )) integer :: ki , kf integer :: k_cut integer :: val_id , cond_id integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_i (:, :) complex ( dp ) :: wfc_FT_f (:, :) complex ( dp ) :: wfc_FT_i_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_f_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose real ( dp ) :: omega real ( dp ) :: q_vec ( 3 ) integer :: g1 , g2 , g3 integer :: n_FFT real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: w complex ( dp ) :: elec_props ( di_n_omega_bins ) real ( dp ) :: d_omega real ( dp ) :: delta integer :: q_bin , q_theta_bin , q_phi_bin real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_mag , q_phi , q_theta real ( dp ) :: Ei , Ef integer :: num_q_in_bins ( di_n_q_bins , di_n_q_theta_bins , di_n_q_phi_bins ) integer :: q1 , q2 , q3 real ( dp ) :: q_red ( 3 ) integer :: q_ind ( 3 ) di = ( 0.0_dp , 0.0_dp ) di_unbinned = ( 0.0_dp , 0.0_dp ) wfc_FT_i_exp = ( 0.0_dp , 0.0_dp ) wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_i = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) num_q_in_bins = 0 do ki = 1 , k_cut call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_i ( ki , :), wfc_FT_i_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_i_exp , wfc_i ) Ei = energy_bands ( ki , val_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :), wfc_FT_f_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp , wfc_f ) call calc_tff_vc ( f_sq , wfc_i , wfc_f , n_FFT_grid , Tif_fft_plan , verbose = . FALSE .) do w = 1 , di_n_omega_bins omega = di_omega_bin_width * ( w - 0.5_dp ) d_omega = Ef - Ei delta = di_width_func ( omega ) elec_props ( w ) = ( omega - d_omega + ii * delta ) ** ( - 1 ) - & ( omega + d_omega - ii * delta ) ** ( - 1 ) end do do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) - k_grid_xyz ( ki , :) + & get_sym_FFT_G_grid_xyz ( n_FFT_grid , [ g1 , g2 , g3 ], & k_red_to_xyz , verbose = . FALSE .) q_red = k_grid_red ( kf , :) - k_grid_red ( ki , :) + & get_sym_FFT_G_grid_red ( n_FFT_grid , [ g1 , g2 , g3 ], & verbose = . FALSE .) q_mag = norm2 ( q_vec ) if ( ( q_mag > 1.0e-8_dp ) . and . & ( q_mag < di_n_q_bins * di_q_bin_width ) ) then q_ind ( 1 ) = 1 + int ( n_k_vec ( 1 ) * ( q_red ( 1 ) - q_grid_min ( 1 ))) q_ind ( 2 ) = 1 + int ( n_k_vec ( 2 ) * ( q_red ( 2 ) - q_grid_min ( 2 ))) q_ind ( 3 ) = 1 + int ( n_k_vec ( 3 ) * ( q_red ( 3 ) - q_grid_min ( 3 ))) di_unbinned (:, q_ind ( 1 ), q_ind ( 2 ), q_ind ( 3 )) = & di_unbinned (:, q_ind ( 1 ), q_ind ( 2 ), q_ind ( 3 )) + & ( - 1.0_dp ) * ( e_EM ** 2 / q_mag ** 2 ) * ( pc_vol ) ** ( - 1 ) * & k_weight ( ki ) * ( 1.0_dp * n_FFT ) ** ( - 2 ) * & elec_props (:) * f_sq ( g1 , g2 , g3 ) end if end do end do end do end do end do ! now bin the unbinned dielectric do q3 = 1 , n_q_grid ( 3 ) do q2 = 1 , n_q_grid ( 2 ) do q1 = 1 , n_q_grid ( 1 ) q_red ( 1 ) = ( 1.0_dp / n_k_vec ( 1 )) * ( q1 - 1 ) + q_grid_min ( 1 ) q_red ( 2 ) = ( 1.0_dp / n_k_vec ( 2 )) * ( q2 - 1 ) + q_grid_min ( 2 ) q_red ( 3 ) = ( 1.0_dp / n_k_vec ( 3 )) * ( q3 - 1 ) + q_grid_min ( 3 ) q_vec = matmul ( k_red_to_xyz , q_red ) q_mag = norm2 ( q_vec ) if ( ( q_mag > 1.0e-8_dp ) . and . & ( q_mag < di_n_q_bins * di_q_bin_width ) ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) q_theta_bin = Q_func ( q_theta , 0.0_dp ,& pi / max ( 1.0_dp , 1.0_dp * di_n_q_theta_bins ), di_n_q_theta_bins ) q_phi_bin = Q_func ( q_phi , 0.0_dp ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * di_n_q_phi_bins ), di_n_q_phi_bins ) q_bin = 1 + floor ( q_mag / di_q_bin_width ) num_q_in_bins ( q_bin , q_theta_bin , q_phi_bin ) = & num_q_in_bins ( q_bin , q_theta_bin , q_phi_bin ) + 1 di (:, q_bin , q_theta_bin , q_phi_bin ) = & di (:, q_bin , q_theta_bin , q_phi_bin ) + & di_unbinned (:, q1 , q2 , q3 ) end if end do end do end do ! divide by the number of elements in each bin do q1 = 1 , di_n_q_bins do q2 = 1 , di_n_q_theta_bins do q3 = 1 , di_n_q_phi_bins di (:, q1 , q2 , q3 ) = di (:, q1 , q2 , q3 ) / max ( 1 , num_q_in_bins ( q1 , q2 , q3 )) end do end do end do end subroutine subroutine save_dielectric ( filename , verbose ) !! Save the computed dielectric to 'filename'. implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] ! integer(HSIZE_T) :: dims2(2) integer ( HSIZE_T ) :: dims4 ( 4 ) integer :: error if ( verbose ) then print * , 'Saving dielectric...' print * end if ! create the file call h5open_f ( error ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) ! open the file to write call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'dielectric' , group_id , error ) dims4 = [ di_n_omega_bins , di_n_q_bins , di_n_q_theta_bins , di_n_q_phi_bins ] call h5ltmake_dataset_double_f ( file_id , 'dielectric/dielectric_r' , & size ( dims4 ), dims4 ,& real ( dielec ), error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/dielectric_c' , & size ( dims4 ), dims4 ,& aimag ( dielec ), error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/w_bin_width' , & size ( dims1 ), dims1 ,& di_omega_bin_width , error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/q_bin_width' , & size ( dims1 ), dims1 ,& di_q_bin_width , error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/q_theta_bin_width' , & size ( dims1 ), dims1 ,& pi / max ( 1.0_dp , 1.0_dp * di_n_q_theta_bins ), error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/q_phi_bin_width' , & size ( dims1 ), dims1 ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * di_n_q_phi_bins ), error ) call h5ltmake_dataset_int_f ( file_id , 'dielectric/n_w_bins' , & size ( dims1 ), dims1 ,& di_n_omega_bins , error ) call h5ltmake_dataset_int_f ( file_id , 'dielectric/n_q_bins' , & size ( dims1 ), dims1 ,& di_n_q_bins , error ) call h5ltmake_dataset_int_f ( file_id , 'dielectric/n_q_theta_bins' , & size ( dims1 ), dims1 ,& di_n_q_theta_bins , error ) call h5ltmake_dataset_int_f ( file_id , 'dielectric/n_q_phi_bins' , & size ( dims1 ), dims1 ,& di_n_q_phi_bins , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) end subroutine end module","tags":"","loc":"sourcefile/calc_dielectric.f90.html"},{"title":"dielectric_input.f90 – EXCEED-DM","text":"Contents Modules dielectric_input Source Code dielectric_input.f90 Source Code module dielectric_input !! Handles input variables for the calculation of the dielectric. use prec implicit none integer :: di_n_omega_bins = 1 !! Number of omega bins real ( dp ) :: di_omega_bin_width = 1.0_dp !! Width of the omega bins !! !! Units : eV integer :: di_n_q_bins = 1 !! Number of |q| bins real ( dp ) :: di_q_bin_width = 1.0e3_dp !! Width of the q bins. !! !! Units : eV integer :: di_n_q_phi_bins = 1 !! Number of phi_q bins integer :: di_n_q_theta_bins = 1 !! Number of theta_q bins logical :: load_dielectric_from_file = . FALSE . !! Specify whether the dielectric matrix should be loaded !! from a file or computed. real ( dp ) :: di_width_a = 0.2_dp !! Parameter in the model for the width: !! !! delta = min( a + b*omega, width_max ) !! !! Units: eV real ( dp ) :: di_log_width_b = - 3.0_dp !! Parameter in the model for the width: !! !! delta = min( a + b*omega, width_max ) !! !! Units: None real ( dp ) :: di_width_max = 0.2_dp !! Parameter in the model for the width: !! !! delta = min( a + b*omega, width_max ) !! !! Units: eV integer :: di_n_init = 1 !! number of initial bands to compute for. integer :: di_n_fin = 1 !! number of final bands to compute for. integer :: n_k_vec ( 3 ) NAMELIST / dielectric / di_n_omega_bins , & di_n_q_bins , & di_n_q_phi_bins , & di_n_q_theta_bins , & load_dielectric_from_file , & di_width_a , & di_log_width_b , & di_width_max , & di_n_init , & di_n_fin , & di_q_bin_width , & di_omega_bin_width , & n_k_vec contains function di_width_func ( omega ) result ( delta ) !! Parameterization of the electron lifetime/width. real ( dp ) :: omega real ( dp ) :: delta delta = min ( di_width_a + 1 0.0_dp ** ( di_log_width_b ) * omega , di_width_max ) end function subroutine print_dielectric_input ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    ----------' print * , '    Dielectric' print * , '    ----------' print * print * , '        Load from file? : ' , load_dielectric_from_file print * print * , '        Number of initial states : ' , di_n_init print * , '        Number of final states   : ' , di_n_fin print * print * , '        Binning : ' print * print * , '            Number of w bins : ' , di_n_omega_bins print * , '            w bin width      : ' , di_omega_bin_width print * , '            Number of q bins : ' , di_n_q_bins print * , '            q bin width      : ' , di_q_bin_width print * , '            Number of q theta bins : ' , di_n_q_phi_bins print * , '            Number of q phi bins : ' , di_n_q_theta_bins print * print * , '        delta = min( ' , di_width_max , ', ' , di_width_a , ' + ' , 1 0.0_dp ** di_log_width_b , ' x w )' print * end if end subroutine subroutine load_dielectric_input ( filename , verbose ) implicit none character ( len =* ) :: filename logical :: file_exists logical , optional :: verbose integer :: error if ( verbose ) then print * , 'Loading dielectric parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = dielectric , iostat = error ) close ( 100 ) call print_dielectric_input ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for dielectric parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/dielectric_input.f90.html"},{"title":"di_grid.f90 – EXCEED-DM","text":"Contents Modules di_grid Source Code di_grid.f90 Source Code module di_grid use prec use DFT_parameters use FFT_util implicit none contains subroutine define_q_grid ( q_max , k_red_to_xyz , n_q_grid , & q_grid_min , n_k_vec , n_FFT_grid , verbose ) !! q = k' - k + G !! !! Goes through all possible q's and finds ones which have |q| < q_max. !! !! From this list find : !!     N_q_grid(i) = N_k(i) x ( max(q&#94;red)_i - min(q&#94;red)_i ) !! !!     q_grid_min = min(q&#94;red)_i !! !! so that given q_red, the unique index in the q_grid is given by !!     index = [1, 1, 1] + n_k x [ q_red - q_grid_min ] implicit none logical , optional :: verbose real ( dp ) :: q_max real ( dp ) :: k_red_to_xyz ( 3 , 3 ) real ( dp ) :: q_grid_min ( 3 ) integer :: n_q_grid ( 3 ) integer :: k , kp , g1 , g2 , g3 integer :: n_k_vec ( 3 ) !! Might have to be input by hand right now, should add !! to DFT_input file integer :: n_FFT_grid ( 3 ) real ( dp ) :: q_mag real ( dp ) :: q_xyz ( 3 ) integer :: n_q_less_q_max integer :: ind real ( dp ) :: dk_red ( 3 ) real ( dp ) :: dk_red_min ( 3 ) real ( dp ) :: dk_red_max ( 3 ) integer :: G_red ( 3 ) integer :: G_red_min ( 3 ) integer :: G_red_max ( 3 ) real ( dp ) :: q_red ( 3 ) real ( dp ) :: q_red_min ( 3 ) real ( dp ) :: q_red_max ( 3 ) q_red_min = 0.0_dp q_red_max = 0.0_dp do k = 1 , n_k do kp = 1 , n_k dk_red = k_grid_red ( kp , :) - k_grid_red ( k , :) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) G_red = get_sym_FFT_G_grid_red ( n_FFT_grid , [ g1 , g2 , g3 ], & verbose = . FALSE .) q_red = dk_red + G_red q_xyz = matmul ( k_red_to_xyz , q_red ) q_mag = norm2 ( q_xyz ) if ( q_mag <= q_max ) then q_red_min ( 1 ) = min ( q_red ( 1 ), q_red_min ( 1 )) q_red_min ( 2 ) = min ( q_red ( 2 ), q_red_min ( 2 )) q_red_min ( 3 ) = min ( q_red ( 3 ), q_red_min ( 3 )) q_red_max ( 1 ) = max ( q_red ( 1 ), q_red_max ( 1 )) q_red_max ( 2 ) = max ( q_red ( 2 ), q_red_max ( 2 )) q_red_max ( 3 ) = max ( q_red ( 3 ), q_red_max ( 3 )) end if end do end do end do end do end do n_q_grid ( 1 ) = 1 + int ( n_k_vec ( 1 ) * ( q_red_max ( 1 ) - q_red_min ( 1 ) ) ) n_q_grid ( 2 ) = 1 + int ( n_k_vec ( 2 ) * ( q_red_max ( 2 ) - q_red_min ( 2 ) ) ) n_q_grid ( 3 ) = 1 + int ( n_k_vec ( 3 ) * ( q_red_max ( 3 ) - q_red_min ( 3 ) ) ) q_grid_min = q_red_min end subroutine end module","tags":"","loc":"sourcefile/di_grid.f90.html"},{"title":"di_transition.f90 – EXCEED-DM","text":"Contents Modules di_transition Source Code di_transition.f90 Source Code module di_transition !! Handles labelling of the transitions that each processor should compute !! for to compute the dielectric. !! !! TODO: Make a better interface to transition such that the job table !! is not specific to the module. This will allow the same transition !! subroutines to be available more generally. implicit none integer :: di_n_tran !! Total number of transitions !! !! = n_init*n_fin integer :: di_n_tran_per_proc !! Number of transitiosn each processor has to calculate integer , allocatable :: di_tran_to_init_fin_id (:, :) !! Dim : [n_tran, 2] !! !! Each transition (i, f) is given a unique index, and this !! is the map back. For each transition id return the initial !! or final state index integer , allocatable :: di_job_table (:, :) !! Dim : [n_proc, n_tran_per_proc] !! give each processor a list of transitions to compute for contains subroutine di_set_job_table ( n_proc , n_init , n_fin , verbose ) implicit none integer :: n_proc integer :: n_init , n_fin logical , optional :: verbose integer :: i , j , tran_id , id , f if ( verbose ) then print * , 'Configuring jobs for processors...' print * end if di_n_tran = n_init * n_fin allocate ( di_tran_to_init_fin_id ( di_n_tran , 2 )) id = 0 do i = 1 , n_init do f = 1 , n_fin id = id + 1 di_tran_to_init_fin_id ( id , 1 ) = i di_tran_to_init_fin_id ( id , 2 ) = f end do end do if ( mod ( di_n_tran , n_proc ) . eq . 0 ) then di_n_tran_per_proc = di_n_tran / n_proc else di_n_tran_per_proc = di_n_tran / n_proc + 1 end if allocate ( di_job_table ( n_proc , di_n_tran_per_proc )) tran_id = 0 do j = 1 , di_n_tran_per_proc do i = 1 , n_proc tran_id = tran_id + 1 if ( tran_id . gt . di_n_tran ) then di_job_table ( i , j ) = 0 else di_job_table ( i , j ) = tran_id end if end do end do if ( verbose ) then print * , '----------------------------------------' print * if ( mod ( di_n_tran , n_proc ) . eq . 0 ) then print * , '    Equal processor load.' print * else if ( di_n_tran_per_proc . eq . 1 ) then print * , '    Number of processors is greater than the number of i -> f' ,& '    transitions. Consider lowering the number of processors.' print * print * , '    Number of transitions = ' , di_n_tran print * else print * , '    Unequal processor load. Some processors will be given null jobs.' print * print * , '    Number of transitions = ' , di_n_tran print * end if print * , '    Number of calculations per processor = ' , di_n_tran_per_proc print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/di_transition.f90.html"},{"title":"version_control.f90 – EXCEED-DM","text":"Contents Modules version_control Source Code version_control.f90 Source Code module version_control !! Keeps track of the current version of the program implicit none character ( len = 64 ) :: version = \"0.2.1\" end module","tags":"","loc":"sourcefile/version_control.f90.html"},{"title":"exdm_scatter.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter Source Code exdm_scatter.f90 Source Code module exdm_scatter !! Perform DM-electron scattering rate calculations use mpi use hdf5 use h5lt use prec use control_input use particle_physics_scatter use numerics_input use in_med_scr use transition use transition_form_factor use exdm_scatter_vc use exdm_scatter_cc use exdm_scatter_vf use exdm_scatter_cf implicit none real ( dp ), allocatable :: binned_rate_t_scatter (:, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_tran_per_proc] !! !! Binned rate allocated on each processor, for each job to compute for !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_if_scatter (:, :, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init, n_fin] !! !! Binned rate between all transitions !! !! Warning : memory intensive !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_i_scatter (:, :, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init] !! !! Binned rate, summed over final states !! !! Units : eV&#94;2 real ( dp ), allocatable :: binned_rate_scatter (:, :, :, :, :) !! Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time] !! !! Binned rate summed over all transitions !! !! Units : eV&#94;2 real ( dp ), allocatable :: rate_scatter (:, :, :) !! Dim : [n_mX, n_FDM, n_time] !! !! Total rate summed over all transitions !! !! Units : eV&#94;2 character ( len = 64 ) :: calc_modes_list ( 4 ) = [ 'vc' , 'vf' , 'cc' , 'cf' ] contains subroutine run_dme_scatter ( proc_id , root_process , & out_filename , nml_filename , DFT_input_filename , sto_wf_filename , & core_elec_config_filename , n_proc , save_binned_rate_if , verbose ) !! Scattering rate calculation implicit none integer :: proc_id integer :: root_process integer :: n_proc character ( len =* ) :: out_filename character ( len =* ) :: nml_filename character ( len =* ) :: DFT_input_filename character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename logical :: save_binned_rate_if logical , optional :: verbose integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: ierr integer :: t , i if ( verbose ) then print * , 'Starting scattering rate calculation...' print * end if call load_particle_physics_scatter ( nml_filename , verbose = verbose ) call load_numerics ( nml_filename , verbose = verbose ) call load_in_med_scr ( nml_filename , dielectric_filename , & DFT_input_filename , proc_id , root_process , n_proc , verbose = verbose ) call load_tff_input ( nml_filename , verbose = verbose ) call set_job_table ( n_proc , n_init , n_fin , verbose = verbose ) ! allocate arrays if ( proc_id == root_process ) then if ( save_binned_rate_if ) then allocate ( binned_rate_if_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_init , n_fin )) binned_rate_if_scatter = 0.0_dp if ( ( n_q_bins + 1 ) * ( n_E_bins + 1 ) * n_mX * n_FDM * n_time * n_init * n_fin * 8.0_dp > 1.0e10_dp ) then if ( verbose ) then print * , '~~~ WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * print * , '    Attempting to store more than 10 GB of data in binned_rate_if. If this is unwanted behavior' print * , '    set save_binned_rate_if = .FALSE. in the control namelist.' print * print * , '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * end if end if end if allocate ( binned_rate_i_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_init )) binned_rate_i_scatter = 0.0_dp allocate ( binned_rate_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time )) binned_rate_scatter = 0.0_dp allocate ( rate_scatter ( n_mX , n_FDM , n_time )) rate_scatter = 0.0_dp end if allocate ( binned_rate_t_scatter ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_tran_per_proc )) binned_rate_t_scatter = 0.0_dp ! specific calc modes to compute binned_rate_t_scatter ! the subroutines here have one purpose and that is to compute ! the binned rate for a given transition id if ( trim ( calc_mode ) . eq . 'vc' ) then call run_dme_scatter_vc ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'cc' ) then call run_dme_scatter_cc ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & sto_wf_filename , core_elec_config_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'vf' ) then call run_dme_scatter_vf ( binned_rate_t_scatter , n_tran_per_proc , DFT_input_filename , & nml_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( trim ( calc_mode ) . eq . 'cf' ) then call run_dme_scatter_cf ( binned_rate_t_scatter , n_tran_per_proc , sto_wf_filename , & core_elec_config_filename , nml_filename , out_filename , proc_id , root_process , verbose = verbose ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Calculation mode : ' , trim ( calc_mode ), ' is not a valid option. Options are : ' print * do i = 1 , size ( calc_modes_list ) print * , '        ' , trim ( calc_modes_list ( i )) print * end do print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if ! sends data to the main node if ( proc_id . ne . root_process ) then call MPI_SEND ( binned_rate_t_scatter , & size ( binned_rate_t_scatter ), MPI_DOUBLE , root_process , tag , MPI_COMM_WORLD , err ) end if if ( proc_id . eq . root_process ) then ! add main processors contribution call update_rates ( binned_rate_t_scatter , proc_id ) do i = 1 , n_proc if ( ( i - 1 ) . ne . root_process ) then call MPI_RECV ( binned_rate_t_scatter , & size ( binned_rate_t_scatter ), MPI_DOUBLE , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! add other processors contributions call update_rates ( binned_rate_t_scatter , i - 1 ) end if end do end if ! save data if ( proc_id . eq . root_process ) then call save_particle_physics_scatter ( out_filename , verbose = verbose ) call save_numerics ( out_filename , verbose = verbose ) call save_in_med_scr ( out_filename , verbose = verbose ) call save_rates ( out_filename , verbose = verbose ) end if end subroutine subroutine update_rates ( binned_rate_t , proc_id ) !! updates all the rate arrays with the output !! of a single processors results implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time , n_tran_per_proc ) integer :: i , f , m , t integer :: proc_id integer :: tran_id do i = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , i ) if ( tran_id . ne . 0 ) then if ( save_binned_rate_if ) then binned_rate_if_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 ), & tran_to_init_fin_id ( tran_id , 2 ) ) = & binned_rate_if_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 ), & tran_to_init_fin_id ( tran_id , 2 ) ) + binned_rate_t (:, :, :, :, :, i ) end if binned_rate_i_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 )) = & binned_rate_i_scatter (:, :, :, :, :, & tran_to_init_fin_id ( tran_id , 1 )) + binned_rate_t (:, :, :, :, :, i ) binned_rate_scatter = binned_rate_scatter + binned_rate_t (:, :, :, :, :, i ) do t = 1 , n_time do f = 1 , n_FDM do m = 1 , n_mX rate_scatter ( m , f , t ) = rate_scatter ( m , f , t ) + & sum ( binned_rate_t (:, :, m , f , t , i )) end do end do end do end if end do end subroutine ! save data functions subroutine save_rates ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: m , f , t integer :: i , fin character ( len = 64 ) :: m_str , t_str , f_str character ( len = 64 ) :: i_str , fin_str if ( verbose ) then print * , 'Saving scattering rates...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'rates' , group_id , error ) dims2 = [ n_q_bins + 1 , n_E_bins + 1 ] do t = 1 , n_time write ( t_str , * ) t t_str = trim ( adjustl ( t_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ),& group_id , error ) do f = 1 , n_FDM write ( f_str , * ) f f_str = trim ( adjustl ( f_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ),& group_id , error ) do m = 1 , n_mX write ( m_str , * ) m m_str = trim ( adjustl ( m_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/total' , & size ( dims1 ), dims1 ,& rate_scatter ( m , f , t ), error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/total_binned' , & size ( dims2 ), dims2 ,& binned_rate_scatter (:, :, m , f , t ), error ) do i = 1 , n_init write ( i_str , * ) i i_str = trim ( adjustl ( i_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/binned_i' , & size ( dims2 ), dims2 ,& binned_rate_i_scatter (:, :, m , f , t , i ), error ) if ( save_binned_rate_if ) then do fin = 1 , n_fin write ( fin_str , * ) fin fin_str = trim ( adjustl ( fin_str )) call h5gcreate_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'rates' // & '/t_' // trim ( t_str ) // & '/f_' // trim ( f_str ) // & '/m_' // trim ( m_str ) // & '/init_' // trim ( i_str ) // & '/fin_' // trim ( fin_str ) // & '/binned_if' ,& size ( dims2 ), dims2 ,& binned_rate_if_scatter (:, :, m , f , t , i , fin ), error ) end do end if end do end do end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter.f90.html"},{"title":"in_med_scr.f90 – EXCEED-DM","text":"Contents Modules in_med_scr Source Code in_med_scr.f90 Source Code module in_med_scr !! Handle analytic/numeric dielectric or other in medium effects which screen the interaction !! !! rate ~ 1/screen&#94;2 use hdf5 use h5lt use prec use constants use math_mod use dielectric_input use calc_dielectric implicit none character ( len = 64 ) :: screen_type = '' !!! !! Eq 6 from !!      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 real ( dp ) :: di_e0 real ( dp ) :: di_q_tf real ( dp ) :: di_omega_p real ( dp ) :: di_alpha !!! logical :: include_screen = . TRUE . !! toggle whether screening effects are included or not !! For numerical calculation of dielectric complex ( dp ), allocatable :: screen_mat (:, :, :, :) !! Numerically computed screening matrix, binned in [ omega, q, q_theta, q_phi ] integer :: scr_n_w_bins integer :: scr_n_q_bins integer :: scr_n_q_theta_bins integer :: scr_n_q_phi_bins real ( dp ) :: scr_w_bin_width real ( dp ) :: scr_q_bin_width NAMELIST / in_medium / screen_type ,& di_e0 , & di_q_tf , & di_omega_p , & di_alpha , & include_screen contains subroutine load_scr_dielectric ( filename , verbose ) implicit none character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims4 ( 4 ) integer :: error real ( dp ), allocatable :: dielectric_buff (:, :, :, :) if ( verbose ) then print * , 'Loading dielectric from file... ' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_int_f ( file_id , 'dielectric/n_w_bins' ,& scr_n_w_bins , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'dielectric/n_q_bins' ,& scr_n_q_bins , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'dielectric/n_q_theta_bins' ,& scr_n_q_theta_bins , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'dielectric/n_q_phi_bins' ,& scr_n_q_phi_bins , dims1 , error ) call h5ltread_dataset_double_f ( file_id , 'dielectric/w_bin_width' ,& scr_w_bin_width , dims1 , error ) call h5ltread_dataset_double_f ( file_id , 'dielectric/q_bin_width' ,& scr_q_bin_width , dims1 , error ) dims4 = [ scr_n_w_bins , scr_n_q_bins , scr_n_q_theta_bins , scr_n_q_phi_bins ] allocate ( dielectric_buff ( scr_n_w_bins , scr_n_q_bins , scr_n_q_theta_bins , & scr_n_q_phi_bins )) allocate ( screen_mat ( scr_n_w_bins , scr_n_q_bins , scr_n_q_theta_bins , & scr_n_q_phi_bins )) screen_mat = ( 0.0_dp , 0.0_dp ) call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_r' ,& dielectric_buff , dims4 , error ) screen_mat = screen_mat + dielectric_buff call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_c' ,& dielectric_buff , dims4 , error ) screen_mat = screen_mat + ii * dielectric_buff call h5fclose_f ( file_id , error ) call h5close_f ( error ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for dielectric : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_in_med ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    ---------' print * , '    In-Medium' print * , '    ---------' print * print * , '        Include screen? : ' , include_screen print * , '        Screen type     : ' , trim ( screen_type ) print * if ( trim ( screen_type ) == 'analytic' ) then print * , '        e_0      : ' , di_e0 print * , '        alpha    : ' , di_alpha print * , '        q_TF     : ' , di_q_tf / 1.0e3_dp , 'keV' print * , '        omega_p  : ' , di_omega_p , 'eV' print * end if end if end subroutine subroutine load_in_med_scr ( filename , dielectric_filename , DFT_input_filename , & proc_id , root_process , n_proc , verbose ) implicit none character ( len =* ) :: filename character ( len =* ) :: dielectric_filename character ( len =* ) :: DFT_input_filename integer :: proc_id , root_process , n_proc logical :: file_exists logical , optional :: verbose integer :: error , err if ( verbose ) then print * , 'Loading in-medium screening parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = in_medium , iostat = error ) close ( 100 ) call print_in_med ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if if ( trim ( screen_type ) == 'numeric' ) then call load_dielectric_input ( filename , verbose = verbose ) if ( . not . load_dielectric_from_file ) then ! compute and save the dielectric call run_dielectric_calc ( filename , dielectric_filename , & DFT_input_filename , proc_id , root_process , n_proc , verbose = verbose ) end if if ( proc_id == root_process ) then ! load the dielectric file to one processor call load_scr_dielectric ( dielectric_filename , verbose = verbose ) end if ! send loaded data to all other processors call MPI_Bcast ( scr_n_w_bins , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( scr_n_q_bins , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( scr_n_q_theta_bins , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( scr_n_q_phi_bins , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( scr_w_bin_width , 1 , MPI_DOUBLE , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( scr_q_bin_width , 1 , MPI_DOUBLE , root_process ,& MPI_COMM_WORLD , err ) if ( proc_id /= root_process ) then !! allocate screen_mat allocate ( screen_mat ( scr_n_w_bins , scr_n_q_bins , scr_n_q_theta_bins , & scr_n_q_phi_bins )) screen_mat = ( 0.0_dp , 0.0_dp ) end if call MPI_Bcast ( screen_mat , size ( screen_mat ), MPI_DOUBLE_COMPLEX , & root_process , MPI_COMM_WORLD , err ) !! For some reason this does not work when load_dielectric_from_file is FALSE. !! When load_dielectric_from_file = TRUE all the processes !! open and read the file as expected. Seems like a file !! permission issue with HDF5. !! !! Workaround : read by the main processor then broadcast !! the data to the other ones ! call MPI_Barrier(MPI_COMM_WORLD, ierr) ! call load_scr_dielectric(dielectric_filename, verbose = verbose) end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for in medium parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_in_med_scr ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving screening parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'in_med_screening' , group_id , error ) ! ! write data call h5ltmake_dataset_string_f ( file_id , 'in_med_screening/screen_type' ,& screen_type , error ) if ( trim ( screen_type ) == 'analytic' ) then call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_e0' , size ( dims1 ), dims1 ,& di_e0 , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_alpha' , size ( dims1 ), dims1 ,& di_alpha , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_q_tf' , size ( dims1 ), dims1 ,& di_q_tf , error ) call h5ltmake_dataset_double_f ( file_id , 'in_med_screening/di_omega_p' , size ( dims1 ), dims1 ,& di_omega_p , error ) end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * end if stop end if end subroutine function screening ( q_vec , omega ) result ( scr ) implicit none real ( dp ) :: q_vec ( 3 ) real ( dp ) :: omega real ( dp ) :: q_mag real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_theta , q_phi integer :: w_bin_num , q_bin_num , q_theta_bin_num , q_phi_bin_num real ( dp ) :: scr if ( include_screen ) then if ( trim ( screen_type ) . eq . 'analytic' ) then scr = model_dielectric ( q_vec , omega , & di_e0 , & di_q_tf , & di_alpha , & di_omega_p ) else if ( trim ( screen_type ) == 'numeric' ) then q_mag = norm2 ( q_vec ) if ( q_mag >= 1.0e-8_dp ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) w_bin_num = 1 + floor ( omega / scr_w_bin_width ) q_bin_num = 1 + floor ( q_mag / scr_q_bin_width ) q_theta_bin_num = 1 + floor ( q_theta / ( pi / max ( 1.0_dp , 1.0_dp * scr_n_q_theta_bins ))) q_phi_bin_num = 1 + floor ( q_phi / ( 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * scr_n_q_phi_bins ))) if ( ( w_bin_num > scr_n_w_bins ) . or . & ( q_bin_num > scr_n_q_bins ) . or . & ( q_theta_bin_num > scr_n_q_theta_bins ) . or . & ( q_phi_bin_num > scr_n_q_phi_bins ) ) then scr = 1.0_dp else scr = abs ( screen_mat ( w_bin_num , q_bin_num , & q_theta_bin_num , q_phi_bin_num ) ) end if end if else scr = 1.0_dp end if else scr = 1.0_dp end if end function function model_dielectric ( q_vec , omega ,& e0 , q_tf , alpha , omega_p ) result ( di ) !! Analytic form of the dielectric function !! Eq 6 from !!      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 implicit none real ( dp ) :: di real ( dp ) :: e0 , q_tf , alpha , omega_p real ( dp ) :: q_vec ( 3 ) real ( dp ) :: q_mag real ( dp ) :: omega q_mag = norm2 ( q_vec ) di = 1.0_dp + ( ( e0 - 1.0_dp ) ** ( - 1 ) + & alpha * ( q_mag / q_tf ) ** 2 + & q_mag ** 4 / ( 4 * m_elec ** 2 * omega_p ** 2 ) - & ( omega / omega_p ) ** 2 ) ** ( - 1 ) end function end module","tags":"","loc":"sourcefile/in_med_scr.f90.html"},{"title":"numerics_input.f90 – EXCEED-DM","text":"Contents Modules numerics_input Source Code numerics_input.f90 Source Code module numerics_input !! Variables relating to binning and other numerics use hdf5 use h5lt use prec implicit none real ( dp ) :: q_bin_width = 1.0e3_dp !! width of momuntum bins !! !! Units : eV integer :: n_q_bins = 0 !! Number of q bins, with bin width q_bin_width, to save !! !! Note: momentum transfers greater than n_q_bins*q_bin_width !! will be stored in the last, extra bin real ( dp ) :: E_bin_width = 1.0_dp !! Width of the energy bins !! !! Units : eV integer :: n_E_bins = 0 !! Number of E bins, with bin width E_bin_width, to save !! !! Note: energy transfers greater than n_E_bins*E_bin_width !! will be stored in the last, extra bin integer :: E_bin_threshold = 1 !! smallest E bin added to total rate calculation !! default : 1 - include all bins real ( dp ) :: Ef_max = 6 0.0_dp !! maximum final state energy to include in calculations !! !! Units : eV !! !! TODO : E_cut is a more appropriate name integer :: n_init !! number of initial states integer :: n_fin !! number of final states integer :: n_FFT_grid_input ( 3 ) = [ 0 , 0 , 0 ] !! Default size of the FFT, used to extend core !! calculation by making the size of the FFT larger !! !! Note : only used in calculations which use the FFT real ( dp ) :: q_s_FFT = 215 1.0_dp / 2.0_dp !! Units : eV !! !! q_max_FFT = q_s_FFT*N_FFT !! !! Minimum eigenvalue of k_red_to_xyz matrix !! !! Note : only used in calculations which use the FFT !! !! TODO : do not hard code this in integer :: n_kf_theta = 1 !! Number of theta points in integration of kf !! !! Note : only used in free calculatinos integer :: n_kf_phi = 1 !! Number of phi points in integration of kf !! !! Note : only used in free calculatinos integer :: n_ki_theta = 1 !! Number of theta points in integration of ki !! !! Note : only used in core -> free calculatinos integer :: n_ki_phi = 1 !! Number of phi points in integration of ki !! !! Note : only used in core -> free calculatinos real ( dp ) :: ki_s = 10 0.0_dp !! Scale parameter for k_i momentum to integrate over in core -> free calculation !! !! maximum initial electron momentum = ki_s * Z * alpha * m_e !! !! Generally want this to be >> Z alpha m_e, the scale factor of the electron wave functions integer :: n_ki = 2 !! Number of radial points in integration of ki real ( dp ) :: ki_min = 1.0e3_dp !! Minimum electron momentum !! !! Units : eV NAMELIST / numerics / q_bin_width , & n_q_bins , & E_bin_width , & n_E_bins , & E_bin_threshold , & Ef_max , & n_init , & n_fin , & q_s_FFT , & n_FFT_grid_input , & n_kf_theta , & n_kf_phi , & n_ki , & n_ki_theta , & n_ki_phi , & ki_s , & ki_min contains subroutine load_numerics ( filename , verbose ) implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error if ( verbose ) then print * , 'Loading numerics parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics , iostat = error ) close ( 100 ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Problem reading numerics namelist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if call print_numerics ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for numerics parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine print_numerics ( verbose ) implicit none logical , optional :: verbose character ( len = 64 ) :: n_E_bins_str character ( len = 64 ) :: n_q_bins_str if ( verbose ) then write ( n_E_bins_str , * ) n_E_bins write ( n_q_bins_str , * ) n_q_bins print * , '----------------------------------------' print * , '    --------' print * , '    Numerics' print * , '    --------' print * print * , '        Number of initial states = ' , n_init print * , '        Number of final states   = ' , n_fin print * print * , '        Number of E bins = ' , trim ( adjustl ( n_E_bins_str )), ' + 1' print * , '        Energy bin width = ' , E_bin_width , ' eV' print * print * , '        Number of q bins = ' , trim ( adjustl ( n_q_bins_str )), ' + 1' print * , '        q bin width      = ' , q_bin_width / 1.0e3_dp , ' keV' print * print * , '        Ef_max = ' , Ef_max , ' eV' print * end if end subroutine subroutine save_numerics ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving numerics...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'numerics/n_E_bins' , size ( dims1 ), dims1 ,& n_E_bins + 1 , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_q_bins' , size ( dims1 ), dims1 ,& n_q_bins + 1 , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_init' , size ( dims1 ), dims1 ,& n_init , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/n_fin' , size ( dims1 ), dims1 ,& n_fin , error ) call h5ltmake_dataset_double_f ( file_id , 'numerics/E_bin_width' , size ( dims1 ), dims1 ,& E_bin_width , error ) call h5ltmake_dataset_double_f ( file_id , 'numerics/q_bin_width' , size ( dims1 ), dims1 ,& q_bin_width , error ) call h5ltmake_dataset_int_f ( file_id , 'numerics/E_bin_threshold' , size ( dims1 ), dims1 ,& E_bin_threshold , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine end module","tags":"","loc":"sourcefile/numerics_input.f90.html"},{"title":"particle_physics_scatter.f90 – EXCEED-DM","text":"Contents Modules particle_physics_scatter Source Code particle_physics_scatter.f90 Source Code module particle_physics_scatter !! Particle physics parameters needed for a DM-electron !! scattering rate calculation use hdf5 use h5lt use prec use constants use units implicit none integer :: n_mX = 1 !! Number of masses to compute for real ( dp ) :: log_mmin = 9.0_dp real ( dp ) :: log_mmax = 9.0_dp integer :: n_extra_mX = 0 !! Optional !! !! User can specify extra mass points to add in addition to !! the log-uniform ones chosen integer :: n_FDM = 1 !! Number of mediator types to compute for real ( dp ) :: FDMPower_min = 0.0_dp real ( dp ) :: FDMPower_max = 0.0_dp integer :: n_time = 1 !! Number of time of days to compute for real ( dp ) :: time_day_min = 0.0_dp real ( dp ) :: time_day_max = 0.0_dp real ( dp ) :: percentile_cut = 3.0_dp real ( dp ) :: rhoX_GeV_per_cm3 = 0.4_dp !! Dark matter density !! !! Units : GeV/cm&#94;3 real ( dp ) :: v0_km_per_sec = 23 0.0_dp real ( dp ) :: vE_km_per_sec = 24 0.0_dp real ( dp ) :: vEsc_km_per_sec = 60 0.0_dp real ( dp ) :: thetaE = ( 4 2.0_dp / 18 0.0_dp ) * pi !rad !! Generated !!!!!!! real ( dp ) :: rhoX !! Dark matter density !! !! Units : eV&#94;4 real ( dp ) :: v0 real ( dp ) :: vE real ( dp ) :: vEsc real ( dp ), allocatable :: mX (:) real ( dp ), allocatable :: mX_2 (:) real ( dp ), allocatable :: FDMPowerList (:) real ( dp ), allocatable :: timeOfDayList (:) real ( dp ), allocatable :: vEVecList (:, :) !! Dim : [n_times, 3] real ( dp ) :: g_func_N0 real ( dp ) :: g_func_c1 , g_func_c2 real ( dp ) :: v_max !! = vE + vEsc NAMELIST / particle_physics / n_mX , & log_mmin , & log_mmax , & n_extra_mX , & n_FDM , & FDMPower_min , & FDMPower_max , & n_time , & time_day_min , & time_day_max , & percentile_cut , & rhoX_GeV_per_cm3 , & v0_km_per_sec , & vE_km_per_sec , & vEsc_km_per_sec NAMELIST / extra_mX / mX_2 contains subroutine print_particle_physics_scatter ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    -----------' print * , '    Dark Matter' print * , '    -----------' print * print * , '        Density : ' , rhoX_GeV_per_cm3 , ' GeV/cm&#94;3' print * , '        Masses : ' , mX print * print * , '        Mediator Form Factors (-d log F_DM / d log q) : ' , FDMPowerList print * print * , '        Halo Velocity Distribution Parameters : ' print * , '            v0   = ' , v0_km_per_sec , ' km/sec' print * , '            vE   = ' , vE_km_per_sec , ' km/sec' print * , '            vEsc = ' , vEsc_km_per_sec , ' km/sec' print * print * , '        Time of day : ' , timeOfDayList print * end if end subroutine subroutine load_particle_physics_scatter ( filename , verbose ) implicit none logical , optional :: verbose character ( len =* ) :: filename logical :: file_exists integer :: error if ( verbose ) then print * , 'Loading particle physics parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = particle_physics , iostat = error ) rewind ( 100 ) rhoX = inv_cm_to_eV ** 3 * 1.0e9_dp * rhoX_GeV_per_cm3 v0 = km_per_sec_to_none * v0_km_per_sec vE = km_per_sec_to_none * vE_km_per_sec vEsc = km_per_sec_to_none * vEsc_km_per_sec v_max = vE + vEsc if ( n_extra_mX . ne . 0 ) then allocate ( mX_2 ( n_extra_mX )) mX_2 = 1.0e9_dp read ( 100 , nml = extra_mX , iostat = error ) rewind ( 100 ) end if close ( 100 ) call set_g_func_parameters () call set_mX ( verbose ) call set_FDM_powers ( verbose ) call set_time_vE_vec ( verbose ) call print_particle_physics_scatter ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Input file for particle physics parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine save_particle_physics_scatter ( filename , verbose ) implicit none character ( len =* ) :: filename integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving particle physics parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'particle_physics' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_mX' , size ( dims1 ), dims1 ,& n_mX , error ) call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_FDM' , size ( dims1 ), dims1 ,& n_FDM , error ) call h5ltmake_dataset_int_f ( file_id , 'particle_physics/n_time' , size ( dims1 ), dims1 ,& n_time , error ) dims1 = [ n_mX ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/mX' , size ( dims1 ), dims1 ,& mX , error ) dims1 = [ n_FDM ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/FDM_list' , size ( dims1 ), dims1 ,& FDMPowerList , error ) dims1 = [ n_time ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/t_list' , size ( dims1 ), dims1 ,& timeOfDayList , error ) dims2 = [ n_time , 3 ] call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vE_list' , size ( dims2 ), dims2 ,& vEVecList , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/v0' , size ( dims1 ), dims1 ,& v0 , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vEsc' , size ( dims1 ), dims1 ,& vEsc , error ) call h5ltmake_dataset_double_f ( file_id , 'particle_physics/vE' , size ( dims1 ), dims1 ,& vE , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) ! if ( verbose ) then !     print*, '----------' !     print* ! end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '   Output file : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine set_mX ( verbose ) implicit none logical :: verbose integer :: m n_mX = n_mX + n_extra_mX allocate ( mX ( n_mX )) do m = 1 , n_mX - n_extra_mX mX ( m ) = 1 0.0_dp ** ( log_mmin + ( log_mmax - log_mmin ) * & ( m - 1 ) / ( max ( 1 , n_mX - n_extra_mX - 1 ))& ) end do if ( n_extra_mX . ne . 0 ) then mX ( n_mX - n_extra_mX + 1 :) = mX_2 end if end subroutine subroutine set_g_func_parameters () implicit none ! precomputed constants for the g function defined in the physics module g_func_N0 = ( pi * v0 ** 3 ) * ( sqrt ( pi ) * erf ( vEsc / v0 ) - 2 * ( vEsc / v0 ) * exp ( - ( vEsc / v0 ) ** 2 )) g_func_c1 = ( 2 * pi ** 2 * v0 ** 2 / g_func_N0 ) g_func_c2 = exp ( - ( vEsc / v0 ) ** 2 ) end subroutine subroutine set_FDM_powers ( verbose ) implicit none logical :: verbose integer :: f allocate ( FDMPowerList ( n_FDM )) do f = 1 , n_FDM FDMPowerList ( f ) = FDMPower_min + & ( FDMPower_max - FDMPower_min ) * ( f - 1 ) / ( max ( 1 , n_FDM - 1 )) end do end subroutine subroutine set_time_vE_vec ( verbose ) implicit none logical :: verbose integer :: t allocate ( timeOfDayList ( n_time )) allocate ( vEVecList ( n_time , 3 )) do t = 1 , n_time timeOfDayList ( t ) = time_day_min + ( time_day_max - time_day_min ) * & ( t - 1.0_dp ) / ( max ( 1 , n_time - 1 )) vEVecList ( t , 1 ) = vE * sin ( thetaE ) * sin ( 2.0_dp * PI * timeOfDayList ( t )) vEVecList ( t , 2 ) = vE * cos ( thetaE ) * sin ( thetaE ) * ( cos ( 2.0_dp * PI * timeOfDayList ( t )) - 1 ) vEVecList ( t , 3 ) = vE * (( sin ( thetaE ) ** 2 ) * cos ( 2.0_dp * PI * timeOfDayList ( t )) & + cos ( thetaE ) ** 2 ) end do end subroutine function v_minus ( q_vec , mX , vE_vec , omega ) result ( v_m ) !! v_- function !! !! v_- = (1/q)| q_vec . vE + q&#94;2/mX + w | !! !! Note that we will explicitly check that this value is < v_Esc so that !! the g function is always > 0 !! !! Units : None implicit none real ( dp ) :: mX , omega real ( dp ) :: q_mag real ( dp ) :: v_m real ( dp ) :: q_vec ( 3 ) real ( dp ) :: vE_vec ( 3 ) q_mag = norm2 ( q_vec ) v_m = ( 1 / q_mag ) * abs ( dot_product ( q_vec , vE_vec ) + 0.5_dp * q_mag ** 2 / mX + omega ) end function function g_func ( q , v_m ) result ( g_fun ) !! Kinematic function : !! !! g_func = 2*pi*int d&#94;3v f_chi(v) delta(w - w_q) !! !! Units : eV&#94;(-1) implicit none real ( dp ) :: q , v_m real ( dp ) :: g_fun g_fun = ( g_func_c1 / q ) * ( exp ( - ( v_m / v0 ) ** 2 ) - g_func_c2 ) end function function red_mass ( m1 , m2 ) result ( mu ) !! Reduced mass implicit none real ( dp ) :: m1 , m2 , mu mu = m1 * m2 / ( m1 + m2 ) end function function F_med_sq_func ( q_mag , power ) result ( F_med_sq_val ) !! Mediator for factor squared !! !! Units : None implicit none real ( dp ) :: q_mag real ( dp ) :: F_med_sq_val real ( dp ) :: power f_med_sq_val = ( alpha_EM * m_elec / q_mag ) ** ( 2 * power ) end function end module","tags":"","loc":"sourcefile/particle_physics_scatter.f90.html"},{"title":"transition_form_factor.f90 – EXCEED-DM","text":"Contents Modules transition_form_factor Source Code transition_form_factor.f90 Source Code module transition_form_factor !! -------------------------------- !!     Transition Form Factor (TFF) !! -------------------------------- !! ! See the documentation for LaTeX'ed math eqs. !! !! Define general scattering operators such that the scattering rate for !! any DM model can be computed. This will generalize the transition form factor (TFF) defined as !! !! \\begin{align} !!    T_{if}(\\mathcal{O}_1, \\mathcal{O}_2) \\equiv \\langle f | e&#94;{i \\mathbf{q} \\cdot \\mathbf{x}} \\mathcal{O}_1 | i \\rangle !! \\cdot \\langle i | e&#94;{-i \\mathbf{q} \\cdot \\mathbf{x}} \\mathcal{O}_2&#94;* | f \\rangle !! \\end{align} !! !! All spin independent results come from  \\mathcal{O}_1 = \\mathcal{O}_2 = 1 . Note that this quantity is different !! than the mediator form factor and screening factor, both of which can be set independently of this function. !! !! Each  \\mathcal{O}  that the user can specify will have a unique index. !! !! A catalog will be kept of all the operators and their corresponding index. !! !! The calculation can become more difficult technically depending on the operator so a hierarchy will be kept in !! order to simplify the calculation when possible. !! !! TODO: For now we will assume that only a single T_if needs to be computed. Future work could improve on this by !! setting up wrapper functions which compute multiple T's and sum them. This will be necessary when the scattering operator !! has more than one term, e.g.  \\mathcal{O} = \\frac{k}{m_e} + \\mathbf{S}_e . !! !! Catalog : !! <ul> !!     <li> !!         1 -  \\mathcal{O} = 1  [ vc ] !!     </li> !!     <li> !!         2 -  \\mathcal{O} = \\mathbf{S}_e  [ vc, <b>s</b> ] !!     </li> !! </ul> !! !! Notes : Bracketed quantities indicate what transition types are currently supported, <b>s</b> indicates its only !! supported for spin dependent wave functions. use prec use constants implicit none integer :: tff_id ( 2 ) = [ 1 , 1 ] NAMELIST / tff / tff_id interface calc_tff_vc module procedure calc_tff_vc_no_spin module procedure calc_tff_vc_spin end interface contains subroutine print_tff_input ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    ----------------------' print * , '    Transition Form Factor' print * , '    ----------------------' print * print * , '        ID  : ' , tff_id print * end if end subroutine subroutine load_tff_input ( filename , verbose ) implicit none character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error if ( verbose ) then print * , 'Loading Transition Form Factor parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = tff , iostat = error ) close ( 100 ) call print_tff_input ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '   Input file for tff parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine subroutine calc_tff_vc_spin ( TFF , wfc_i , wfc_f , n_FFT_grid , FFT_plan , verbose ) !! Compute the tff for the valence to conduction calculation !! !! TFF = FFT(  u_{f, k_f}&#94;* \\mathcal{O}_1 u_{i, k_i}   )  \\times  FFT(  u_{f, k_f}&#94;* \\mathcal{O}_2 u_{i, k_i}  ) !!  &#94;*  !! !! Dim : [ n_FFT_grid ] !! !! Units : None use DFT_parameters use math_mod implicit none logical , optional :: verbose integer :: n_FFT_grid ( 3 ) integer :: FFT_plan ( 8 ) complex ( dp ) :: wfc_i ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: Tx_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar overlaps in position space complex ( dp ) :: Tx_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector overlaps in position space complex ( dp ) :: TFF_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar complex ( dp ) :: TFF_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector real ( dp ) :: TFF ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: op ( 2 , 2 ) integer :: i , g1 , g2 , g3 Tx_s_terms = ( 0.0_dp , 0.0_dp ) Tx_v_terms = ( 0.0_dp , 0.0_dp ) TFF_s_terms = ( 0.0_dp , 0.0_dp ) TFF_v_terms = ( 0.0_dp , 0.0_dp ) if ( tff_id ( 1 ) == tff_id ( 2 ) ) then ! only have to compute one element since the other is the complex conjugate select case ( tff_id ( 1 ) ) case ( 1 ) ! 1 op = pauli_spin_matrix ( 0 ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) Tx_s_terms ( 1 , g1 , g2 , g3 ) = dot_product (& conjg ( wfc_f (:, g1 , g2 , g3 )),& matmul ( op , wfc_i (:, g1 , g2 , g3 ) )& ) end do end do end do call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) TFF_s_terms ( 2 , :, :, :) = conjg ( TFF_s_terms ( 1 , :, :, :)) TFF = TFF_s_terms ( 1 , :, :, :) * TFF_s_terms ( 2 , :, :, :) case ( 2 ) ! pauli matrix operator do i = 1 , 3 do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) op = pauli_spin_matrix ( i ) Tx_v_terms ( i , 1 , g1 , g2 , g3 ) = dot_product (& conjg ( wfc_f (:, g1 , g2 , g3 )),& matmul ( op , wfc_i (:, g1 , g2 , g3 ) )& ) end do end do end do call dfftw_execute_dft ( FFT_plan , Tx_v_terms ( i , 1 , :, :, :) , TFF_v_terms ( i , 1 , :, :, :)) TFF_v_terms ( i , 2 , :, :, :) = conjg ( TFF_v_terms ( i , 1 , :, :, :)) TFF = TFF + TFF_v_terms ( i , 1 , :, :, :) * TFF_v_terms ( i , 2 , :, :, :) end do case default op = pauli_spin_matrix ( 0 ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) Tx_s_terms ( 1 , g1 , g2 , g3 ) = dot_product (& conjg ( wfc_f (:, g1 , g2 , g3 )),& matmul ( op , wfc_i (:, g1 , g2 , g3 ) )& ) end do end do end do call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) TFF_s_terms ( 2 , :, :, :) = conjg ( TFF_s_terms ( 1 , :, :, :)) TFF = TFF_s_terms ( 1 , :, :, :) * TFF_s_terms ( 2 , :, :, :) end select end if end subroutine subroutine calc_tff_vc_no_spin ( TFF , wfc_i , wfc_f , n_FFT_grid , FFT_plan , verbose ) !! Compute the tff for the valence to conduction calculation !! !! TFF = FFT(  u_{f, k_f}&#94;* \\mathcal{O}_1 u_{i, k_i}   )  \\times  FFT(  u_{f, k_f}&#94;* \\mathcal{O}_2 u_{i, k_i}  ) !!  &#94;*  !! !! Dim : [ n_FFT_grid ] !! !! Units : None use DFT_parameters implicit none logical , optional :: verbose integer :: n_FFT_grid ( 3 ) integer :: FFT_plan ( 8 ) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: Tx_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar overlap in position space complex ( dp ) :: Tx_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector overlap in position space complex ( dp ) :: TFF_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar complex ( dp ) :: TFF_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector real ( dp ) :: TFF ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) Tx_s_terms = ( 0.0_dp , 0.0_dp ) Tx_v_terms = ( 0.0_dp , 0.0_dp ) TFF_s_terms = ( 0.0_dp , 0.0_dp ) TFF_v_terms = ( 0.0_dp , 0.0_dp ) if ( tff_id ( 1 ) == tff_id ( 2 ) ) then ! only have to compute one element since the other is the complex conjugate select case ( tff_id ( 1 ) ) case ( 1 ) ! 1 Tx_s_terms ( 1 , :, :, :) = conjg ( wfc_f ) * wfc_i call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) TFF_s_terms ( 2 , :, :, :) = conjg ( TFF_s_terms ( 1 , :, :, :)) TFF = TFF_s_terms ( 1 , :, :, :) * TFF_s_terms ( 2 , :, :, :) case default Tx_s_terms ( 1 , :, :, :) = conjg ( wfc_f ) * wfc_i call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) TFF_s_terms ( 2 , :, :, :) = conjg ( TFF_s_terms ( 1 , :, :, :)) TFF = TFF_s_terms ( 1 , :, :, :) * TFF_s_terms ( 2 , :, :, :) end select end if end subroutine end module","tags":"","loc":"sourcefile/transition_form_factor.f90.html"},{"title":"Zeff_input.f90 – EXCEED-DM","text":"Contents Modules Zeff_input Source Code Zeff_input.f90 Source Code module Zeff_input !! Loads the Zeff paramters for the free calculation use prec use DFT_parameters use core_electrons implicit none character ( len = 64 ) :: Zeff_type = 'one' !! Specify what Zeff to use !! !! - 'one' - all Zeff = 1 !! - 'Eb' - use the binding energy of the (valence) state !! - 'Eb_c' - use the binding energy of the (core) state !! - 'in' - specified by the input real ( dp ) :: n_Eb = 1.0_dp !! n to use when computing Z_eff with the binding energy approximation real ( dp ) :: val_Zeff_in ( 100 ) = 1.0_dp NAMELIST / Zeff / Zeff_type , & n_Eb , & val_Zeff_in contains subroutine print_Zeff ( verbose ) implicit none logical , optional :: verbose if ( verbose ) then print * , '----------------------------------------' print * , '    ----' print * , '    Zeff' print * , '    ----' print * print * , '        Type  : ' , trim ( Zeff_type ) print * end if end subroutine subroutine load_Zeff_parameters ( filename , verbose ) implicit none character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error if ( verbose ) then print * , 'Loading Zeff parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = Zeff , iostat = error ) close ( 100 ) if ( error . ne . 0 ) then if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '    Problem reading Zeff namelist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if call print_Zeff ( verbose = verbose ) if ( verbose ) then print * , '----------------------------------------' print * end if else if ( verbose ) then print * , '!!! ERROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * print * , '   Input file for Zeff parameters : ' , trim ( filename ), ' does NOT exist.' print * print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * end if stop end if end subroutine function get_val_Z_eff ( i , k ) result ( Zeff ) !! returns the Z_eff value of the valence state implicit none real ( dp ) :: Zeff integer :: i , k real ( dp ) :: Eb !! binding energy if ( trim ( Zeff_type ) == 'one' ) then Zeff = 1.0_dp else if ( trim ( Zeff_type ) == 'Eb' ) then Eb = maxval ( energy_bands (:, : n_val )) - energy_bands ( k , i ) Zeff = n_Eb * sqrt ( Eb / 1 3.6_dp ) Zeff = max ( Zeff , 1.0_dp ) else if ( trim ( Zeff_type ) == 'Eb_c' ) then Eb = - core_energy ( i ) n_Eb = core_elec_conf ( i , 2 ) Zeff = n_Eb * sqrt ( Eb / 1 3.6_dp ) Zeff = max ( Zeff , 1.0_dp ) else if ( trim ( Zeff_type ) == 'in' ) then Zeff = val_Zeff_in ( i ) end if end function end module","tags":"","loc":"sourcefile/zeff_input.f90.html"},{"title":"calc_exdm_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_cc Source Code calc_exdm_scatter_cc.f90 Source Code module calc_exdm_scatter_cc !! Holds the subroutine which calculates the binned rate for the cc calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use core_electrons use FFT_util use in_med_scr implicit none contains subroutine dme_scatter_cc_calc ( binned_rate_t ,& wfc_i ,& wfc_FT_f ,& init_id , cond_id , & n_FFT_grid ,& k_cut , & wfc_FFT_plan , Tif_FFT_plan ,& verbose ) implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G ) complex ( dp ) :: wfc_FT_f_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: T_if ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: f_G ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: k_cut integer :: init_id , cond_id integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose integer :: ki , kf integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max , q_max_FFT real ( dp ) :: omega , omega_max , Ei , Ef real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: scr integer :: q_bin_num , E_bin_num integer :: n_FFT real ( dp ) :: f_sq_val b_rate = 0.0_dp wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) T_if = ( 0.0_dp , 0.0_dp ) f_G = ( 0.0_dp , 0.0_dp ) f_sq = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) q_max_FFT = n_FFT_grid ( 1 ) * q_s_FFT Ei = core_energy ( init_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) - minval ( energy_bands (:, n_val + 1 :)) omega = Ef - Ei E_bin_num = Q_func ( omega , band_gap , E_bin_width , n_E_bins + 1 ) if ( ( E_bin_num >= E_bin_threshold ) . and . & ( Ef <= Ef_max ) ) then call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :), wfc_FT_f_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp , wfc_f ) T_if = conjg ( wfc_f ) * wfc_i f_G = ( 0.0_dp , 0.0_dp ) call dfftw_execute_dft ( Tif_fft_plan , T_if , f_G ) f_sq = abs ( f_G ) ** 2 ! particle physics do m = 1 , n_mX omega_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega < omega_max ) then q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& q_max_FFT , & mX ( m ) * v_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) + sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m < vEsc ) then g_func_val = g_func ( q_mag , v_m ) b_rate ( q_bin_num , E_bin_num , m , :, t ) = & b_rate ( q_bin_num , E_bin_num , m , :, t ) + & 2.0_dp * k_weight ( kf ) * & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if end do ! add overall constants do m = 1 , n_mX b_rate (:, :, m , :, :) = ( core_elec_conf ( init_id , 5 ) * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 2 ) * & red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * & ( 1.0_dp * n_FFT ) ** ( - 2 ) * b_rate (:, :, m , :, :) end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_cc.f90.html"},{"title":"exdm_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_cc Source Code exdm_scatter_cc.f90 Source Code module exdm_scatter_cc !! Compute the scattering rate from core to conduction states use prec use control_input use numerics_input use material_input use DFT_parameters use core_electrons use FFT_util use transition use calc_exdm_scatter_cc implicit none contains subroutine run_dme_scatter_cc ( binned_rate_t , n_tran_per_proc , DFT_input_filename , & sto_wf_filename , core_elec_config_filename , out_filename ,& proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t integer :: tran_id integer :: init_id , cond_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename integer :: n_FFT_grid ( 3 ) integer :: n_FFT integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) complex ( dp ), allocatable :: wfc_i (:, :, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) if ( verbose ) then print * , 'Starting c -> c scattering rate calculation...' print * end if ! calculation setup if ( trim ( screen_type ) /= 'numeric' ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) else if ( load_dielectric_from_file ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) end if end if call load_core_elec_config ( trim ( core_elec_config_filename ), verbose = verbose ) call load_core_sto_data ( trim ( sto_wf_filename ), verbose = verbose ) ! doubled to avoid wrapping problems n_FFT_grid ( 1 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 1 )) - minval ( in_G_grid_red (:, 1 ))) + 1 , & n_FFT_grid_input ( 1 )) n_FFT_grid ( 2 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 2 )) - minval ( in_G_grid_red (:, 2 ))) + 1 , & n_FFT_grid_input ( 2 )) n_FFT_grid ( 3 ) = max (& 2 * ( maxval ( in_G_grid_red (:, 3 )) - minval ( in_G_grid_red (:, 3 ))) + 1 , & n_FFT_grid_input ( 3 )) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) if ( verbose ) then print * , '----------------------------------------' print * , '    ---' print * , '    FFT' print * , '    ---' print * print * , '        Dimensions of FFT grid : ' print * , '        ' , n_FFT_grid print * print * , '        Number of G points in FFT grid = ' , n_FFT print * print * , '----------------------------------------' print * end if call set_fft_plan_backward_3d ( n_FFT_grid , wfc_fft_plan ) call set_fft_plan_backward_3d ( n_FFT_grid , Tif_fft_plan ) call set_sym_FFT_G_grid_xyz ( n_FFT_grid , k_red_to_xyz , verbose = verbose ) ! time calculation if ( ( proc_id == root_process ) . and . ( timer ) ) then call time_exdm_scatter_cc_calc ( DFT_input_filename , 1 , wfc_fft_plan , & Tif_fft_plan , n_FFT_grid , verbose = verbose ) end if allocate ( wfc_FT_f ( n_k , n_in_G )) allocate ( wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 ))) wfc_i = ( 0.0_dp , 0.0_dp ) ! do calculation if ( verbose ) then print * , 'Calculating transition rates...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then init_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val call calc_core_sto_wf_grid ( wfc_i , init_id , n_FFT_grid , red_to_xyz , & shift = . TRUE ., verbose = verbose ) wfc_i = sqrt ( pc_vol ) * wfc_i call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) call dme_scatter_cc_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_i , wfc_FT_f , init_id , cond_id , n_FFT_grid , n_k , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) call save_core_electrons ( out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_cc_calc ( DFT_input_filename , tran_id , wfc_fft_plan , & Tif_fft_plan , n_FFT_grid , verbose ) !! Times the c -> c scattering rate calculation use timing use mpi implicit none character ( len =* ) :: DFT_input_filename integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) integer :: tran_id integer :: n_FFT_grid ( 3 ) logical , optional :: verbose real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) complex ( dp ), allocatable :: wfc_i (:, :, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) integer :: init_id , cond_id if ( verbose ) then print * , 'Timing c -> c calculation...' print * end if allocate ( wfc_FT_f ( n_k , n_in_G )) allocate ( wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 ))) init_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val time ( 3 ) = MPI_Wtime () call calc_core_sto_wf_grid ( wfc_i , init_id , n_FFT_grid , red_to_xyz , & shift = . TRUE ., verbose = verbose ) wfc_i = sqrt ( pc_vol ) * wfc_i call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) time ( 4 ) = MPI_Wtime () call dme_scatter_cc_calc ( b_rate ,& wfc_i , wfc_FT_f , init_id , cond_id , n_FFT_grid , 1 , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) time ( 5 ) = MPI_Wtime () if ( verbose ) then print * , '----------------------------------------' print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Core WF :' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        (Total) Core WF :' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * ( time ( 4 ) - time ( 3 ))& )) print * print * , '        (TEST) Rate : ' print * , '            ' , trim ( pretty_time_format ( time ( 5 ) - time ( 4 ))) print * print * , '        (Total) Rate : ' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * n_k * ( time ( 5 ) - time ( 4 ))& )) print * print * , '        Expected run time for whole calculation :' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * ( time ( 4 ) - time ( 3 )) + n_tran_per_proc * n_k * ( time ( 5 ) - time ( 4 ))& )) print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_cc.f90.html"},{"title":"calc_exdm_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_cf Source Code calc_exdm_scatter_cf.f90 Source Code module calc_exdm_scatter_cf !! Holds the subroutine which calculates the binned rate for the cf calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use in_med_scr use Zeff_input use core_electrons implicit none contains subroutine dme_scatter_cf_calc ( binned_rate_t , init_id , log_omegas , & ki_cut , ki_angular_mesh , kf_angular_mesh , verbose ) implicit none logical , optional :: verbose real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: dRdw ( n_q_bins + 1 , 2 , n_mX , n_FDM , n_time ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) integer :: init_id real ( dp ) :: log_omegas ( 2 ) integer :: ki_cut real ( dp ) :: ki_angular_mesh (:, :) real ( dp ) :: kf_angular_mesh (:, :) real ( dp ) :: Ei , Ef , omega , log_omega real ( dp ) :: omega_1 , omega_2 , E1 , E2 real ( dp ) :: log_omega_bounds ( 2 ) real ( dp ) :: ki_vec ( 3 ), ki_mag , ki_theta , ki_phi real ( dp ) :: ki_max real ( dp ) :: jac_ki real ( dp ) :: kf_vec ( 3 ), kf_mag , kf_theta , kf_phi real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max integer :: q_bin_num real ( dp ) :: v_m , g_func_val real ( dp ) :: Zeff real ( dp ) :: fermi_val , fermi_factor real ( dp ) :: scr real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: f_sq real ( dp ) :: omega_kin_max real ( dp ) :: log_dRdw ( 2 ) real ( dp ) :: fit_params integer :: i , a , b , t , ki , kf , m , q , f , e b_rate = 0.0_dp dRdw = 0.0_dp Ei = core_energy ( init_id ) Zeff = get_val_Z_eff ( init_id , 1 ) ki_max = ki_s * Zeff * alpha_EM * m_elec do m = 1 , n_mX omega_kin_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega_kin_max > 1 0.0_dp ** log_omegas ( 1 ) ) then log_omega_bounds ( 1 ) = log_omegas ( 1 ) log_omega_bounds ( 2 ) = min ( log10 ( omega_kin_max ), log_omegas ( 2 )) do i = 1 , 2 omega = 1 0.0_dp ** log_omega_bounds ( i ) q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = mX ( m ) * v_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) Ef = Ei + omega if ( ( Ef > 0.0_dp ) . and . ( Ef > Ef_max ) ) then kf_mag = sqrt ( 2.0_dp * m_elec * Ef ) fermi_val = 2.0_dp * pi * Zeff * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do ki = 1 + n_ki - ki_cut , n_ki ki_mag = ( ki_max / ki_min ) ** (( ki - 1.0_dp ) / ( n_ki - 1.0_dp )) * ki_min jac_ki = ( 1.0_dp / n_ki ) * ki_mag ** 3 * log10 ( ki_max / ki_min ) do a = 1 , size ( ki_angular_mesh , 1 ) ki_theta = ki_angular_mesh ( a , 1 ) ki_phi = ki_angular_mesh ( a , 2 ) ki_vec ( 1 ) = ki_mag * sin ( ki_theta ) * cos ( ki_phi ) ki_vec ( 2 ) = ki_mag * sin ( ki_theta ) * sin ( ki_phi ) ki_vec ( 3 ) = ki_mag * cos ( ki_theta ) f_sq = abs ( core_sto_wf_FT ( init_id , ki_vec )) ** 2 do b = 1 , size ( kf_angular_mesh , 1 ) kf_theta = kf_angular_mesh ( b , 1 ) kf_phi = kf_angular_mesh ( b , 2 ) kf_vec ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) kf_vec ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) kf_vec ( 3 ) = kf_mag * cos ( kf_theta ) q_vec = kf_vec - ki_vec q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) scr = screening ( q_vec , omega ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m . lt . vEsc ) then g_func_val = g_func ( q_mag , v_m ) dRdw ( q_bin_num , i , m , :, t ) = dRdw ( q_bin_num , i , m , :, t ) + & fermi_factor * & F_med_sq * & g_func_val * & f_sq * & jac_ki * & m_elec * kf_mag * scr ** ( - 2 ) end if end do end if end do end do end do end if end do ! add overall constants dRdw (:, :, m , :, :) = ( core_elec_conf ( i , 5 ) * pi ) * ( rhoX / rho_T ) * & ( pc_vol ) ** ( - 1 ) * red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * mX ( m ) ** ( - 1 ) * & ( 2 * pi ) ** ( - 6 ) * ( 4 * pi ) / ( 1.0_dp * n_ki_theta * n_ki_phi ) * & ( 4 * pi ) / ( 1.0_dp * n_kf_theta * n_kf_phi ) * & dRdw (:, :, m , :, :) ! now that dRdw has been computed at the end points we need to interpolate and integrate ! to get the binned rate ! our interpolating function is dRdw = dRdw(1)*(w/w_1)**b ! This procedure is equivalent to saving dRdw and interpolating later do q = 1 , n_q_bins + 1 do t = 1 , n_time do f = 1 , n_FDM if ( ( dRdw ( q , 1 , m , f , t ) > 0.0_dp ) . and . ( dRdw ( q , 2 , m , f , t ) > 0.0_dp ) ) then log_dRdw = log10 ( dRdw ( q , :, m , f , t )) fit_params = power_law_fit ( log_omega_bounds , log_dRdw ) omega_1 = 1 0.0_dp ** log_omega_bounds ( 1 ) omega_2 = 1 0.0_dp ** log_omega_bounds ( 2 ) do e = E_bin_threshold , n_E_bins + 1 E1 = ( e - 1 ) * E_bin_width E2 = e * E_bin_width if ( ( E2 > omega_1 ) & . and . ( E1 < omega_2 ) & . and . ( E1 > 0.0_dp ) ) then b_rate ( q , e , m , f , t ) = 1 0.0_dp ** log_dRdw ( 1 ) * & integrate_power_law ( fit_params , max ( E1 , omega_1 ), & min ( E2 , omega_2 ), omega_1 ) end if end do end if end do end do end do end if end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_cf.f90.html"},{"title":"exdm_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_cf Source Code exdm_scatter_cf.f90 Source Code module exdm_scatter_cf !! Compute the scattering rate from core to free states use prec use math_mod use control_input use numerics_input use material_input use particle_physics_scatter use core_electrons use transition use Zeff_input use calc_exdm_scatter_cf contains subroutine run_dme_scatter_cf ( binned_rate_t , n_tran_per_proc , & sto_wf_filename , core_elec_config_filename , nml_input_filename , & out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) integer :: n_tran_per_proc character ( len =* ) :: sto_wf_filename character ( len =* ) :: core_elec_config_filename character ( len =* ) :: nml_input_filename character ( len =* ) :: out_filename integer :: proc_id , root_process logical , optional :: verbose integer :: tran_id , init_id , fin_id integer :: t , i , f real ( dp ) :: log_omega_min , log_omega_max real ( dp ) :: log_omega real ( dp ) :: log_omegas ( 2 ) real ( dp ), allocatable :: log_omega_list (:) real ( dp ), allocatable :: log_omega_table (:, :) real ( dp ) :: ki_angular_mesh ( n_ki_theta * n_ki_phi , 2 ) real ( dp ) :: kf_angular_mesh ( n_kf_theta * n_kf_phi , 2 ) if ( verbose ) then print * , 'Starting c -> f scattering rate calculation...' print * end if ! calculation setup call load_core_elec_config ( trim ( core_elec_config_filename ), verbose = verbose ) call load_core_sto_data ( trim ( sto_wf_filename ), verbose = verbose ) call load_Zeff_parameters ( trim ( nml_input_filename ), verbose = verbose ) ki_angular_mesh = generate_uniform_points_on_sphere ( n_ki_theta , n_ki_phi ) kf_angular_mesh = generate_uniform_points_on_sphere ( n_kf_theta , n_kf_phi ) ! do calculation ! create array of omega's that each processor will compute the transition rate ! for allocate ( log_omega_table ( n_fin , 2 )) allocate ( log_omega_list ( n_fin + 1 )) log_omega_min = log10 ( Ef_max ) log_omega_max = log10 ( 0.5_dp * v_max ** 2 * maxval ( mX )) if ( log_omega_max > log_omega_min ) then do f = 1 , n_fin + 1 log_omega = log_omega_min + ( log_omega_max - log_omega_min ) * & ( f - 1.0_dp ) / max ( n_fin + 1.0_dp - 1.0_dp , 1.0_dp ) log_omega_list ( f ) = log_omega end do do f = 1 , n_fin do i = 0 , 1 log_omega_table ( f , i + 1 ) = log_omega_list ( f + i ) end do end do if ( verbose ) then print * , 'Calculating transition rates...' print * end if ! time calculation if ( ( proc_id == root_process ) . and . ( timer ) ) then call time_exdm_scatter_cf_calc ( log_omega_table , & ki_angular_mesh , kf_angular_mesh , verbose = verbose ) end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then init_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) log_omegas = log_omega_table ( fin_id , :) call dme_scatter_cf_calc ( binned_rate_t (:, :, :, :, :, t ),& init_id , log_omegas , n_ki , ki_angular_mesh , kf_angular_mesh , verbose = verbose ) end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if else if ( verbose ) then print * , '~~~ WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * print * , '   No mass in mX is large enough to warrant the c -> f calculation' print * , '   with the specified Ef_max. Skipping c -> f calculation.' print * print * , '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * end if end if if ( proc_id == root_process ) then call save_core_electrons ( out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_cf_calc ( log_omega_table , & ki_angular_mesh , kf_angular_mesh , verbose ) !! Times the v -> f scattering rate calculation use timing use mpi implicit none real ( dp ) :: log_omega_table ( n_fin , 2 ) real ( dp ) :: log_omegas ( 2 ) real ( dp ) :: ki_angular_mesh (:, :) real ( dp ) :: kf_angular_mesh (:, :) integer :: tran_id logical , optional :: verbose real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: init_id , fin_id if ( verbose ) then print * , 'Timing c -> f calculation...' print * end if ! one of the jobs which takes longer tran_id = job_table ( 12 , n_tran_per_proc ) init_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) log_omegas = log_omega_table ( fin_id , :) time ( 3 ) = MPI_Wtime () call dme_scatter_cf_calc ( b_rate ,& init_id , log_omegas , n_ki , ki_angular_mesh , kf_angular_mesh , verbose = verbose ) time ( 4 ) = MPI_Wtime () if ( verbose ) then print * , '----------------------------------------' print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Run time : ' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        Expected run time for whole calculation :' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * ( time ( 4 ) - time ( 3 ))& )) print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_cf.f90.html"},{"title":"calc_exdm_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_vc Source Code calc_exdm_scatter_vc.f90 Source Code module calc_exdm_scatter_vc !! Holds the subroutine which calculates the binned rate for the vc calculation use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use FFT_util use in_med_scr use transition_form_factor implicit none interface dme_scatter_vc_calc module procedure dme_scatter_vc_calc_no_spin module procedure dme_scatter_vc_calc_spin end interface contains subroutine dme_scatter_vc_calc_spin ( binned_rate_t ,& wfc_FT_i , wfc_FT_f ,& val_id , cond_id , & n_FFT_grid ,& k_cut , & wfc_FFT_plan , Tif_FFT_plan ,& verbose ) !! Computes the valence to conduction scattering rate. Wave functions are 2 component spinors !! in S_z basis implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G , 2 ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G , 2 ) complex ( dp ) :: wfc_i ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_i_exp ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_f_exp ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: T_if ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: f_G ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: k_cut integer :: val_id , cond_id integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose integer :: ki , kf integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max , q_max_FFT real ( dp ) :: omega , omega_max , Ei , Ef real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: scr integer :: q_bin_num , E_bin_num integer :: n_FFT real ( dp ) :: f_sq_val complex ( dp ) :: matrix_ele ( 2 , 2 ) b_rate = 0.0_dp wfc_FT_i_exp = ( 0.0_dp , 0.0_dp ) wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_i = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) T_if = ( 0.0_dp , 0.0_dp ) f_G = ( 0.0_dp , 0.0_dp ) f_sq = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) q_max_FFT = n_FFT_grid ( 1 ) * q_s_FFT do ki = 1 , k_cut ! expand both components call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_i ( ki , :, 1 ), wfc_FT_i_exp ( 1 , :, :, :),& verbose = verbose ) call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_i ( ki , :, 2 ), wfc_FT_i_exp ( 2 , :, :, :),& verbose = verbose ) ! Fourier transform both components call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_i_exp ( 1 , :, :, :), wfc_i ( 1 , :, :, :)) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_i_exp ( 2 , :, :, :), wfc_i ( 2 , :, :, :)) Ei = energy_bands ( ki , val_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) omega = Ef - Ei E_bin_num = Q_func ( omega , band_gap , E_bin_width , n_E_bins + 1 ) if ( ( E_bin_num >= E_bin_threshold ) . and . & ( Ef <= Ef_max ) ) then ! expand both components call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :, 1 ), wfc_FT_f_exp ( 1 , :, :, :),& verbose = verbose ) call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :, 2 ), wfc_FT_f_exp ( 2 , :, :, :),& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp ( 1 , :, :, :), wfc_f ( 1 , :, :, :)) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp ( 2 , :, :, :), wfc_f ( 2 , :, :, :)) call calc_tff_vc ( f_sq , wfc_i , wfc_f , n_FFT_grid , Tif_fft_plan , verbose ) ! particle physics do m = 1 , n_mX omega_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega < omega_max ) then q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& q_max_FFT , & mX ( m ) * v_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) - k_grid_xyz ( ki , :) + sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m < vEsc ) then g_func_val = g_func ( q_mag , v_m ) b_rate ( q_bin_num , E_bin_num , m , :, t ) = & b_rate ( q_bin_num , E_bin_num , m , :, t ) + & k_weight ( ki ) * k_weight ( kf ) * & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if end do end do ! add overall constants do m = 1 , n_mX b_rate (:, :, m , :, :) = ( 2 * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 2 ) * & red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * & ( 1.0_dp * n_FFT ) ** ( - 2 ) * b_rate (:, :, m , :, :) end do binned_rate_t = b_rate end subroutine subroutine dme_scatter_vc_calc_no_spin ( binned_rate_t ,& wfc_FT_i , wfc_FT_f ,& val_id , cond_id , & n_FFT_grid ,& k_cut , & wfc_FFT_plan , Tif_FFT_plan ,& verbose ) !! Computes the valence to conduction scattering rate assuming the wave functions do not !! depend on the spin. implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) integer :: n_FFT_grid ( 3 ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) complex ( dp ) :: wfc_FT_f ( n_k , n_in_G ) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_i_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_FT_f_exp ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: T_if ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: f_G ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) real ( dp ) :: f_sq ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) integer :: k_cut integer :: val_id , cond_id integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) logical , optional :: verbose integer :: ki , kf integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max , q_max_FFT real ( dp ) :: omega , omega_max , Ei , Ef real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: scr integer :: q_bin_num , E_bin_num integer :: n_FFT real ( dp ) :: f_sq_val b_rate = 0.0_dp wfc_FT_i_exp = ( 0.0_dp , 0.0_dp ) wfc_FT_f_exp = ( 0.0_dp , 0.0_dp ) wfc_i = ( 0.0_dp , 0.0_dp ) wfc_f = ( 0.0_dp , 0.0_dp ) T_if = ( 0.0_dp , 0.0_dp ) f_G = ( 0.0_dp , 0.0_dp ) f_sq = ( 0.0_dp , 0.0_dp ) n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) q_max_FFT = n_FFT_grid ( 1 ) * q_s_FFT do ki = 1 , k_cut call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_i ( ki , :), wfc_FT_i_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_i_exp , wfc_i ) Ei = energy_bands ( ki , val_id ) do kf = 1 , k_cut Ef = energy_bands ( kf , cond_id ) omega = Ef - Ei E_bin_num = Q_func ( omega , band_gap , E_bin_width , n_E_bins + 1 ) if ( ( E_bin_num >= E_bin_threshold ) . and . & ( Ef <= Ef_max ) ) then call expand_wfc_FT_for_FFT ( n_FFT_grid , wfc_FT_f ( kf , :), wfc_FT_f_exp ,& verbose = verbose ) call dfftw_execute_dft ( wfc_fft_plan , wfc_FT_f_exp , wfc_f ) call calc_tff_vc ( f_sq , wfc_i , wfc_f , n_FFT_grid , Tif_fft_plan , verbose = . FALSE .) ! particle physics do m = 1 , n_mX omega_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega < omega_max ) then q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& q_max_FFT , & mX ( m ) * v_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) q_vec = k_grid_xyz ( kf , :) - k_grid_xyz ( ki , :) + sym_FFT_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m < vEsc ) then g_func_val = g_func ( q_mag , v_m ) b_rate ( q_bin_num , E_bin_num , m , :, t ) = & b_rate ( q_bin_num , E_bin_num , m , :, t ) + & k_weight ( ki ) * k_weight ( kf ) * & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if end do end do ! add overall constants do m = 1 , n_mX b_rate (:, :, m , :, :) = ( 2 * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 2 ) * & red_mass ( mX ( m ), m_elec ) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * & ( 1.0_dp * n_FFT ) ** ( - 2 ) * b_rate (:, :, m , :, :) end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_vc.f90.html"},{"title":"exdm_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_vc Source Code exdm_scatter_vc.f90 Source Code module exdm_scatter_vc !! Compute the scattering rate from valence to conduction states use prec use numerics_input use control_input use material_input use DFT_parameters use FFT_util use transition use calc_exdm_scatter_vc implicit none contains subroutine run_dme_scatter_vc ( binned_rate_t , n_tran_per_proc , DFT_input_filename , & out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t integer :: tran_id integer :: val_id , cond_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename integer :: n_FFT_grid ( 3 ) integer :: n_FFT integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) complex ( dp ), allocatable :: wfc_FT_i (:, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) complex ( dp ), allocatable :: wfc_FT_i_s (:, :, :) complex ( dp ), allocatable :: wfc_FT_f_s (:, :, :) if ( verbose ) then print * , 'Starting v -> c scattering rate calculation...' print * end if ! calculation setup !! only load these variables if they haven't been loaded before !! to compute the dielectric if ( trim ( screen_type ) /= 'numeric' ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) else if ( load_dielectric_from_file ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) end if end if ! doubled to avoid wrapping problems n_FFT_grid ( 1 ) = 2 * ( maxval ( in_G_grid_red (:, 1 )) - minval ( in_G_grid_red (:, 1 ))) + 1 n_FFT_grid ( 2 ) = 2 * ( maxval ( in_G_grid_red (:, 2 )) - minval ( in_G_grid_red (:, 2 ))) + 1 n_FFT_grid ( 3 ) = 2 * ( maxval ( in_G_grid_red (:, 3 )) - minval ( in_G_grid_red (:, 3 ))) + 1 n_FFT = n_FFT_grid ( 1 ) * n_FFT_grid ( 2 ) * n_FFT_grid ( 3 ) if ( verbose ) then print * , '----------------------------------------' print * , '    ---' print * , '    FFT' print * , '    ---' print * print * , '        Dimensions of FFT grid : ' print * , '        ' , n_FFT_grid print * print * , '        Number of G points in FFT grid = ' , n_FFT print * print * , '----------------------------------------' print * end if call set_fft_plan_backward_3d ( n_FFT_grid , wfc_fft_plan ) call set_fft_plan_backward_3d ( n_FFT_grid , Tif_fft_plan ) call set_sym_FFT_G_grid_xyz ( n_FFT_grid , k_red_to_xyz , verbose = verbose ) ! time calculation if ( ( proc_id == root_process ) . and . ( timer ) ) then call time_exdm_scatter_vc_calc ( DFT_input_filename , 1 , wfc_fft_plan , & Tif_fft_plan , n_FFT_grid , verbose = verbose ) end if ! do calculation if ( verbose ) then print * , 'Calculating transition rates...' print * end if if ( include_spin ) then allocate ( wfc_FT_i_s ( n_k , n_in_G , 2 )) allocate ( wfc_FT_f_s ( n_k , n_in_G , 2 )) else allocate ( wfc_FT_i ( n_k , n_in_G )) allocate ( wfc_FT_f ( n_k , n_in_G )) end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then val_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val if ( include_spin ) then call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i_s ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f_s ) call dme_scatter_vc_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_FT_i_s , wfc_FT_f_s , val_id , cond_id , n_FFT_grid , n_k , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) else call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) call dme_scatter_vc_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_FT_i , wfc_FT_f , val_id , cond_id , n_FFT_grid , n_k , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) end if end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_vc_calc ( DFT_input_filename , tran_id , wfc_fft_plan , & Tif_fft_plan , n_FFT_grid , verbose ) !! Times the v -> c scattering rate calculation use timing use mpi implicit none character ( len =* ) :: DFT_input_filename integer :: wfc_fft_plan ( 8 ) integer :: Tif_fft_plan ( 8 ) integer :: tran_id integer :: n_FFT_grid ( 3 ) logical , optional :: verbose real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) complex ( dp ), allocatable :: wfc_FT_i (:, :) complex ( dp ), allocatable :: wfc_FT_f (:, :) complex ( dp ), allocatable :: wfc_FT_i_s (:, :, :) complex ( dp ), allocatable :: wfc_FT_f_s (:, :, :) integer :: val_id , cond_id if ( verbose ) then print * , 'Timing v -> c calculation...' print * end if if ( include_spin ) then allocate ( wfc_FT_i_s ( n_k , n_in_G , 2 )) allocate ( wfc_FT_f_s ( n_k , n_in_G , 2 )) else allocate ( wfc_FT_i ( n_k , n_in_G )) allocate ( wfc_FT_f ( n_k , n_in_G )) end if val_id = tran_to_init_fin_id ( tran_id , 1 ) cond_id = tran_to_init_fin_id ( tran_id , 2 ) + n_val if ( include_spin ) then call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i_s ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f_s ) time ( 3 ) = MPI_Wtime () call dme_scatter_vc_calc ( b_rate ,& wfc_FT_i_s , wfc_FT_f_s , val_id , cond_id , n_FFT_grid , 1 , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) time ( 4 ) = MPI_Wtime () else call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) call get_in_wfc_FT ( DFT_input_filename , cond_id , wfc_FT_f ) time ( 3 ) = MPI_Wtime () call dme_scatter_vc_calc ( b_rate ,& wfc_FT_i , wfc_FT_f , val_id , cond_id , n_FFT_grid , 1 , & wfc_fft_plan , Tif_FFT_plan , verbose = verbose ) time ( 4 ) = MPI_Wtime () end if if ( verbose ) then print * , '----------------------------------------' print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Run time: ' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        Expected run time for whole calculation : ' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * n_k ** 2 * ( time ( 4 ) - time ( 3 ))& )) print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_vc.f90.html"},{"title":"calc_exdm_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_vf Source Code calc_exdm_scatter_vf.f90 Source Code module calc_exdm_scatter_vf use prec use constants use math_mod use numerics_input use material_input use particle_physics_scatter use DFT_parameters use in_med_scr use Zeff_input implicit none contains subroutine dme_scatter_vf_calc ( binned_rate_t ,& wfc_FT_i , val_id , log_omegas , k_cut , angular_mesh , & verbose ) implicit none real ( dp ) :: binned_rate_t ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) real ( dp ) :: dRdw ( n_q_bins + 1 , 2 , n_mX , n_FDM , n_time ) complex ( dp ) :: wfc_FT_i ( n_k , n_in_G ) integer :: val_id real ( dp ) :: log_omegas ( 2 ) real ( dp ) :: omega_kin_max real ( dp ) :: log_omega_bounds ( 2 ) real ( dp ) :: log_dRdw ( 2 ) integer :: k_cut real ( dp ) :: angular_mesh ( n_kf_theta * n_kf_phi , 2 ) logical , optional :: verbose integer :: i , t , m , f , q , e , g , k , a real ( dp ) :: Zeff real ( dp ) :: kf_theta , kf_phi , kf_mag real ( dp ) :: k_f ( 3 ), k_i ( 3 ) real ( dp ) :: q_min , q_max , q_mag real ( dp ) :: q_vec ( 3 ) integer :: q_bin_num real ( dp ) :: omega , Eik , Ef real ( dp ) :: E1 , E2 real ( dp ) :: omega_1 , omega_2 real ( dp ) :: fit_params real ( dp ) :: v_m , g_func_val real ( dp ) :: F_med_sq ( n_FDM ) real ( dp ) :: f_sq real ( dp ) :: scr real ( dp ) :: fermi_val , fermi_factor real ( dp ) :: log_b_rate b_rate = 0.0_dp dRdw = 0.0_dp do m = 1 , n_mX omega_kin_max = 0.5_dp * mX ( m ) * v_max ** 2 if ( omega_kin_max > 1 0.0_dp ** log_omegas ( 1 ) ) then log_omega_bounds ( 1 ) = log_omegas ( 1 ) log_omega_bounds ( 2 ) = min ( log10 ( omega_kin_max ), log_omegas ( 2 )) ! compute dRdw at the endpoints, then interpolate and integrate between to get ! binned rate do i = 1 , 2 omega = 1 0.0_dp ** log_omega_bounds ( i ) q_min = mX ( m ) * v_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = mX ( m ) * v_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) do k = 1 , k_cut Eik = energy_bands ( k , val_id ) - maxval ( energy_bands (:, : n_val )) Ef = omega + Eik if ( ( Ef . gt . 0.0_dp ) . and . ( Ef . gt . Ef_max ) ) then Zeff = get_val_Z_eff ( val_id , k ) kf_mag = sqrt ( 2 * m_elec * Ef ) fermi_val = 2.0_dp * pi * Zeff * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do a = 1 , n_kf_theta * n_kf_phi kf_theta = angular_mesh ( a , 1 ) kf_phi = angular_mesh ( a , 2 ) k_f ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) k_f ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) k_f ( 3 ) = kf_mag * cos ( kf_theta ) do g = 1 , n_in_G f_sq = wfc_FT_i ( k , g ) * conjg ( wfc_FT_i ( k , g )) k_i = k_grid_xyz ( k , :) + in_G_grid_xyz ( g , :) q_vec = k_f - k_i q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = screening ( q_vec , omega ) q_bin_num = Q_func ( q_mag , 0.0_dp , q_bin_width , n_q_bins + 1 ) do f = 1 , n_FDM F_med_sq ( f ) = F_med_sq_func ( q_mag , FDMPowerList ( f )) end do do t = 1 , n_time v_m = v_minus ( q_vec , mX ( m ), vEVecList ( t , :), omega ) if ( v_m . lt . vEsc ) then g_func_val = g_func ( q_mag , v_m ) dRdw ( q_bin_num , i , m , :, t ) = & dRdw ( q_bin_num , i , m , :, t ) + & k_weight ( k ) * & f_sq * & fermi_factor * & g_func_val * F_med_sq * & 2.0_dp * m_elec * kf_mag * & scr ** ( - 2 ) end if end do end if end do end do end if end do end do ! overall constants dRdw (:, :, m , :, :) = ( 2 * pi ) * ( rhoX / rho_T ) * ( 2 * pc_vol ) ** ( - 1 ) * (( 4 * pi ) / ( n_kf_theta * n_kf_phi * 1.0_dp )) * & red_mass ( m_elec , mX ( m )) ** ( - 2 ) * ( mX ( m )) ** ( - 1 ) * ( 2 * pi ) ** ( - 3 ) * dRdw (:, :, m , :, :) ! now that dRdw has been computed at the end points we need to interpolate and integrate ! to get the binned rate ! our interpolating function is dRdw = dRdw(1)*(w/w_1)**b ! This procedure is equivalent to saving dRdw and interpolating later do q = 1 , n_q_bins + 1 do t = 1 , n_time do f = 1 , n_FDM if ( ( dRdw ( q , 1 , m , f , t ) > 0.0_dp ) . and . ( dRdw ( q , 2 , m , f , t ) > 0.0_dp ) ) then log_dRdw = log10 ( dRdw ( q , :, m , f , t )) fit_params = power_law_fit ( log_omega_bounds , log_dRdw ) omega_1 = 1 0.0_dp ** log_omega_bounds ( 1 ) omega_2 = 1 0.0_dp ** log_omega_bounds ( 2 ) do e = E_bin_threshold , n_E_bins + 1 E1 = ( e - 1 ) * E_bin_width E2 = e * E_bin_width if ( ( E2 > omega_1 ) & . and . ( E1 < omega_2 ) & . and . ( E1 > 0.0_dp ) ) then b_rate ( q , e , m , f , t ) = 1 0.0_dp ** log_dRdw ( 1 ) * & integrate_power_law ( fit_params , max ( E1 , omega_1 ), & min ( E2 , omega_2 ), omega_1 ) end if end do end if end do end do end do end if end do binned_rate_t = b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_vf.f90.html"},{"title":"exdm_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_vf Source Code exdm_scatter_vf.f90 Source Code module exdm_scatter_vf !! Compute the scattering rate from valence to free states use prec use math_mod use control_input use numerics_input use material_input use DFT_parameters use particle_physics_scatter use transition use Zeff_input use calc_exdm_scatter_vf implicit none contains subroutine run_dme_scatter_vf ( binned_rate_t , n_tran_per_proc , DFT_input_filename ,& nml_input_filename , out_filename , proc_id , root_process , verbose ) implicit none real ( dp ) :: binned_rate_t (:, :, :, :, :, :) logical , optional :: verbose integer :: proc_id , root_process integer :: n_tran_per_proc integer :: t , f , i integer :: tran_id integer :: val_id , fin_id character ( len =* ) :: DFT_input_filename character ( len =* ) :: out_filename character ( len =* ) :: nml_input_filename complex ( dp ), allocatable :: wfc_FT_i (:, :) real ( dp ) :: angular_mesh ( n_kf_theta * n_kf_phi , 2 ) real ( dp ), allocatable :: log_omega_table (:, :) real ( dp ), allocatable :: log_omega_list (:) real ( dp ) :: log_omega_min , log_omega_max real ( dp ) :: log_omega real ( dp ) :: log_omegas ( 2 ) if ( verbose ) then print * , 'Starting v -> f scattering rate calculation...' print * end if ! calculation setup !! only load these variables if they haven't been loaded before !! to compute the dielectric if ( trim ( screen_type ) /= 'numeric' ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) else if ( load_dielectric_from_file ) then call load_DFT_parameters ( DFT_input_filename , verbose = verbose ) call do_scissor_correction ( band_gap , verbose = verbose ) end if end if call load_Zeff_parameters ( trim ( nml_input_filename ), verbose = verbose ) angular_mesh = generate_uniform_points_on_sphere ( n_kf_theta , n_kf_phi ) allocate ( wfc_FT_i ( n_k , n_in_G )) ! create array of omega's that each processor will compute the transition rate ! for allocate ( log_omega_table ( n_fin , 2 )) allocate ( log_omega_list ( n_fin + 1 )) log_omega_min = log10 ( Ef_max ) log_omega_max = log10 ( 0.5_dp * v_max ** 2 * maxval ( mX )) if ( log_omega_max > log_omega_min ) then do f = 1 , n_fin + 1 log_omega = log_omega_min + ( log_omega_max - log_omega_min ) * & ( f - 1.0_dp ) / max ( n_fin + 1.0_dp - 1.0_dp , 1.0_dp ) log_omega_list ( f ) = log_omega end do do f = 1 , n_fin do i = 0 , 1 log_omega_table ( f , i + 1 ) = log_omega_list ( f + i ) end do end do ! time calculation if ( ( proc_id == root_process ) . and . ( timer ) ) then call time_exdm_scatter_vf_calc ( DFT_input_filename , 1 , log_omega_table , & angular_mesh , verbose = verbose ) end if if ( verbose ) then print * , 'Calculating transition rates...' print * end if do t = 1 , n_tran_per_proc tran_id = job_table ( proc_id + 1 , t ) if ( tran_id . ne . 0 ) then val_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) log_omegas = log_omega_table ( fin_id , :) call dme_scatter_vf_calc ( binned_rate_t (:, :, :, :, :, t ),& wfc_FT_i , val_id , log_omegas , n_k , angular_mesh , verbose = verbose ) end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if else if ( verbose ) then print * , '~~~ WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * print * , '    No mass in mX is large enough to warrant the v -> f calculation' print * , '    with the specified Ef_max. Skipping v -> f calculation.' print * print * , '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~' print * end if end if if ( proc_id == root_process ) then call save_DFT_parameters ( out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_vf_calc ( DFT_input_filename , tran_id , log_omega_table , & angular_mesh , verbose ) !! Times the v -> f scattering rate calculation use timing use mpi implicit none real ( dp ) :: log_omega_table ( n_fin , 2 ) real ( dp ) :: log_omegas ( 2 ) real ( dp ) :: angular_mesh ( n_kf_theta * n_kf_phi , 2 ) character ( len =* ) :: DFT_input_filename integer :: tran_id logical , optional :: verbose real ( dp ) :: b_rate ( n_q_bins + 1 , n_E_bins + 1 , n_mX , n_FDM , n_time ) complex ( dp ), allocatable :: wfc_FT_i (:, :) integer :: val_id , fin_id if ( verbose ) then print * , 'Timing v -> f calculation...' print * end if allocate ( wfc_FT_i ( n_k , n_in_G )) val_id = tran_to_init_fin_id ( tran_id , 1 ) fin_id = tran_to_init_fin_id ( tran_id , 2 ) call get_in_wfc_FT ( DFT_input_filename , val_id , wfc_FT_i ) log_omegas = log_omega_table ( fin_id , :) time ( 3 ) = MPI_Wtime () call dme_scatter_vf_calc ( b_rate ,& wfc_FT_i , val_id , log_omegas , 1 , angular_mesh , verbose = verbose ) time ( 4 ) = MPI_Wtime () if ( verbose ) then print * , '----------------------------------------' print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Run time : ' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        Expected run time for whole calculation :' print * , '            ' , trim ( pretty_time_format (& n_tran_per_proc * n_k * ( time ( 4 ) - time ( 3 ))& )) print * print * , '----------------------------------------' print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_vf.f90.html"},{"title":"print_control – EXCEED-DM","text":"public subroutine print_control(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_control.html"},{"title":"load_control – EXCEED-DM","text":"public subroutine load_control(filename, verbose) Loads the control variables Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_control.html"},{"title":"core_sto_wf – EXCEED-DM","text":"public function core_sto_wf(core_state_idx, x_vec) result(val) Core wave function Units : eV&#94;(3/2)\n avoid |x| = 0 problems Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_vec (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf.html"},{"title":"core_sto_wf_FT – EXCEED-DM","text":"public function core_sto_wf_FT(core_state_idx, k_vec) result(val) Fourier transform of the core wave function Units : eV&#94;(-3/2)\n avoid |k| = 0 problems Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_vec (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_ft.html"},{"title":"core_sto_wf_radial – EXCEED-DM","text":"public function core_sto_wf_radial(core_state_idx, x_mag) result(val) Radial part of the total core wave function, summed over \n the individual sto_wf_radial Units : eV&#94;(3/2) Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_mag Return Value real(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_radial.html"},{"title":"core_sto_wf_FT_radial – EXCEED-DM","text":"public function core_sto_wf_FT_radial(core_state_idx, k_mag) result(chi) Radial part of the total Fourier transformed core wave function, summed over \n the individual sto_wf_FT_radial Units : eV&#94;(-3/2) Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/core_sto_wf_ft_radial.html"},{"title":"sto_wf_radial – EXCEED-DM","text":"public function sto_wf_radial(n, norm, Z, x_mag) result(val) Radial part of the Slater type orbital (STO) wave function Units : eV&#94;(3/2) Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: x_mag Return Value real(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_radial.html"},{"title":"sto_wf_FT_radial – EXCEED-DM","text":"public function sto_wf_FT_radial(n, l, norm, Z, k_mag) result(val) Radial part of the fourier transform of a Slater type orbital (STO) wave function sto_wf_FT = int d&#94;3x sto_wf e&#94;(-ikr)\n           = (sto_wf_FT_radial) * sph_harmonic(k hat) Reference : https://en.wikipedia.org/wiki/Slater-type_orbital Units : eV&#94;(-3/2) Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_ft_radial.html"},{"title":"get_sto_dataset_str – EXCEED-DM","text":"public function get_sto_dataset_str(Z, n, l) result(dset_name) Returns the name of the dataset for nth element in the\n core electron configuration Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Contents None","tags":"","loc":"proc/get_sto_dataset_str.html"},{"title":"save_core_electrons – EXCEED-DM","text":"public subroutine save_core_electrons(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_core_electrons.html"},{"title":"calc_core_sto_wf_grid – EXCEED-DM","text":"public subroutine calc_core_sto_wf_grid(core_wfc, core_state_idx, n_grid, red_to_xyz, shift, k_vec_in, s_cut_in, verbose) computes the core wave functions on a grid, summed over the closest unit cells if shift == T : x_shift = x_pos_red (equilibrium position)\n else: x_shift = 0\n core_sto_wf_grid(x) = sum_s core_sto_wf(x - x_shift + s) where x_i is the atomic equilibrium position Arguments Type Intent Optional Attributes Name complex(kind=dp) :: core_wfc (n_grid(1),n_grid(2),n_grid(3)) integer :: core_state_idx integer :: n_grid (3) Number of grid points in reduced x coordinates real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: s_cut_in logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_core_sto_wf_grid.html"},{"title":"load_core_elec_config – EXCEED-DM","text":"public subroutine load_core_elec_config(filename, verbose) Reads the core electron configuration file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_core_elec_config.html"},{"title":"print_core_elec_config – EXCEED-DM","text":"public subroutine print_core_elec_config(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/print_core_elec_config.html"},{"title":"load_core_sto_data – EXCEED-DM","text":"public subroutine load_core_sto_data(filename, verbose) Reads the sto wf file to get the relevant\n coefficients for the electron configuration\n specified in the core_elec_conf get the relevant data for each core state Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_core_sto_data.html"},{"title":"print_sto_data – EXCEED-DM","text":"public subroutine print_sto_data(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_sto_data.html"},{"title":"in_wfc_at_single_pt – EXCEED-DM","text":"public function in_wfc_at_single_pt(band_num, x0_red, in_wfc_FT) result(wfc) returns the wave function evaluated at a point in\n reduced coordinates at a single point av_wfc(x0)_k = sum_G e&#94;(i G.x0) wfc(G)_k Arguments Type Intent Optional Attributes Name integer :: band_num real(kind=dp) :: x0_red (3) complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Return Value complex(kind=dp)\n  (n_k) Contents None","tags":"","loc":"proc/in_wfc_at_single_pt.html"},{"title":"get_w_max – EXCEED-DM","text":"public function get_w_max(i) result(w_max) Returns the maximum energy transfer allowed from valence state i Arguments Type Intent Optional Attributes Name integer :: i Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_w_max.html"},{"title":"save_DFT_parameters – EXCEED-DM","text":"public subroutine save_DFT_parameters(filename, verbose) Saves some of the DFT input variables to filename Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_dft_parameters.html"},{"title":"load_DFT_parameters – EXCEED-DM","text":"public subroutine load_DFT_parameters(filename, verbose) Loads the DFT input file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_dft_parameters.html"},{"title":"check_DFT_parameters – EXCEED-DM","text":"public subroutine check_DFT_parameters(verbose) Check the values of of the input file to make sure they make sense Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/check_dft_parameters.html"},{"title":"print_DFT_parameters – EXCEED-DM","text":"public subroutine print_DFT_parameters(filename, verbose) Prints variables defined in this moudle Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/print_dft_parameters.html"},{"title":"get_in_wfc_FT_no_spin – EXCEED-DM","text":"public subroutine get_in_wfc_FT_no_spin(filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:) Bloch wave functions in reciprocal space Contents None","tags":"","loc":"proc/get_in_wfc_ft_no_spin.html"},{"title":"get_in_wfc_FT_spin – EXCEED-DM","text":"public subroutine get_in_wfc_FT_spin(filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G, 2] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_{i, k, G, s}, where s is the spin index Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:,:) Bloch wave functions in reciprocal space Contents None","tags":"","loc":"proc/get_in_wfc_ft_spin.html"},{"title":"expand_wfc_FT_for_FFT – EXCEED-DM","text":"public subroutine expand_wfc_FT_for_FFT(n_grid, wfc_FT, wfc_FT_exp, verbose) Uses FFT_util The Fourier components will generally not be defined on a\n uniform grid needed for an FFT. This subroutine puts the \n values of the Bloch coefficients in the correct place Arguments Type Intent Optional Attributes Name integer :: n_grid (3) complex(kind=dp) :: wfc_FT (n_in_G) complex(kind=dp) :: wfc_FT_exp (n_grid(1),n_grid(2),n_grid(3)) logical, optional :: verbose Contents None","tags":"","loc":"proc/expand_wfc_ft_for_fft.html"},{"title":"get_PW_cutoffs – EXCEED-DM","text":"public subroutine get_PW_cutoffs(verbose) Calculate the plane wave expansion parameters Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/get_pw_cutoffs.html"},{"title":"do_scissor_correction – EXCEED-DM","text":"public subroutine do_scissor_correction(band_gap, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: band_gap logical, optional :: verbose Contents None","tags":"","loc":"proc/do_scissor_correction.html"},{"title":"get_in_wfc_FT – EXCEED-DM","text":"public interface get_in_wfc_FT Contents Module Procedures get_in_wfc_FT_no_spin get_in_wfc_FT_spin Module Procedures public subroutine get_in_wfc_FT_no_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:) Bloch wave functions in reciprocal space public subroutine get_in_wfc_FT_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G, 2] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_{i, k, G, s}, where s is the spin index Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:,:) Bloch wave functions in reciprocal space","tags":"","loc":"interface/get_in_wfc_ft.html"},{"title":"get_sym_FFT_G_grid_red – EXCEED-DM","text":"public function get_sym_FFT_G_grid_red(n_grid, G_ind_vec, verbose) result(G_red) Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_ind_vec (3) logical, optional :: verbose Return Value integer\n  (3) Contents None","tags":"","loc":"proc/get_sym_fft_g_grid_red.html"},{"title":"get_sym_FFT_G_grid_xyz – EXCEED-DM","text":"public function get_sym_FFT_G_grid_xyz(n_grid, G_ind_vec, k_red_to_xyz, verbose) result(G_xyz) Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_ind_vec (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp)\n  (3) Contents None","tags":"","loc":"proc/get_sym_fft_g_grid_xyz.html"},{"title":"set_sym_FFT_G_grid_xyz – EXCEED-DM","text":"public subroutine set_sym_FFT_G_grid_xyz(n_grid, k_red_to_xyz, verbose) Symmetric FFT grid. Standard convention for FFTs is to compute for frequencies 0 -> N-1. \n This subroutine creates a map which takes the larger half of the positive\n frequencies and maps then back to negative values, for a symmetric G grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Contents None","tags":"","loc":"proc/set_sym_fft_g_grid_xyz.html"},{"title":"set_fft_plan_forward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_forward_3d(n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_forward_3d.html"},{"title":"set_fft_plan_backward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_backward_3d(n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_backward_3d.html"},{"title":"G_red_to_FFT_G_grid_index – EXCEED-DM","text":"public subroutine G_red_to_FFT_G_grid_index(n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \n grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3) Contents None","tags":"","loc":"proc/g_red_to_fft_g_grid_index.html"},{"title":"print_io – EXCEED-DM","text":"public subroutine print_io(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_io.html"},{"title":"load_io – EXCEED-DM","text":"public subroutine load_io(filename, verbose) Loads the io namelist Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_io.html"},{"title":"create_output_file – EXCEED-DM","text":"public recursive subroutine create_output_file(filename, overwrite_output, verbose) Uses hdf5 h5lt prec Creates the output file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical :: overwrite_output logical, optional :: verbose Contents None","tags":"","loc":"proc/create_output_file.html"},{"title":"print_material – EXCEED-DM","text":"public subroutine print_material(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_material.html"},{"title":"load_material – EXCEED-DM","text":"public subroutine load_material(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_material.html"},{"title":"save_material – EXCEED-DM","text":"public subroutine save_material(filename, verbose) Saves the material properties Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_material.html"},{"title":"set_job_table – EXCEED-DM","text":"public subroutine set_job_table(n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose Contents None","tags":"","loc":"proc/set_job_table.html"},{"title":"save_absorption_input – EXCEED-DM","text":"public subroutine save_absorption_input(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_absorption_input.html"},{"title":"print_absorption_input – EXCEED-DM","text":"public subroutine print_absorption_input(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_absorption_input.html"},{"title":"load_absorption_input – EXCEED-DM","text":"public subroutine load_absorption_input(filename, verbose) Load the absorption inputs Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_absorption_input.html"},{"title":"compute_self_energies – EXCEED-DM","text":"public subroutine compute_self_energies(nml_filename, tran_form, tran_form_vec, omega_iipk, n_init, n_fin, n_k, n_proc, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: nml_filename complex(kind=dp) :: tran_form (n_init,n_fin,n_k) complex(kind=dp) :: tran_form_vec (3,n_init,n_fin,n_k) real(kind=dp) :: omega_iipk (n_init,n_fin,n_k) integer :: n_init integer :: n_fin integer :: n_k integer :: n_proc integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/compute_self_energies.html"},{"title":"save_self_energies – EXCEED-DM","text":"public subroutine save_self_energies(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_self_energies.html"},{"title":"calc_pi_vv – EXCEED-DM","text":"public subroutine calc_pi_vv(pi_vv, tran_form_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vv (n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) real(kind=dp) :: omega_iipk_t (n_k) Contents None","tags":"","loc":"proc/calc_pi_vv.html"},{"title":"calc_pi_11_mat – EXCEED-DM","text":"public subroutine calc_pi_11_mat(pi_11_mat, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k) Contents None","tags":"","loc":"proc/calc_pi_11_mat.html"},{"title":"calc_pi_v1 – EXCEED-DM","text":"public subroutine calc_pi_v1(pi_v1, tran_form_t, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v1 (3,n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k) Contents None","tags":"","loc":"proc/calc_pi_v1.html"},{"title":"calc_pi_1v – EXCEED-DM","text":"public subroutine calc_pi_1v(pi_1v, tran_form_t, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1v (3,n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k) Contents None","tags":"","loc":"proc/calc_pi_1v.html"},{"title":"run_dme_absorption – EXCEED-DM","text":"public subroutine run_dme_absorption(proc_id, root_process, out_filename, nml_filename, DFT_input_filename, n_proc, verbose) Absorption rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename integer :: n_proc logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_absorption.html"},{"title":"save_abs_rate – EXCEED-DM","text":"public subroutine save_abs_rate(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_abs_rate.html"},{"title":"save_tran_form – EXCEED-DM","text":"public subroutine save_tran_form(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_tran_form.html"},{"title":"update_tran_form – EXCEED-DM","text":"public subroutine update_tran_form(tran_form_t, tran_form_vec_t, omega_iipk_t, proc_id, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_t (n_tran_per_proc,n_k) complex(kind=dp) :: tran_form_vec_t (3,n_tran_per_proc,n_k) real(kind=dp) :: omega_iipk_t (n_tran_per_proc,n_k) integer :: proc_id logical, optional :: verbose Contents None","tags":"","loc":"proc/update_tran_form.html"},{"title":"mb_vel_distribution – EXCEED-DM","text":"public function mb_vel_distribution(v_vec, boost_vec_in) result(mb_val) Maxwell boltzmann distribution, boosted with boost_vec Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_vec (3) real(kind=dp), optional :: boost_vec_in (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/mb_vel_distribution.html"},{"title":"print_particle_physics_abs – EXCEED-DM","text":"public subroutine print_particle_physics_abs(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_particle_physics_abs.html"},{"title":"load_particle_physics_abs – EXCEED-DM","text":"public subroutine load_particle_physics_abs(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_particle_physics_abs.html"},{"title":"check_mb_dist_normalization – EXCEED-DM","text":"public subroutine check_mb_dist_normalization(n_v_mag, n_v_theta, n_v_phi, boost_vec_in, verbose) make sure the mb distribution integrates to 1 good indicator of whether the mesh is large enough to integrate over Arguments Type Intent Optional Attributes Name integer :: n_v_mag integer :: n_v_theta integer :: n_v_phi real(kind=dp), optional :: boost_vec_in (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/check_mb_dist_normalization.html"},{"title":"calc_tran_form – EXCEED-DM","text":"public subroutine calc_tran_form(tran_form, tran_form_vec, omega_k, val_id, cond_id, wfc_FT_i, wfc_FT_f, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form (n_k) complex(kind=dp) :: tran_form_vec (3,n_k) real(kind=dp) :: omega_k (n_k) integer :: val_id integer :: cond_id complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_tran_form.html"},{"title":"calc_rate_ps – EXCEED-DM","text":"public subroutine calc_rate_ps(pi_11_mat, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_ps.html"},{"title":"calc_rate_scalar – EXCEED-DM","text":"public subroutine calc_rate_scalar(pi_11_mat, pi_1v, pi_v1, pi_vv, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) complex(kind=dp) :: pi_1v (3,n_omega,n_widths) complex(kind=dp) :: pi_v1 (3,n_omega,n_widths) complex(kind=dp) :: pi_vv (n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_scalar.html"},{"title":"calc_rate_vector – EXCEED-DM","text":"public subroutine calc_rate_vector(pi_11_mat, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_vector.html"},{"title":"pauli_spin_matrix – EXCEED-DM","text":"public function pauli_spin_matrix(i) result(mat) Returns the ith Pauli spin matrix. Assume 0th Pauli matrix is the identity Arguments Type Intent Optional Attributes Name integer :: i Return Value complex(kind=dp)\n  (2,2) Contents None","tags":"","loc":"proc/pauli_spin_matrix.html"},{"title":"integrate_power_law – EXCEED-DM","text":"public function integrate_power_law(b, x1, x2, x_s) result(integral) = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy\n = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) The reason this function is non-trivial is because evaluating x**(b + 1)\n when b is large can be problematic. Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) Contents None","tags":"","loc":"proc/integrate_power_law.html"},{"title":"power_law_fit – EXCEED-DM","text":"public function power_law_fit(log_x_pts, log_y_pts) result(fit_params) Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x fit_params = [a, b] Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/power_law_fit.html"},{"title":"generate_uniform_points_on_sphere – EXCEED-DM","text":"public function generate_uniform_points_on_sphere(n_theta, n_phi) result(angular_mesh) Generates an (n_thata*n_phi, 2) list of points which are uniformly \n distributed on the sphere Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) Contents None","tags":"","loc":"proc/generate_uniform_points_on_sphere.html"},{"title":"Q_func – EXCEED-DM","text":"public function Q_func(x, a, b, Q_max) result(Q) Places x in an appropriate bin Q = min(Q_max, 1 + floor((x - a)/b)) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer Contents None","tags":"","loc":"proc/q_func.html"},{"title":"factorial – EXCEED-DM","text":"public function factorial(n) result(fact) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer Contents None","tags":"","loc":"proc/factorial.html"},{"title":"sph_harmonic – EXCEED-DM","text":"public recursive function sph_harmonic(l, m, theta, phi) result(y_lm) Spherical harmonic function with phase convention identical\n to Mathematica Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sph_harmonic.html"},{"title":"get_phi – EXCEED-DM","text":"public function get_phi(n_hat) result(phi) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_phi.html"},{"title":"get_theta – EXCEED-DM","text":"public function get_theta(n_hat) result(theta) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_theta.html"},{"title":"pretty_time_format – EXCEED-DM","text":"public function pretty_time_format(t) result(time_str) Fills time_str with a nicely formatted version of time Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512) Contents None","tags":"","loc":"proc/pretty_time_format.html"},{"title":"check_dielectric_memory – EXCEED-DM","text":"public subroutine check_dielectric_memory(verbose) Checks to see if the dielectric is going to take up too\n much memory. Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/check_dielectric_memory.html"},{"title":"run_dielectric_calc – EXCEED-DM","text":"public subroutine run_dielectric_calc(nml_filename, filename, DFT_input_filename, proc_id, root_process, n_proc, verbose) Compute the dielectric binned in energy and momentum transfer. load inputs Don't need this here, get G vector from function in FFT_util.\n Less than ideal because we don't precompute the G vectors, but \n we avoid reallocating the array in FFT_util twice. time calculation? hard part of calculation starts here allocate memory factor of 1 in the dielectric formula\n initialize variables\n do calculation for each job only compute what the processor should be\n computing\n do the calculation for an individual job collect and sum results from all the processors, MPI part send to main processor\n add the main processors contribution\n receive the other processors contributions\n save dielectric data Arguments Type Intent Optional Attributes Name character(len=*) :: nml_filename character(len=*) :: filename character(len=*) :: DFT_input_filename integer :: proc_id integer :: root_process integer :: n_proc logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dielectric_calc.html"},{"title":"compute_dielectric – EXCEED-DM","text":"public subroutine compute_dielectric(di, val_id, cond_id, wfc_FT_i, wfc_FT_f, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, n_q_grid, q_grid_min, n_k_vec, verbose) Compute the contribution to the dimensionless dielectric\n from a given i -> f transition. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) integer :: val_id integer :: cond_id complex(kind=dp) :: wfc_FT_i (:,:) complex(kind=dp) :: wfc_FT_f (:,:) integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_q_grid (3) real(kind=dp) :: q_grid_min (3) integer :: n_k_vec (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/compute_dielectric.html"},{"title":"save_dielectric – EXCEED-DM","text":"public subroutine save_dielectric(filename, verbose) Save the computed dielectric to 'filename'. Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_dielectric.html"},{"title":"di_width_func – EXCEED-DM","text":"public function di_width_func(omega) result(delta) Parameterization of the electron lifetime/width. Arguments Type Intent Optional Attributes Name real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/di_width_func.html"},{"title":"print_dielectric_input – EXCEED-DM","text":"public subroutine print_dielectric_input(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_dielectric_input.html"},{"title":"load_dielectric_input – EXCEED-DM","text":"public subroutine load_dielectric_input(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_dielectric_input.html"},{"title":"define_q_grid – EXCEED-DM","text":"public subroutine define_q_grid(q_max, k_red_to_xyz, n_q_grid, q_grid_min, n_k_vec, n_FFT_grid, verbose) q = k' - k + G Goes through all possible q's and finds ones which have |q| < q_max. From this list find :\n     N_q_grid(i) = N_k(i) x ( max(q&#94;red)_i - min(q&#94;red)_i ) q_grid_min = min(q&#94;red)_i so that given q_red, the unique index in the q_grid is given by\n     index = [1, 1, 1] + n_k x [ q_red - q_grid_min ] Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_max real(kind=dp) :: k_red_to_xyz (3,3) integer :: n_q_grid (3) real(kind=dp) :: q_grid_min (3) integer :: n_k_vec (3) Might have to be input by hand right now, should add\n to DFT_input file integer :: n_FFT_grid (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/define_q_grid.html"},{"title":"di_set_job_table – EXCEED-DM","text":"public subroutine di_set_job_table(n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose Contents None","tags":"","loc":"proc/di_set_job_table.html"},{"title":"run_dme_scatter – EXCEED-DM","text":"public subroutine run_dme_scatter(proc_id, root_process, out_filename, nml_filename, DFT_input_filename, sto_wf_filename, core_elec_config_filename, n_proc, save_binned_rate_if, verbose) Scattering rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename integer :: n_proc logical :: save_binned_rate_if logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter.html"},{"title":"update_rates – EXCEED-DM","text":"public subroutine update_rates(binned_rate_t, proc_id) updates all the rate arrays with the output \n of a single processors results Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time,n_tran_per_proc) integer :: proc_id Contents None","tags":"","loc":"proc/update_rates.html"},{"title":"save_rates – EXCEED-DM","text":"public subroutine save_rates(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_rates.html"},{"title":"screening – EXCEED-DM","text":"public function screening(q_vec, omega) result(scr) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/screening.html"},{"title":"model_dielectric – EXCEED-DM","text":"public function model_dielectric(q_vec, omega, e0, q_tf, alpha, omega_p) result(di) Analytic form of the dielectric function\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega real(kind=dp) :: e0 real(kind=dp) :: q_tf real(kind=dp) :: alpha real(kind=dp) :: omega_p Return Value real(kind=dp) Contents None","tags":"","loc":"proc/model_dielectric.html"},{"title":"load_scr_dielectric – EXCEED-DM","text":"public subroutine load_scr_dielectric(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_scr_dielectric.html"},{"title":"print_in_med – EXCEED-DM","text":"public subroutine print_in_med(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_in_med.html"},{"title":"load_in_med_scr – EXCEED-DM","text":"public subroutine load_in_med_scr(filename, dielectric_filename, DFT_input_filename, proc_id, root_process, n_proc, verbose) allocate screen_mat\n For some reason this does not work when load_dielectric_from_file is FALSE.\n When load_dielectric_from_file = TRUE all the processes\n open and read the file as expected. Seems like a file \n permission issue with HDF5. Workaround : read by the main processor then broadcast\n the data to the other ones Arguments Type Intent Optional Attributes Name character(len=*) :: filename character(len=*) :: dielectric_filename character(len=*) :: DFT_input_filename integer :: proc_id integer :: root_process integer :: n_proc logical, optional :: verbose Contents None","tags":"","loc":"proc/load_in_med_scr.html"},{"title":"save_in_med_scr – EXCEED-DM","text":"public subroutine save_in_med_scr(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_in_med_scr.html"},{"title":"load_numerics – EXCEED-DM","text":"public subroutine load_numerics(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_numerics.html"},{"title":"print_numerics – EXCEED-DM","text":"public subroutine print_numerics(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_numerics.html"},{"title":"save_numerics – EXCEED-DM","text":"public subroutine save_numerics(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_numerics.html"},{"title":"v_minus – EXCEED-DM","text":"public function v_minus(q_vec, mX, vE_vec, omega) result(v_m) v_- function v_- = (1/q)| q_vec . vE + q&#94;2/mX + w | Note that we will explicitly check that this value is < v_Esc so that \n the g function is always > 0 Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/v_minus.html"},{"title":"g_func – EXCEED-DM","text":"public function g_func(q, v_m) result(g_fun) Kinematic function : g_func = 2 pi int d&#94;3v f_chi(v) delta(w - w_q) Units : eV&#94;(-1) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m Return Value real(kind=dp) Contents None","tags":"","loc":"proc/g_func.html"},{"title":"red_mass – EXCEED-DM","text":"public function red_mass(m1, m2) result(mu) Reduced mass Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) Contents None","tags":"","loc":"proc/red_mass.html"},{"title":"F_med_sq_func – EXCEED-DM","text":"public function F_med_sq_func(q_mag, power) result(F_med_sq_val) Mediator for factor squared Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp) Contents None","tags":"","loc":"proc/f_med_sq_func.html"},{"title":"print_particle_physics_scatter – EXCEED-DM","text":"public subroutine print_particle_physics_scatter(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_particle_physics_scatter.html"},{"title":"load_particle_physics_scatter – EXCEED-DM","text":"public subroutine load_particle_physics_scatter(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_particle_physics_scatter.html"},{"title":"save_particle_physics_scatter – EXCEED-DM","text":"public subroutine save_particle_physics_scatter(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_particle_physics_scatter.html"},{"title":"set_mX – EXCEED-DM","text":"public subroutine set_mX(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_mx.html"},{"title":"set_g_func_parameters – EXCEED-DM","text":"public subroutine set_g_func_parameters() Arguments None Contents None","tags":"","loc":"proc/set_g_func_parameters.html"},{"title":"set_FDM_powers – EXCEED-DM","text":"public subroutine set_FDM_powers(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_fdm_powers.html"},{"title":"set_time_vE_vec – EXCEED-DM","text":"public subroutine set_time_vE_vec(verbose) Arguments Type Intent Optional Attributes Name logical :: verbose Contents None","tags":"","loc":"proc/set_time_ve_vec.html"},{"title":"print_tff_input – EXCEED-DM","text":"public subroutine print_tff_input(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_tff_input.html"},{"title":"load_tff_input – EXCEED-DM","text":"public subroutine load_tff_input(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_tff_input.html"},{"title":"calc_tff_vc_spin – EXCEED-DM","text":"public subroutine calc_tff_vc_spin(TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Uses DFT_parameters math_mod Compute the tff for the valence to conduction calculation TFF = FFT( ) FFT( ) Dim : [ n_FFT_grid ] Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_tff_vc_spin.html"},{"title":"calc_tff_vc_no_spin – EXCEED-DM","text":"public subroutine calc_tff_vc_no_spin(TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Uses DFT_parameters Compute the tff for the valence to conduction calculation TFF = FFT( ) FFT( ) Dim : [ n_FFT_grid ] Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_tff_vc_no_spin.html"},{"title":"calc_tff_vc – EXCEED-DM","text":"public interface calc_tff_vc Contents Module Procedures calc_tff_vc_no_spin calc_tff_vc_spin Module Procedures public subroutine calc_tff_vc_no_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_vc_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose","tags":"","loc":"interface/calc_tff_vc.html"},{"title":"get_val_Z_eff – EXCEED-DM","text":"public function get_val_Z_eff(i, k) result(Zeff) returns the Z_eff value of the valence state Arguments Type Intent Optional Attributes Name integer :: i integer :: k Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_val_z_eff.html"},{"title":"print_Zeff – EXCEED-DM","text":"public subroutine print_Zeff(verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose Contents None","tags":"","loc":"proc/print_zeff.html"},{"title":"load_Zeff_parameters – EXCEED-DM","text":"public subroutine load_Zeff_parameters(filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_zeff_parameters.html"},{"title":"dme_scatter_cc_calc – EXCEED-DM","text":"public subroutine dme_scatter_cc_calc(binned_rate_t, wfc_i, wfc_FT_f, init_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: init_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_cc_calc.html"},{"title":"run_dme_scatter_cc – EXCEED-DM","text":"public subroutine run_dme_scatter_cc(binned_rate_t, n_tran_per_proc, DFT_input_filename, sto_wf_filename, core_elec_config_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_cc.html"},{"title":"time_exdm_scatter_cc_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_cc_calc(DFT_input_filename, tran_id, wfc_fft_plan, Tif_fft_plan, n_FFT_grid, verbose) Uses timing mpi Times the c -> c scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_FFT_grid (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_cc_calc.html"},{"title":"dme_scatter_cf_calc – EXCEED-DM","text":"public subroutine dme_scatter_cf_calc(binned_rate_t, init_id, log_omegas, ki_cut, ki_angular_mesh, kf_angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) integer :: init_id real(kind=dp) :: log_omegas (2) integer :: ki_cut real(kind=dp) :: ki_angular_mesh (:,:) real(kind=dp) :: kf_angular_mesh (:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_cf_calc.html"},{"title":"run_dme_scatter_cf – EXCEED-DM","text":"public subroutine run_dme_scatter_cf(binned_rate_t, n_tran_per_proc, sto_wf_filename, core_elec_config_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_cf.html"},{"title":"time_exdm_scatter_cf_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_cf_calc(log_omega_table, ki_angular_mesh, kf_angular_mesh, verbose) Uses timing mpi Times the v -> f scattering rate calculation Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_omega_table (n_fin,2) real(kind=dp) :: ki_angular_mesh (:,:) real(kind=dp) :: kf_angular_mesh (:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_cf_calc.html"},{"title":"dme_scatter_vc_calc_spin – EXCEED-DM","text":"public subroutine dme_scatter_vc_calc_spin(binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate. Wave functions are 2 component spinors\n in S_z basis Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G,2) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G,2) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_vc_calc_spin.html"},{"title":"dme_scatter_vc_calc_no_spin – EXCEED-DM","text":"public subroutine dme_scatter_vc_calc_no_spin(binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate assuming the wave functions do not\n depend on the spin. Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_vc_calc_no_spin.html"},{"title":"dme_scatter_vc_calc – EXCEED-DM","text":"public interface dme_scatter_vc_calc Contents Module Procedures dme_scatter_vc_calc_no_spin dme_scatter_vc_calc_spin Module Procedures public subroutine dme_scatter_vc_calc_no_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate assuming the wave functions do not\n depend on the spin. Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose public subroutine dme_scatter_vc_calc_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate. Wave functions are 2 component spinors\n in S_z basis Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G,2) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G,2) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose","tags":"","loc":"interface/dme_scatter_vc_calc.html"},{"title":"run_dme_scatter_vc – EXCEED-DM","text":"public subroutine run_dme_scatter_vc(binned_rate_t, n_tran_per_proc, DFT_input_filename, out_filename, proc_id, root_process, verbose) only load these variables if they haven't been loaded before\n to compute the dielectric Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_vc.html"},{"title":"time_exdm_scatter_vc_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_vc_calc(DFT_input_filename, tran_id, wfc_fft_plan, Tif_fft_plan, n_FFT_grid, verbose) Uses timing mpi Times the v -> c scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_FFT_grid (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_vc_calc.html"},{"title":"dme_scatter_vf_calc – EXCEED-DM","text":"public subroutine dme_scatter_vf_calc(binned_rate_t, wfc_FT_i, val_id, log_omegas, k_cut, angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) integer :: val_id real(kind=dp) :: log_omegas (2) integer :: k_cut real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose Contents None","tags":"","loc":"proc/dme_scatter_vf_calc.html"},{"title":"run_dme_scatter_vf – EXCEED-DM","text":"public subroutine run_dme_scatter_vf(binned_rate_t, n_tran_per_proc, DFT_input_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) only load these variables if they haven't been loaded before\n to compute the dielectric Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose Contents None","tags":"","loc":"proc/run_dme_scatter_vf.html"},{"title":"time_exdm_scatter_vf_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_vf_calc(DFT_input_filename, tran_id, log_omega_table, angular_mesh, verbose) Uses timing mpi Times the v -> f scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id real(kind=dp) :: log_omega_table (n_fin,2) real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_vf_calc.html"},{"title":"control_input – EXCEED-DM","text":"Collection of variables which specify how the program should run Contents Variables process calc_mode timer quiet save_binned_rate_if overwrite_output Subroutines print_control load_control Variables Type Visibility Attributes Name Initial character(len=64), public :: process = '' character(len=64), public :: calc_mode = '' logical, public :: timer = .TRUE. Optional If .TRUE. the program will output timing information logical, public :: quiet = .FALSE. Don't print any output logical, public :: save_binned_rate_if = .FALSE. save the 2d differential rate data for \n every i -> f transition memory intensive logical, public :: overwrite_output = .FALSE. if True the output file will be overwritten Subroutines public subroutine print_control (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_control (filename, verbose) Loads the control variables Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/control_input.html"},{"title":"core_electrons – EXCEED-DM","text":"Handles the wave functions and energy levels for core electrons Uses hdf5 h5lt prec constants math_mod Contents Variables n_atoms n_core_states Z_list eq_pos_red core_energy core_elec_conf core_sto_nj_list core_sto_max_nj core_sto_data Functions core_sto_wf core_sto_wf_FT core_sto_wf_radial core_sto_wf_FT_radial sto_wf_radial sto_wf_FT_radial get_sto_dataset_str Subroutines save_core_electrons calc_core_sto_wf_grid load_core_elec_config print_core_elec_config load_core_sto_data print_sto_data Variables Type Visibility Attributes Name Initial integer, public :: n_atoms Number of atoms in the primitive cell integer, public :: n_core_states Total number of core states integer, public, allocatable :: Z_list (:) Dim : [n_atoms] Proton number / number of electrons real(kind=dp), public, allocatable :: eq_pos_red (:,:) Dim : [n_atoms, 3] Equilibrium position of the atoms in the primitive cell\n in reduced coordinates Units : None real(kind=dp), public, allocatable :: core_energy (:) Dim : [n_core_states] Energy of the core states Units : eV integer, public, allocatable :: core_elec_conf (:,:) Dim : [n_core_states, 5] Electron configuration, each element is\n  core_elec_conf(i, 1) - atom id\n  core_elec_conf(i, 2) - n\n  core_elec_conf(i, 3) - l\n  core_elec_conf(i, 4) - m\n  core_elec_conf(i, 5) - n_s (number of spin states) Generated STO parameters integer, public, allocatable :: core_sto_nj_list (:) Dim : [n_core_states] Number of terms in the analytic STO expansion integer, public :: core_sto_max_nj Maximum value of core_sto_nj_list real(kind=dp), public, allocatable :: core_sto_data (:,:,:) Dim : [n_core_states, 4, max(core_sto_nj_list)] All of the parameters of the STO expansion\n  core_sto_data(i, 1, :) - n_l[j]\n  core_sto_data(i, 2, :) - Z_l[j]\n  core_sto_data(i, 3, :) - N_l[j]\n  core_sto_data(i, 4, :) - C_nl[j] Functions public function core_sto_wf (core_state_idx, x_vec) result(val) Core wave function Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_vec (3) Return Value complex(kind=dp) public function core_sto_wf_FT (core_state_idx, k_vec) result(val) Fourier transform of the core wave function Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_vec (3) Return Value complex(kind=dp) public function core_sto_wf_radial (core_state_idx, x_mag) result(val) Radial part of the total core wave function, summed over \n the individual sto_wf_radial Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: x_mag Return Value real(kind=dp) public function core_sto_wf_FT_radial (core_state_idx, k_mag) result(chi) Radial part of the total Fourier transformed core wave function, summed over \n the individual sto_wf_FT_radial Read more… Arguments Type Intent Optional Attributes Name integer :: core_state_idx references a specific element in core_elec_conf real(kind=dp) :: k_mag Return Value complex(kind=dp) public function sto_wf_radial (n, norm, Z, x_mag) result(val) Radial part of the Slater type orbital (STO) wave function Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: x_mag Return Value real(kind=dp) public function sto_wf_FT_radial (n, l, norm, Z, k_mag) result(val) Radial part of the fourier transform of a Slater type orbital (STO) wave function Read more… Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) public function get_sto_dataset_str (Z, n, l) result(dset_name) Returns the name of the dataset for nth element in the\n core electron configuration Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Subroutines public subroutine save_core_electrons (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine calc_core_sto_wf_grid (core_wfc, core_state_idx, n_grid, red_to_xyz, shift, k_vec_in, s_cut_in, verbose) computes the core wave functions on a grid, summed over the closest unit cells Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: core_wfc (n_grid(1),n_grid(2),n_grid(3)) integer :: core_state_idx integer :: n_grid (3) Number of grid points in reduced x coordinates real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: s_cut_in logical, optional :: verbose public subroutine load_core_elec_config (filename, verbose) Reads the core electron configuration file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_core_elec_config (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine load_core_sto_data (filename, verbose) Reads the sto wf file to get the relevant\n coefficients for the electron configuration\n specified in the core_elec_conf Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_sto_data (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose","tags":"","loc":"module/core_electrons.html"},{"title":"DFT_parameters – EXCEED-DM","text":"Handles the results from DFT calculations that compute the Bloch wave \n function coefficients. Variables with '_A' are with units of Angstroms Uses h5lt hdf5 prec constants units Contents Variables n_k n_val n_cond n_in_G in_G_grid_red a_vecs_A b_vecs_A k_weight k_grid_red energy_bands_raw n_bands q_PW_cut E_PW_cut a_vecs red_to_xyz b_vecs k_red_to_xyz energy_bands in_G_grid_xyz k_grid_xyz include_spin Interfaces get_in_wfc_FT Functions in_wfc_at_single_pt get_w_max Subroutines save_DFT_parameters load_DFT_parameters check_DFT_parameters print_DFT_parameters get_in_wfc_FT_no_spin get_in_wfc_FT_spin expand_wfc_FT_for_FFT get_PW_cutoffs do_scissor_correction Variables Type Visibility Attributes Name Initial integer, public :: n_k Number of k points integer, public :: n_val Number of valence bands integer, public :: n_cond Number of conduction bands integer, public :: n_in_G Number of G points in in_G_grid integer, public, allocatable :: in_G_grid_red (:,:) Dim : [n_in_G, 3] Input grid of G vectors in reduced coordinates real(kind=dp), public :: a_vecs_A (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : Ang real(kind=dp), public :: b_vecs_A (3,3) Reciprocal lattice vector (i, :) is the ith reciprocal lattice vector Units : Ang&#94;(-1) real(kind=dp), public, allocatable :: k_weight (:) Dim : [n_k] Weights of each k point in the k_red grid, must sum to 2 Units : None real(kind=dp), public, allocatable :: k_grid_red (:,:) Dim : [n_k, 3] List of k vectors in reduced coordinates Units : None real(kind=dp), public, allocatable :: energy_bands_raw (:,:) Dim : [n_k, n_bands] Raw electron energy eigenvalues Units : eV Generated from input integer, public :: n_bands Number of bands n_bands = n_cond + n_val real(kind=dp), public :: q_PW_cut plane wave cutoff in expansion Units : eV real(kind=dp), public :: E_PW_cut energy cooresponding to q_PW_cut E_PW_cut = q_PW_cut* 2/(2 m_elec) Units : eV real(kind=dp), public :: a_vecs (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : eV real(kind=dp), public :: red_to_xyz (3,3) Matrix converting reduced cooredinate positions to physical xyz cooredinates\n in eV&#94;(-1) via x_xyz = matmul(red_to_xyz, x_red) red_to_xyz = transpose(a_vecs) Units : eV&#94;(-1) real(kind=dp), public :: b_vecs (3,3) Reciprocal lattice vector (i, :) is the ith reciprocal lattice vector Units : eV real(kind=dp), public :: k_red_to_xyz (3,3) Matrix converting reduced coordinate momentum to physical xyz coordinates\n in eV via k_xyz = matmul(k_red_to_xyz, k_red) k_red_to_xyz = transpose(b_vecs) Units : eV real(kind=dp), public, allocatable :: energy_bands (:,:) Dim : [n_k, n_bands] Scissor corrected electron energy eigenvalues Units : eV real(kind=dp), public, allocatable :: in_G_grid_xyz (:,:) Dim : [n_in_G, 3] Input grid of G vectors in physical xyz coordinates Units : eV real(kind=dp), public, allocatable :: k_grid_xyz (:,:) Dim : [n_k, 3] List of k vectors in xyz coordinates Units : eV ! experimental logical, public :: include_spin = .FALSE. Interfaces public interface get_in_wfc_FT public subroutine get_in_wfc_FT_no_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:) Bloch wave functions in reciprocal space public subroutine get_in_wfc_FT_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G, 2] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_{i, k, G, s}, where s is the spin index Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:,:) Bloch wave functions in reciprocal space Functions public function in_wfc_at_single_pt (band_num, x0_red, in_wfc_FT) result(wfc) returns the wave function evaluated at a point in\n reduced coordinates at a single point Read more… Arguments Type Intent Optional Attributes Name integer :: band_num real(kind=dp) :: x0_red (3) complex(kind=dp) :: in_wfc_FT (n_k,n_in_G) Return Value complex(kind=dp)\n  (n_k) public function get_w_max (i) result(w_max) Returns the maximum energy transfer allowed from valence state i Arguments Type Intent Optional Attributes Name integer :: i Return Value real(kind=dp) Subroutines public subroutine save_DFT_parameters (filename, verbose) Saves some of the DFT input variables to filename Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine load_DFT_parameters (filename, verbose) Loads the DFT input file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine check_DFT_parameters (verbose) Check the values of of the input file to make sure they make sense Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine print_DFT_parameters (filename, verbose) Prints variables defined in this moudle Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine get_in_wfc_FT_no_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_ikG Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:) Bloch wave functions in reciprocal space public subroutine get_in_wfc_FT_spin (filename, band_num, in_wfc_FT) Reads the input DFT file and sets the [n_k, n_in_G, 2] complex(dp) array \n with whose elements are the dimensionless block wave function \n coefficients, u_{i, k, G, s}, where s is the spin index Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer :: band_num complex(kind=dp) :: in_wfc_FT (:,:,:) Bloch wave functions in reciprocal space public subroutine expand_wfc_FT_for_FFT (n_grid, wfc_FT, wfc_FT_exp, verbose) The Fourier components will generally not be defined on a\n uniform grid needed for an FFT. This subroutine puts the \n values of the Bloch coefficients in the correct place Arguments Type Intent Optional Attributes Name integer :: n_grid (3) complex(kind=dp) :: wfc_FT (n_in_G) complex(kind=dp) :: wfc_FT_exp (n_grid(1),n_grid(2),n_grid(3)) logical, optional :: verbose public subroutine get_PW_cutoffs (verbose) Calculate the plane wave expansion parameters Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine do_scissor_correction (band_gap, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: band_gap logical, optional :: verbose","tags":"","loc":"module/dft_parameters.html"},{"title":"FFT_util – EXCEED-DM","text":"Utilities for computing FFT's Uses prec fftw3 Contents Variables sym_FFT_G_grid_xyz Functions get_sym_FFT_G_grid_red get_sym_FFT_G_grid_xyz Subroutines set_sym_FFT_G_grid_xyz set_fft_plan_forward_3d set_fft_plan_backward_3d G_red_to_FFT_G_grid_index Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: sym_FFT_G_grid_xyz (:,:,:,:) FFT G grid shifted so that both + and - G's are represented Functions public function get_sym_FFT_G_grid_red (n_grid, G_ind_vec, verbose) result(G_red) Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_ind_vec (3) logical, optional :: verbose Return Value integer\n  (3) public function get_sym_FFT_G_grid_xyz (n_grid, G_ind_vec, k_red_to_xyz, verbose) result(G_xyz) Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_ind_vec (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp)\n  (3) Subroutines public subroutine set_sym_FFT_G_grid_xyz (n_grid, k_red_to_xyz, verbose) Symmetric FFT grid. Read more… Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose public subroutine set_fft_plan_forward_3d (n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine set_fft_plan_backward_3d (n_grid, fft_plan) sets the FFT plan for an array with dimensinos [ n_grid ] Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine G_red_to_FFT_G_grid_index (n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \n grid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3)","tags":"","loc":"module/fft_util.html"},{"title":"io_input – EXCEED-DM","text":"Input and output file names Contents Variables nml_input_filename DFT_input_filename run_description out_folder out_filename sto_wf_filename core_elec_config_filename dielectric_filename Subroutines print_io load_io create_output_file Variables Type Visibility Attributes Name Initial character(len=512), public :: nml_input_filename = '' Namelist input filename, character(len=512), public :: DFT_input_filename = '' DFT calculations input file character(len=64), public :: run_description = '' description of the calculation character(len=512), public :: out_folder = '.' Ouput folder character(len=512), public :: out_filename = '' Output filename Setting this variable overrides the settings of out_folder\n and run_description character(len=512), public :: sto_wf_filename = '' Input file specifying the Slater type orbital (sto)\n wave function coefficients for the core electron\n states character(len=512), public :: core_elec_config_filename = '' File specifying the core electron configuration character(len=512), public :: dielectric_filename = '' File specifying the dielectric function. If the dielectric\n will be computed this will be where the computed values are\n stored. If this file already exists, the dielectric function\n will be loaded from this file. Subroutines public subroutine print_io (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_io (filename, verbose) Loads the io namelist Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public recursive subroutine create_output_file (filename, overwrite_output, verbose) Creates the output file Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical :: overwrite_output logical, optional :: verbose","tags":"","loc":"module/io_input.html"},{"title":"material_input – EXCEED-DM","text":"Information about the target material. Uses hdf5 h5lt prec units Contents Variables mat_name pc_vol_A rho_T_g_per_cm3 m_T_kg band_gap pc_vol rho_T m_T Subroutines print_material load_material save_material Variables Type Visibility Attributes Name Initial character(len=64), public :: mat_name = '' real(kind=dp), public :: pc_vol_A Volume of the unit cell pc_vol_A = det(a_vecs) Units : Ang&#94;3 real(kind=dp), public :: rho_T_g_per_cm3 Target density Units : g/cm&#94;3 real(kind=dp), public :: m_T_kg = 1.0_dp Target mass Units : kg real(kind=dp), public :: band_gap = 0.0_dp Band gap of the target Units : eV Generated from input real(kind=dp), public :: pc_vol Volume of the primitive cell Units : eV&#94;(-3) real(kind=dp), public :: rho_T Target density Units : eV&#94;4 real(kind=dp), public :: m_T Target mass Units : eV Subroutines public subroutine print_material (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_material (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_material (filename, verbose) Saves the material properties Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/material_input.html"},{"title":"transition – EXCEED-DM","text":"Handles labelling of the transitions that each processor should compute \n for Contents Variables n_tran n_tran_per_proc tran_to_init_fin_id job_table Subroutines set_job_table Variables Type Visibility Attributes Name Initial integer, public :: n_tran Total number of transitions = n_init*n_fin integer, public :: n_tran_per_proc Number of transitiosn each processor has to calculate integer, public, allocatable :: tran_to_init_fin_id (:,:) Dim : [n_tran, 2] Each transition (i, f) is given a unique index, and this \n is the map back. For each transition id return the initial \n or final state index integer, public, allocatable :: job_table (:,:) Dim : [n_proc, n_tran_per_proc]\n give each processor a list of transitions to compute for Subroutines public subroutine set_job_table (n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose","tags":"","loc":"module/transition.html"},{"title":"absorption_input – EXCEED-DM","text":"Load parameters relevant for absorption calculations ! Uses hdf5 h5lt prec Contents Variables n_omega log_omega_min log_omega_max n_width_b n_width_a n_width_max n_widths width_a_min width_a_max log_width_b_min log_width_b_max width_max_min width_max_max sigma_gamma omega_list delta_list width_info Subroutines save_absorption_input print_absorption_input load_absorption_input Variables Type Visibility Attributes Name Initial integer, public :: n_omega = 1 Number of omega/mass points to compute for real(kind=dp), public :: log_omega_min = -2.0_dp real(kind=dp), public :: log_omega_max = 2.0_dp integer, public :: n_width_b = 1 integer, public :: n_width_a = 1 integer, public :: n_width_max = 0 integer, public :: n_widths n_width_a*n_width_b real(kind=dp), public :: width_a_min = 0.0_dp real(kind=dp), public :: width_a_max = 0.0_dp real(kind=dp), public :: log_width_b_min = -6.0_dp real(kind=dp), public :: log_width_b_max = -1.0_dp real(kind=dp), public :: width_max_min = 100.0_dp real(kind=dp), public :: width_max_max = 100.0_dp real(kind=dp), public :: sigma_gamma = 3 real(kind=dp), public, allocatable :: omega_list (:) Dim : [n_omega] real(kind=dp), public, allocatable :: delta_list (:,:) Dim : [n_omega, n_widths] real(kind=dp), public, allocatable :: width_info (:,:) Dim : [n_widths, 2] Width parameters, [a, b] Subroutines public subroutine save_absorption_input (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_absorption_input (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_absorption_input (filename, verbose) Load the absorption inputs Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/absorption_input.html"},{"title":"calc_PI – EXCEED-DM","text":"Computes self-energies needed for absorption calculations Uses mpi hdf5 h5lt prec constants material_input absorption_input DFT_parameters transition Contents Variables pi_vv pi_11_mat pi_v1 pi_1v pi_vv_t pi_11_mat_t pi_v1_t pi_1v_t Subroutines compute_self_energies save_self_energies calc_pi_vv calc_pi_11_mat calc_pi_v1 calc_pi_1v Variables Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: pi_vv (:,:) Dim : [n_omega, n_widths] self energy with two v&#94;2 insertions Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_11_mat (:,:,:,:) Dim : [3, 3, n_omega, n_widths] self energy, without q_vec's Pi_11 = (q/m_elec) . Pi_11_mat . (q/m_elec) Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_v1 (:,:,:) Dim : [3, n_omega, n_widths] self energy Pi_{v&#94;2, 1} Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_1v (:,:,:) Dim : [3, n_omega, n_widths] self energy Pi_{1, v&#94;2} = Pi_{v&#94;2, 1}&#94;*(-delta) Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_vv_t (:,:,:) Dim : [n_omega, n_widths, n_tran_per_proc] self energy with two v&#94;2 insertions Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_11_mat_t (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] self energy, without q_vec's Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_v1_t (:,:,:,:) Dim : [3, n_omega, n_widths, n_tran_per_proc] self energy Pi_{v&#94;2, 1} Units : eV&#94;2 complex(kind=dp), public, allocatable :: pi_1v_t (:,:,:,:) Dim : [3, n_omega, n_widths, n_tran_per_proc] self energy Pi_{1, v&#94;2} = Pi_{v&#94;2, 1}&#94;*(-delta) Units : eV&#94;2 Subroutines public subroutine compute_self_energies (nml_filename, tran_form, tran_form_vec, omega_iipk, n_init, n_fin, n_k, n_proc, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: nml_filename complex(kind=dp) :: tran_form (n_init,n_fin,n_k) complex(kind=dp) :: tran_form_vec (3,n_init,n_fin,n_k) real(kind=dp) :: omega_iipk (n_init,n_fin,n_k) integer :: n_init integer :: n_fin integer :: n_k integer :: n_proc integer :: proc_id integer :: root_process logical, optional :: verbose public subroutine save_self_energies (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine calc_pi_vv (pi_vv, tran_form_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vv (n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) real(kind=dp) :: omega_iipk_t (n_k) public subroutine calc_pi_11_mat (pi_11_mat, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k) public subroutine calc_pi_v1 (pi_v1, tran_form_t, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v1 (3,n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k) public subroutine calc_pi_1v (pi_1v, tran_form_t, tran_form_vec_t, omega_iipk_t) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1v (3,n_omega,n_widths) complex(kind=dp) :: tran_form_t (n_k) complex(kind=dp) :: tran_form_vec_t (3,n_k) real(kind=dp) :: omega_iipk_t (n_k)","tags":"","loc":"module/calc_pi.html"},{"title":"dme_absorption – EXCEED-DM","text":"Perform DM absorption rate calculations Note : currently specific to vc transitions building blocks of all absorption calculations Uses mpi hdf5 h5lt prec control_input numerics_input material_input transition DFT_parameters particle_physics_abs tran_form_calc calc_PI rate_calc_vector rate_calc_ps rate_calc_scalar Contents Variables tran_form tran_form_vec omega_iipk tran_form_t tran_form_vec_t omega_iipk_t abs_rate Subroutines run_dme_absorption save_abs_rate save_tran_form update_tran_form Variables Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: tran_form (:,:,:) Dim : [n_init, n_fin, n_k] Scalar transition form factor for absorption calculations = Units : None complex(kind=dp), public, allocatable :: tran_form_vec (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Vector transition form factor for absorption calculations = Units : None real(kind=dp), public, allocatable :: omega_iipk (:,:,:) Dim : [n_init, n_fin, n_k] Energy difference of the transition from i -> f at k Units : None complex(kind=dp), public, allocatable :: tran_form_t (:,:) Dim : [n_tran_per_proc, n_k] Scalar transition form factor for absorption calculations Units : None complex(kind=dp), public, allocatable :: tran_form_vec_t (:,:,:) Dim : [3, n_tran_per_proc, n_k] Vector transition form factor for absorption calculations Units : None real(kind=dp), public, allocatable :: omega_iipk_t (:,:) Dim : [n_tran_per_proc, n_k] Energy difference of the transition from i -> f at k Units : None real(kind=dp), public, allocatable :: abs_rate (:,:,:) Dim : [n_omega, n_widths, n_times] Absorption rate per kg-year Units : None Subroutines public subroutine run_dme_absorption (proc_id, root_process, out_filename, nml_filename, DFT_input_filename, n_proc, verbose) Absorption rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename integer :: n_proc logical, optional :: verbose public subroutine save_abs_rate (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_tran_form (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine update_tran_form (tran_form_t, tran_form_vec_t, omega_iipk_t, proc_id, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_t (n_tran_per_proc,n_k) complex(kind=dp) :: tran_form_vec_t (3,n_tran_per_proc,n_k) real(kind=dp) :: omega_iipk_t (n_tran_per_proc,n_k) integer :: proc_id logical, optional :: verbose","tags":"","loc":"module/dme_absorption.html"},{"title":"particle_physics_abs – EXCEED-DM","text":"Relevant particle physics parameters for an absorption\n calculation Uses prec constants units math_mod Contents Variables rhoX_GeV_per_cm3 v0_km_per_sec vE_km_per_sec vEsc_km_per_sec thetaE rhoX v0 vE vEsc vel_dist_N0 n_v_mag n_v_theta n_v_phi n_time time_day_min time_day_max time_of_day vE_vec_list Functions mb_vel_distribution Subroutines print_particle_physics_abs load_particle_physics_abs check_mb_dist_normalization Variables Type Visibility Attributes Name Initial real(kind=dp), public :: rhoX_GeV_per_cm3 = 0.4_dp Dark matter density Units : GeV/cm&#94;3 real(kind=dp), public :: v0_km_per_sec = 230.0_dp real(kind=dp), public :: vE_km_per_sec = 240.0_dp real(kind=dp), public :: vEsc_km_per_sec = 600.0_dp real(kind=dp), public :: thetaE = (42.0_dp/180.0_dp)*pi Generated !!!!!!! real(kind=dp), public :: rhoX Dark matter density Units : eV&#94;4 real(kind=dp), public :: v0 real(kind=dp), public :: vE real(kind=dp), public :: vEsc real(kind=dp), public :: vel_dist_N0 integer, public :: n_v_mag integer, public :: n_v_theta integer, public :: n_v_phi integer, public :: n_time = 1 real(kind=dp), public :: time_day_min = 0.0_dp real(kind=dp), public :: time_day_max = 1.0_dp real(kind=dp), public, allocatable :: time_of_day (:) real(kind=dp), public, allocatable :: vE_vec_list (:,:) Functions public function mb_vel_distribution (v_vec, boost_vec_in) result(mb_val) Maxwell boltzmann distribution, boosted with boost_vec Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_vec (3) real(kind=dp), optional :: boost_vec_in (3) Return Value real(kind=dp) Subroutines public subroutine print_particle_physics_abs (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_particle_physics_abs (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine check_mb_dist_normalization (n_v_mag, n_v_theta, n_v_phi, boost_vec_in, verbose) make sure the mb distribution integrates to 1 Read more… Arguments Type Intent Optional Attributes Name integer :: n_v_mag integer :: n_v_theta integer :: n_v_phi real(kind=dp), optional :: boost_vec_in (3) logical, optional :: verbose","tags":"","loc":"module/particle_physics_abs.html"},{"title":"tran_form_calc – EXCEED-DM","text":"Compute the transition form factors Uses prec constants DFT_parameters Contents Subroutines calc_tran_form Subroutines public subroutine calc_tran_form (tran_form, tran_form_vec, omega_k, val_id, cond_id, wfc_FT_i, wfc_FT_f, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form (n_k) complex(kind=dp) :: tran_form_vec (3,n_k) real(kind=dp) :: omega_k (n_k) integer :: val_id integer :: cond_id complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) logical, optional :: verbose","tags":"","loc":"module/tran_form_calc.html"},{"title":"rate_calc_ps – EXCEED-DM","text":"Given the self energies, compute the absorption rate of \n pseudoscalar DM Uses prec constants particle_physics_abs absorption_input material_input Contents Subroutines calc_rate_ps Subroutines public subroutine calc_rate_ps (pi_11_mat, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose","tags":"","loc":"module/rate_calc_ps.html"},{"title":"rate_calc_scalar – EXCEED-DM","text":"Given the self energies, compute the absorption rate of \n scalar DM Uses prec constants particle_physics_abs absorption_input material_input Contents Subroutines calc_rate_scalar Subroutines public subroutine calc_rate_scalar (pi_11_mat, pi_1v, pi_v1, pi_vv, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) complex(kind=dp) :: pi_1v (3,n_omega,n_widths) complex(kind=dp) :: pi_v1 (3,n_omega,n_widths) complex(kind=dp) :: pi_vv (n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose","tags":"","loc":"module/rate_calc_scalar.html"},{"title":"rate_calc_vector – EXCEED-DM","text":"Given the self energies, compute the absorption rate of vector DM Uses prec constants particle_physics_abs absorption_input material_input Contents Subroutines calc_rate_vector Subroutines public subroutine calc_rate_vector (pi_11_mat, abs_rate, verbose) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_11_mat (3,3,n_omega,n_widths) real(kind=dp) :: abs_rate (n_omega,n_widths,n_time) logical, optional :: verbose","tags":"","loc":"module/rate_calc_vector.html"},{"title":"constants – EXCEED-DM","text":"Collection of useful constants Uses prec Contents Variables m_elec alpha_EM a0 pi ii e_EM Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: m_elec = 511.0e3_dp Electron mass Units : eV real(kind=dp), public, parameter :: alpha_EM = 1.0_dp/137.0_dp Fine structure constant real(kind=dp), public, parameter :: a0 = 2.681336e-4_dp Bohr radius Units : eV&#94;(-1) real(kind=dp), public, parameter :: pi = 4.0_dp*atan(1.0_dp) complex(kind=dp), public, parameter :: ii = (0.0_dp, 1.0_dp) Imaginary unit real(kind=dp), public, parameter :: e_EM = sqrt(4*pi*alpha_EM) Unit of electric charge","tags":"","loc":"module/constants.html"},{"title":"math_mod – EXCEED-DM","text":"A collection of useful math functions Uses prec special_functions constants Contents Functions pauli_spin_matrix integrate_power_law power_law_fit generate_uniform_points_on_sphere Q_func factorial sph_harmonic get_phi get_theta Functions public function pauli_spin_matrix (i) result(mat) Returns the ith Pauli spin matrix. Assume 0th Pauli matrix is the identity Arguments Type Intent Optional Attributes Name integer :: i Return Value complex(kind=dp)\n  (2,2) public function integrate_power_law (b, x1, x2, x_s) result(integral) = int_{x1}&#94;{x2} (x/x_s)&#94;b dx = x1 * int_{1}&#94;{x2/x1} (x1/x_s)&#94;b y&#94;b dy\n = (b + 1)&#94;(-1) * x1 * exp( b log(x1/x_s) ) * ( exp( (b + 1) log(x2/x1) ) - 1 ) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) public function power_law_fit (log_x_pts, log_y_pts) result(fit_params) Finds the best fit parameters for y = y1 * (x/x1) &#94; b, given log_y and log_x Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) public function generate_uniform_points_on_sphere (n_theta, n_phi) result(angular_mesh) Generates an (n_thata*n_phi, 2) list of points which are uniformly \n distributed on the sphere Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) public function Q_func (x, a, b, Q_max) result(Q) Places x in an appropriate bin Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer public function factorial (n) result(fact) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer public recursive function sph_harmonic (l, m, theta, phi) result(y_lm) Spherical harmonic function with phase convention identical\n to Mathematica Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) public function get_phi (n_hat) result(phi) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) public function get_theta (n_hat) result(theta) returns the theta value of a unit direction vector, n_hat Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp)","tags":"","loc":"module/math_mod.html"},{"title":"prec – EXCEED-DM","text":"Precision definitions\n double precision (dp) definition Uses iso_fortran_env Contents None","tags":"","loc":"module/prec.html"},{"title":"timing – EXCEED-DM","text":"Useful functions for timing a program Uses prec Contents Variables time delta_t Functions pretty_time_format Variables Type Visibility Attributes Name Initial real(kind=dp), public :: time (100) holds raw timing variables real(kind=dp), public :: delta_t (100) holds difference in timing variables Functions public function pretty_time_format (t) result(time_str) Fills time_str with a nicely formatted version of time Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512)","tags":"","loc":"module/timing.html"},{"title":"units – EXCEED-DM","text":"Unit conversion factors If a variable has units of x to convert to units y: var_y = x_to_y * var_x Uses prec Contents Variables inv_Ang_to_eV inv_eV_to_cm Ang_to_inv_eV g_to_eV kg_to_eV inv_cm_to_eV km_per_sec_to_none Variables Type Visibility Attributes Name Initial real(kind=dp), public :: inv_Ang_to_eV = 1973.37_dp real(kind=dp), public :: inv_eV_to_cm = 1.97327e-5_dp real(kind=dp), public :: Ang_to_inv_eV = 5.068e-4_dp real(kind=dp), public :: g_to_eV = 5.61e32_dp real(kind=dp), public :: kg_to_eV = 5.61e35_dp real(kind=dp), public :: inv_cm_to_eV = 1.97327e-5_dp real(kind=dp), public :: km_per_sec_to_none = 3.33563e-6_dp","tags":"","loc":"module/units.html"},{"title":"calc_dielectric – EXCEED-DM","text":"Compute the dielectric tensor from Pi_11 from valence -> conduction transitions. Uses mpi hdf5 h5lt prec constants math_mod material_input DFT_parameters FFT_util io_input transition_form_factor di_transition dielectric_input di_grid Contents Variables dielec dielec_t Subroutines check_dielectric_memory run_dielectric_calc compute_dielectric save_dielectric Variables Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: dielec (:,:,:,:) Dim : [ n_omega_bins + 1, n_q_bins + 1, n_q_theta_bins + 1, n_q_phi_bins + 1 ] eps(omega, q) = 1 - \\frac{e&#94;2}{q&#94;2} Pi_11(q, omega) Pi_11 = (1/V) sum_{II'} \\frac{1}{omega - omega_{I'} - omega_{I} + i delta} \n      | |&#94;2 Units : None complex(kind=dp), public, allocatable :: dielec_t (:,:,:,:,:) Dim : [ n_tran_per_proc, n_omega_bins + 1, n_q_bins + 1, n_q_theta_bins + 1, n_q_phi_bins + 1 ] Each processors contribution to the dielectric Units : None Subroutines public subroutine check_dielectric_memory (verbose) Checks to see if the dielectric is going to take up too\n much memory. Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine run_dielectric_calc (nml_filename, filename, DFT_input_filename, proc_id, root_process, n_proc, verbose) Compute the dielectric binned in energy and momentum transfer. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: nml_filename character(len=*) :: filename character(len=*) :: DFT_input_filename integer :: proc_id integer :: root_process integer :: n_proc logical, optional :: verbose public subroutine compute_dielectric (di, val_id, cond_id, wfc_FT_i, wfc_FT_f, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, n_q_grid, q_grid_min, n_k_vec, verbose) Compute the contribution to the dimensionless dielectric\n from a given i -> f transition. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) integer :: val_id integer :: cond_id complex(kind=dp) :: wfc_FT_i (:,:) complex(kind=dp) :: wfc_FT_f (:,:) integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_q_grid (3) real(kind=dp) :: q_grid_min (3) integer :: n_k_vec (3) logical, optional :: verbose public subroutine save_dielectric (filename, verbose) Save the computed dielectric to 'filename'. Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/calc_dielectric.html"},{"title":"dielectric_input – EXCEED-DM","text":"Handles input variables for the calculation of the dielectric. Uses prec Contents Variables di_n_omega_bins di_omega_bin_width di_n_q_bins di_q_bin_width di_n_q_phi_bins di_n_q_theta_bins load_dielectric_from_file di_width_a di_log_width_b di_width_max di_n_init di_n_fin n_k_vec Functions di_width_func Subroutines print_dielectric_input load_dielectric_input Variables Type Visibility Attributes Name Initial integer, public :: di_n_omega_bins = 1 Number of omega bins real(kind=dp), public :: di_omega_bin_width = 1.0_dp Width of the omega bins Units : eV integer, public :: di_n_q_bins = 1 Number of |q| bins real(kind=dp), public :: di_q_bin_width = 1.0e3_dp Width of the q bins. Units : eV integer, public :: di_n_q_phi_bins = 1 Number of phi_q bins integer, public :: di_n_q_theta_bins = 1 Number of theta_q bins logical, public :: load_dielectric_from_file = .FALSE. Specify whether the dielectric matrix should be loaded\n from a file or computed. real(kind=dp), public :: di_width_a = 0.2_dp Parameter in the model for the width: delta = min( a + b*omega, width_max ) Units: eV real(kind=dp), public :: di_log_width_b = -3.0_dp Parameter in the model for the width: delta = min( a + b*omega, width_max ) Units: None real(kind=dp), public :: di_width_max = 0.2_dp Parameter in the model for the width: delta = min( a + b*omega, width_max ) Units: eV integer, public :: di_n_init = 1 number of initial bands to compute for. integer, public :: di_n_fin = 1 number of final bands to compute for. integer, public :: n_k_vec (3) Functions public function di_width_func (omega) result(delta) Parameterization of the electron lifetime/width. Arguments Type Intent Optional Attributes Name real(kind=dp) :: omega Return Value real(kind=dp) Subroutines public subroutine print_dielectric_input (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_dielectric_input (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/dielectric_input.html"},{"title":"di_grid – EXCEED-DM","text":"Uses prec DFT_parameters FFT_util Contents Subroutines define_q_grid Subroutines public subroutine define_q_grid (q_max, k_red_to_xyz, n_q_grid, q_grid_min, n_k_vec, n_FFT_grid, verbose) q = k' - k + G Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_max real(kind=dp) :: k_red_to_xyz (3,3) integer :: n_q_grid (3) real(kind=dp) :: q_grid_min (3) integer :: n_k_vec (3) Might have to be input by hand right now, should add\n to DFT_input file integer :: n_FFT_grid (3) logical, optional :: verbose","tags":"","loc":"module/di_grid.html"},{"title":"di_transition – EXCEED-DM","text":"Handles labelling of the transitions that each processor should compute \n for to compute the dielectric. TODO: Make a better interface to transition such that the job table\n is not specific to the module. This will allow the same transition\n subroutines to be available more generally. Contents Variables di_n_tran di_n_tran_per_proc di_tran_to_init_fin_id di_job_table Subroutines di_set_job_table Variables Type Visibility Attributes Name Initial integer, public :: di_n_tran Total number of transitions = n_init*n_fin integer, public :: di_n_tran_per_proc Number of transitiosn each processor has to calculate integer, public, allocatable :: di_tran_to_init_fin_id (:,:) Dim : [n_tran, 2] Each transition (i, f) is given a unique index, and this \n is the map back. For each transition id return the initial \n or final state index integer, public, allocatable :: di_job_table (:,:) Dim : [n_proc, n_tran_per_proc]\n give each processor a list of transitions to compute for Subroutines public subroutine di_set_job_table (n_proc, n_init, n_fin, verbose) Arguments Type Intent Optional Attributes Name integer :: n_proc integer :: n_init integer :: n_fin logical, optional :: verbose","tags":"","loc":"module/di_transition.html"},{"title":"version_control – EXCEED-DM","text":"Keeps track of the current version of the program Contents Variables version Variables Type Visibility Attributes Name Initial character(len=64), public :: version = \"0.2.1\"","tags":"","loc":"module/version_control.html"},{"title":"exdm_scatter – EXCEED-DM","text":"Perform DM-electron scattering rate calculations Uses mpi hdf5 h5lt prec control_input particle_physics_scatter numerics_input in_med_scr transition transition_form_factor exdm_scatter_vc exdm_scatter_cc exdm_scatter_vf exdm_scatter_cf Contents Variables binned_rate_t_scatter binned_rate_if_scatter binned_rate_i_scatter binned_rate_scatter rate_scatter calc_modes_list Subroutines run_dme_scatter update_rates save_rates Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: binned_rate_t_scatter (:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_tran_per_proc] Binned rate allocated on each processor, for each job to compute for Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_if_scatter (:,:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init, n_fin] Binned rate between all transitions Warning : memory intensive Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_i_scatter (:,:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time, n_init] Binned rate, summed over final states Units : eV&#94;2 real(kind=dp), public, allocatable :: binned_rate_scatter (:,:,:,:,:) Dim : [n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time] Binned rate summed over all transitions Units : eV&#94;2 real(kind=dp), public, allocatable :: rate_scatter (:,:,:) Dim : [n_mX, n_FDM, n_time] Total rate summed over all transitions Units : eV&#94;2 character(len=64), public :: calc_modes_list (4) = ['vc', 'vf', 'cc', 'cf'] Subroutines public subroutine run_dme_scatter (proc_id, root_process, out_filename, nml_filename, DFT_input_filename, sto_wf_filename, core_elec_config_filename, n_proc, save_binned_rate_if, verbose) Scattering rate calculation Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process character(len=*) :: out_filename character(len=*) :: nml_filename character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename integer :: n_proc logical :: save_binned_rate_if logical, optional :: verbose public subroutine update_rates (binned_rate_t, proc_id) updates all the rate arrays with the output \n of a single processors results Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time,n_tran_per_proc) integer :: proc_id public subroutine save_rates (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/exdm_scatter.html"},{"title":"in_med_scr – EXCEED-DM","text":"Handle analytic/numeric dielectric or other in medium effects which screen the interaction rate ~ 1/screen&#94;2 Uses hdf5 h5lt prec constants math_mod dielectric_input calc_dielectric Contents Variables screen_type di_e0 di_q_tf di_omega_p di_alpha include_screen screen_mat scr_n_w_bins scr_n_q_bins scr_n_q_theta_bins scr_n_q_phi_bins scr_w_bin_width scr_q_bin_width Functions screening model_dielectric Subroutines load_scr_dielectric print_in_med load_in_med_scr save_in_med_scr Variables Type Visibility Attributes Name Initial character(len=64), public :: screen_type = '' !\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 real(kind=dp), public :: di_e0 real(kind=dp), public :: di_q_tf real(kind=dp), public :: di_omega_p real(kind=dp), public :: di_alpha ! logical, public :: include_screen = .TRUE. toggle whether screening effects are included or not For numerical calculation of dielectric complex(kind=dp), public, allocatable :: screen_mat (:,:,:,:) Numerically computed screening matrix, binned in [ omega, q, q_theta, q_phi ] integer, public :: scr_n_w_bins integer, public :: scr_n_q_bins integer, public :: scr_n_q_theta_bins integer, public :: scr_n_q_phi_bins real(kind=dp), public :: scr_w_bin_width real(kind=dp), public :: scr_q_bin_width Functions public function screening (q_vec, omega) result(scr) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function model_dielectric (q_vec, omega, e0, q_tf, alpha, omega_p) result(di) Analytic form of the dielectric function\n Eq 6 from \n      https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: omega real(kind=dp) :: e0 real(kind=dp) :: q_tf real(kind=dp) :: alpha real(kind=dp) :: omega_p Return Value real(kind=dp) Subroutines public subroutine load_scr_dielectric (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_in_med (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_in_med_scr (filename, dielectric_filename, DFT_input_filename, proc_id, root_process, n_proc, verbose) allocate screen_mat\n For some reason this does not work when load_dielectric_from_file is FALSE.\n When load_dielectric_from_file = TRUE all the processes\n open and read the file as expected. Seems like a file \n permission issue with HDF5. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: filename character(len=*) :: dielectric_filename character(len=*) :: DFT_input_filename integer :: proc_id integer :: root_process integer :: n_proc logical, optional :: verbose public subroutine save_in_med_scr (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/in_med_scr.html"},{"title":"numerics_input – EXCEED-DM","text":"Variables relating to binning and other numerics Uses hdf5 h5lt prec Contents Variables q_bin_width n_q_bins E_bin_width n_E_bins E_bin_threshold Ef_max n_init n_fin n_FFT_grid_input q_s_FFT n_kf_theta n_kf_phi n_ki_theta n_ki_phi ki_s n_ki ki_min Subroutines load_numerics print_numerics save_numerics Variables Type Visibility Attributes Name Initial real(kind=dp), public :: q_bin_width = 1.0e3_dp width of momuntum bins Units : eV integer, public :: n_q_bins = 0 Number of q bins, with bin width q_bin_width, to save Note: momentum transfers greater than n_q_bins*q_bin_width\n will be stored in the last, extra bin real(kind=dp), public :: E_bin_width = 1.0_dp Width of the energy bins Units : eV integer, public :: n_E_bins = 0 Number of E bins, with bin width E_bin_width, to save Note: energy transfers greater than n_E_bins*E_bin_width\n will be stored in the last, extra bin integer, public :: E_bin_threshold = 1 smallest E bin added to total rate calculation\n default : 1 - include all bins real(kind=dp), public :: Ef_max = 60.0_dp maximum final state energy to include in calculations Units : eV TODO : E_cut is a more appropriate name integer, public :: n_init number of initial states integer, public :: n_fin number of final states integer, public :: n_FFT_grid_input (3) = [0, 0, 0] Default size of the FFT, used to extend core\n calculation by making the size of the FFT larger Note : only used in calculations which use the FFT real(kind=dp), public :: q_s_FFT = 2151.0_dp/2.0_dp Units : eV q_max_FFT = q_s_FFT*N_FFT Minimum eigenvalue of k_red_to_xyz matrix Note : only used in calculations which use the FFT TODO : do not hard code this in integer, public :: n_kf_theta = 1 Number of theta points in integration of kf Note : only used in free calculatinos integer, public :: n_kf_phi = 1 Number of phi points in integration of kf Note : only used in free calculatinos integer, public :: n_ki_theta = 1 Number of theta points in integration of ki Note : only used in core -> free calculatinos integer, public :: n_ki_phi = 1 Number of phi points in integration of ki Note : only used in core -> free calculatinos real(kind=dp), public :: ki_s = 100.0_dp Scale parameter for k_i momentum to integrate over in core -> free calculation maximum initial electron momentum = ki_s * Z * alpha * m_e Generally want this to be >> Z alpha m_e, the scale factor of the electron wave functions integer, public :: n_ki = 2 Number of radial points in integration of ki real(kind=dp), public :: ki_min = 1.0e3_dp Minimum electron momentum Units : eV Subroutines public subroutine load_numerics (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine print_numerics (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine save_numerics (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/numerics_input.html"},{"title":"particle_physics_scatter – EXCEED-DM","text":"Particle physics parameters needed for a DM-electron\n scattering rate calculation Uses hdf5 h5lt prec constants units Contents Variables n_mX log_mmin log_mmax n_extra_mX n_FDM FDMPower_min FDMPower_max n_time time_day_min time_day_max percentile_cut rhoX_GeV_per_cm3 v0_km_per_sec vE_km_per_sec vEsc_km_per_sec thetaE rhoX v0 vE vEsc mX mX_2 FDMPowerList timeOfDayList vEVecList g_func_N0 g_func_c1 g_func_c2 v_max Functions v_minus g_func red_mass F_med_sq_func Subroutines print_particle_physics_scatter load_particle_physics_scatter save_particle_physics_scatter set_mX set_g_func_parameters set_FDM_powers set_time_vE_vec Variables Type Visibility Attributes Name Initial integer, public :: n_mX = 1 Number of masses to compute for real(kind=dp), public :: log_mmin = 9.0_dp real(kind=dp), public :: log_mmax = 9.0_dp integer, public :: n_extra_mX = 0 Optional User can specify extra mass points to add in addition to \n the log-uniform ones chosen integer, public :: n_FDM = 1 Number of mediator types to compute for real(kind=dp), public :: FDMPower_min = 0.0_dp real(kind=dp), public :: FDMPower_max = 0.0_dp integer, public :: n_time = 1 Number of time of days to compute for real(kind=dp), public :: time_day_min = 0.0_dp real(kind=dp), public :: time_day_max = 0.0_dp real(kind=dp), public :: percentile_cut = 3.0_dp real(kind=dp), public :: rhoX_GeV_per_cm3 = 0.4_dp Dark matter density Units : GeV/cm&#94;3 real(kind=dp), public :: v0_km_per_sec = 230.0_dp real(kind=dp), public :: vE_km_per_sec = 240.0_dp real(kind=dp), public :: vEsc_km_per_sec = 600.0_dp real(kind=dp), public :: thetaE = (42.0_dp/180.0_dp)*pi Generated !!!!!!! real(kind=dp), public :: rhoX Dark matter density Units : eV&#94;4 real(kind=dp), public :: v0 real(kind=dp), public :: vE real(kind=dp), public :: vEsc real(kind=dp), public, allocatable :: mX (:) real(kind=dp), public, allocatable :: mX_2 (:) real(kind=dp), public, allocatable :: FDMPowerList (:) real(kind=dp), public, allocatable :: timeOfDayList (:) real(kind=dp), public, allocatable :: vEVecList (:,:) Dim : [n_times, 3] real(kind=dp), public :: g_func_N0 real(kind=dp), public :: g_func_c1 real(kind=dp), public :: g_func_c2 real(kind=dp), public :: v_max = vE + vEsc Functions public function v_minus (q_vec, mX, vE_vec, omega) result(v_m) v_- function Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function g_func (q, v_m) result(g_fun) Kinematic function : Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m Return Value real(kind=dp) public function red_mass (m1, m2) result(mu) Reduced mass Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) public function F_med_sq_func (q_mag, power) result(F_med_sq_val) Mediator for factor squared Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp) Subroutines public subroutine print_particle_physics_scatter (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_particle_physics_scatter (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine save_particle_physics_scatter (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine set_mX (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose public subroutine set_g_func_parameters () Arguments None public subroutine set_FDM_powers (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose public subroutine set_time_vE_vec (verbose) Arguments Type Intent Optional Attributes Name logical :: verbose","tags":"","loc":"module/particle_physics_scatter.html"},{"title":"transition_form_factor – EXCEED-DM","text":"Transition Form Factor (TFF) Define general scattering operators such that the scattering rate for\n any DM model can be computed. This will generalize the transition form factor (TFF) defined as All spin independent results come from . Note that this quantity is different \n than the mediator form factor and screening factor, both of which can be set independently of this function. Each that the user can specify will have a unique index. A catalog will be kept of all the operators and their corresponding index. The calculation can become more difficult technically depending on the operator so a hierarchy will be kept in\n order to simplify the calculation when possible. TODO: For now we will assume that only a single T_if needs to be computed. Future work could improve on this by\n setting up wrapper functions which compute multiple T's and sum them. This will be necessary when the scattering operator\n has more than one term, e.g. . Catalog : 1 -  \\mathcal{O} = 1  [ vc ] 2 -  \\mathcal{O} = \\mathbf{S}_e  [ vc, s ] Notes : Bracketed quantities indicate what transition types are currently supported, s indicates its only\n supported for spin dependent wave functions. Uses prec constants Contents Variables tff_id Interfaces calc_tff_vc Subroutines print_tff_input load_tff_input calc_tff_vc_spin calc_tff_vc_no_spin Variables Type Visibility Attributes Name Initial integer, public :: tff_id (2) = [1, 1] Interfaces public interface calc_tff_vc public subroutine calc_tff_vc_no_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_vc_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Subroutines public subroutine print_tff_input (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_tff_input (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose public subroutine calc_tff_vc_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_vc_no_spin (TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the tff for the valence to conduction calculation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose","tags":"","loc":"module/transition_form_factor.html"},{"title":"Zeff_input – EXCEED-DM","text":"Loads the Zeff paramters for the free calculation Uses prec DFT_parameters core_electrons Contents Variables Zeff_type n_Eb val_Zeff_in Functions get_val_Z_eff Subroutines print_Zeff load_Zeff_parameters Variables Type Visibility Attributes Name Initial character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use 'one' - all Zeff = 1 'Eb' - use the binding energy of the (valence) state 'Eb_c' - use the binding energy of the (core) state 'in' - specified by the input real(kind=dp), public :: n_Eb = 1.0_dp n to use when computing Z_eff with the binding energy approximation real(kind=dp), public :: val_Zeff_in (100) = 1.0_dp Functions public function get_val_Z_eff (i, k) result(Zeff) returns the Z_eff value of the valence state Arguments Type Intent Optional Attributes Name integer :: i integer :: k Return Value real(kind=dp) Subroutines public subroutine print_Zeff (verbose) Arguments Type Intent Optional Attributes Name logical, optional :: verbose public subroutine load_Zeff_parameters (filename, verbose) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/zeff_input.html"},{"title":"calc_exdm_scatter_cc – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the cc calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters core_electrons FFT_util in_med_scr Contents Subroutines dme_scatter_cc_calc Subroutines public subroutine dme_scatter_cc_calc (binned_rate_t, wfc_i, wfc_FT_f, init_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: init_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_cc.html"},{"title":"exdm_scatter_cc – EXCEED-DM","text":"Compute the scattering rate from core to conduction states Uses prec control_input numerics_input material_input DFT_parameters core_electrons FFT_util transition calc_exdm_scatter_cc Contents Subroutines run_dme_scatter_cc time_exdm_scatter_cc_calc Subroutines public subroutine run_dme_scatter_cc (binned_rate_t, n_tran_per_proc, DFT_input_filename, sto_wf_filename, core_elec_config_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose public subroutine time_exdm_scatter_cc_calc (DFT_input_filename, tran_id, wfc_fft_plan, Tif_fft_plan, n_FFT_grid, verbose) Times the c -> c scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_FFT_grid (3) logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_cc.html"},{"title":"calc_exdm_scatter_cf – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the cf calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter in_med_scr Zeff_input core_electrons Contents Subroutines dme_scatter_cf_calc Subroutines public subroutine dme_scatter_cf_calc (binned_rate_t, init_id, log_omegas, ki_cut, ki_angular_mesh, kf_angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) integer :: init_id real(kind=dp) :: log_omegas (2) integer :: ki_cut real(kind=dp) :: ki_angular_mesh (:,:) real(kind=dp) :: kf_angular_mesh (:,:) logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_cf.html"},{"title":"exdm_scatter_cf – EXCEED-DM","text":"Compute the scattering rate from core to free states Uses prec math_mod control_input numerics_input material_input particle_physics_scatter core_electrons transition Zeff_input calc_exdm_scatter_cf Contents Subroutines run_dme_scatter_cf time_exdm_scatter_cf_calc Subroutines public subroutine run_dme_scatter_cf (binned_rate_t, n_tran_per_proc, sto_wf_filename, core_elec_config_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: sto_wf_filename character(len=*) :: core_elec_config_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose public subroutine time_exdm_scatter_cf_calc (log_omega_table, ki_angular_mesh, kf_angular_mesh, verbose) Times the v -> f scattering rate calculation Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_omega_table (n_fin,2) real(kind=dp) :: ki_angular_mesh (:,:) real(kind=dp) :: kf_angular_mesh (:,:) logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_cf.html"},{"title":"calc_exdm_scatter_vc – EXCEED-DM","text":"Holds the subroutine which calculates the binned rate for the vc calculation Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters FFT_util in_med_scr transition_form_factor Contents Interfaces dme_scatter_vc_calc Subroutines dme_scatter_vc_calc_spin dme_scatter_vc_calc_no_spin Interfaces public interface dme_scatter_vc_calc public subroutine dme_scatter_vc_calc_no_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate assuming the wave functions do not\n depend on the spin. Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose public subroutine dme_scatter_vc_calc_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate. Wave functions are 2 component spinors\n in S_z basis Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G,2) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G,2) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose Subroutines public subroutine dme_scatter_vc_calc_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate. Wave functions are 2 component spinors\n in S_z basis Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G,2) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G,2) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose public subroutine dme_scatter_vc_calc_no_spin (binned_rate_t, wfc_FT_i, wfc_FT_f, val_id, cond_id, n_FFT_grid, k_cut, wfc_fft_plan, Tif_fft_plan, verbose) Computes the valence to conduction scattering rate assuming the wave functions do not\n depend on the spin. Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) complex(kind=dp) :: wfc_FT_f (n_k,n_in_G) integer :: val_id integer :: cond_id integer :: n_FFT_grid (3) integer :: k_cut integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_vc.html"},{"title":"exdm_scatter_vc – EXCEED-DM","text":"Compute the scattering rate from valence to conduction states Uses prec numerics_input control_input material_input DFT_parameters FFT_util transition calc_exdm_scatter_vc Contents Subroutines run_dme_scatter_vc time_exdm_scatter_vc_calc Subroutines public subroutine run_dme_scatter_vc (binned_rate_t, n_tran_per_proc, DFT_input_filename, out_filename, proc_id, root_process, verbose) only load these variables if they haven't been loaded before\n to compute the dielectric Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose public subroutine time_exdm_scatter_vc_calc (DFT_input_filename, tran_id, wfc_fft_plan, Tif_fft_plan, n_FFT_grid, verbose) Times the v -> c scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id integer :: wfc_fft_plan (8) integer :: Tif_fft_plan (8) integer :: n_FFT_grid (3) logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_vc.html"},{"title":"calc_exdm_scatter_vf – EXCEED-DM","text":"Uses prec constants math_mod numerics_input material_input particle_physics_scatter DFT_parameters in_med_scr Zeff_input Contents Subroutines dme_scatter_vf_calc Subroutines public subroutine dme_scatter_vf_calc (binned_rate_t, wfc_FT_i, val_id, log_omegas, k_cut, angular_mesh, verbose) Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (n_q_bins+1,n_E_bins+1,n_mX,n_FDM,n_time) complex(kind=dp) :: wfc_FT_i (n_k,n_in_G) integer :: val_id real(kind=dp) :: log_omegas (2) integer :: k_cut real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_vf.html"},{"title":"exdm_scatter_vf – EXCEED-DM","text":"Compute the scattering rate from valence to free states Uses prec math_mod control_input numerics_input material_input DFT_parameters particle_physics_scatter transition Zeff_input calc_exdm_scatter_vf Contents Subroutines run_dme_scatter_vf time_exdm_scatter_vf_calc Subroutines public subroutine run_dme_scatter_vf (binned_rate_t, n_tran_per_proc, DFT_input_filename, nml_input_filename, out_filename, proc_id, root_process, verbose) only load these variables if they haven't been loaded before\n to compute the dielectric Arguments Type Intent Optional Attributes Name real(kind=dp) :: binned_rate_t (:,:,:,:,:,:) integer :: n_tran_per_proc character(len=*) :: DFT_input_filename character(len=*) :: nml_input_filename character(len=*) :: out_filename integer :: proc_id integer :: root_process logical, optional :: verbose public subroutine time_exdm_scatter_vf_calc (DFT_input_filename, tran_id, log_omega_table, angular_mesh, verbose) Times the v -> f scattering rate calculation Arguments Type Intent Optional Attributes Name character(len=*) :: DFT_input_filename integer :: tran_id real(kind=dp) :: log_omega_table (n_fin,2) real(kind=dp) :: angular_mesh (n_kf_theta*n_kf_phi,2) logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_vf.html"},{"title":"exdm – EXCEED-DM","text":"Uses iso_fortran_env mpi version_control control_input timing io_input material_input dme_absorption exdm_scatter EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct\n detection of Dark Matter Contents Variables proc_id n_proc n_proc_str root_process err verbose Variables Type Attributes Name Initial integer :: proc_id Open MPI, processor ID integer :: n_proc Open MPI, number of processors character(len=64) :: n_proc_str Number of processors in string format integer :: root_process = 0 Open MPI, root processor ID integer :: err Open MPI error code logical :: verbose = .FALSE. If verbose = .TRUE., print output","tags":"","loc":"program/exdm.html"}]}