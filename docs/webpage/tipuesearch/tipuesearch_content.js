var tipuesearch = {"pages":[{"title":" EXCEED-DM ","text":"EXCEED-DM Developer Info Tanner Trickle","tags":"home","loc":"index.html"},{"title":"control_input.f90 – EXCEED-DM","text":"Contents Modules control_input Source Code control_input.f90 Source Code module control_input !! Collection of variables controlling how `EXCEED-DM` is run, i.e. what is computed and how it is computed. use info_messages implicit none type control_t !! Stores all variables associated with the program control. character ( len = 64 ) :: process = '' character ( len = 64 ) :: calc_mode = '' logical :: timer = . TRUE . !! Optional !! !! If .TRUE. the program will output timing information logical :: quiet = . FALSE . !! Don't print any output logical :: overwrite_output = . FALSE . !! If .TRUE. the output file will be overwritten contains procedure :: print => print_control procedure :: load => load_control_nml procedure :: save => save_control end type contains subroutine save_control ( self , filename , verbose ) !! Saves `control`. use hdf5 use h5lt use info_messages implicit none class ( control_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving control parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'control' , group_id , error ) ! write data call h5ltmake_dataset_string_f ( file_id , & 'control/process' , & trim ( self % process ), & error ) call h5ltmake_dataset_string_f ( file_id , & 'control/calc_mode' , & trim ( self % calc_mode ), & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine print_control ( self , verbose ) !! Prints `control` components. implicit none class ( control_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -------' print * , '    Control' print * , '    -------' print * print * , '        Physics process  : ' , trim ( self % process ) print * , '        Calculation mode : ' , trim ( self % calc_mode ) print * , '        Timing?          : ' , self % timer print * call print_section_seperator () print * end if end subroutine subroutine load_control_nml ( self , filename , verbose ) !! Loads `control` parameters from a namelist. implicit none class ( control_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error ! namelist logical :: timer = . TRUE . logical :: quiet = . FALSE . character ( len = 64 ) :: process = '' character ( len = 64 ) :: calc_mode = '' logical :: overwrite_output = . FALSE . NAMELIST / control / timer , & quiet , & process , & calc_mode , & overwrite_output if ( verbose ) then print * , 'Loading control parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = control , iostat = error ) close ( 100 ) if ( error /= 0 ) then call print_error_message (& 'Problem reading control namelist.' ,& verbose = verbose ) stop end if self % timer = timer self % quiet = quiet self % process = process self % calc_mode = calc_mode self % overwrite_output = overwrite_output call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for control parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/control_input.f90.html"},{"title":"exdm.f90 – EXCEED-DM","text":"Contents Programs exdm Source Code exdm.f90 Source Code program exdm !! EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct detection of Dark Matter !! !! Github    : https://github.com/tanner-trickle/EXCEED-DM use iso_fortran_env use mpi use info_messages use timing use version_control use control_input use io_input use material_type use dm_model_type use expt_type use exdm_absorption use exdm_scatter use exdm_dielectric implicit none integer :: proc_id !! Processor ID integer :: n_proc !! Number of processors integer :: root_process = 0 !! Root processor ID integer :: err !! Error code character ( len = 512 ) :: nml_input_filename = '' !! Namelist input filename. logical :: verbose = . FALSE . !! If verbose = .TRUE., print output type ( control_t ) :: main_control !! Control parameters type ( io_files_t ) :: io_files !! Input/output filenames type ( material_t ) :: target_mat !! The target material type ( dm_model_t ) :: dm_model !! Dark matter model parameters type ( expt_t ) :: expt !! Experimental parameters ! Initialize MPI call MPI_INIT ( err ) call MPI_COMM_RANK ( MPI_COMM_WORLD , proc_id , err ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) call exdm_startup_message ( proc_id , root_process , n_proc , version ) call get_command_argument ( 1 , nml_input_filename ) ! start timing the program if ( proc_id == root_process ) then time ( 1 ) = MPI_Wtime () end if ! load inputs if ( proc_id == root_process ) then call main_control % load ( nml_input_filename , verbose = . TRUE .) if ( main_control % quiet ) then verbose = . FALSE . else verbose = . TRUE . end if else call main_control % load ( nml_input_filename , verbose = . FALSE .) end if call io_files % load ( nml_input_filename , verbose = verbose ) call target_mat % load ( io_files % nml_input_filename , verbose = verbose ) call dm_model % load ( io_files % nml_input_filename , verbose = verbose ) call expt % load ( io_files % nml_input_filename , verbose = verbose ) ! create the output file if ( proc_id == root_process ) then call create_output_file (& io_files ,& main_control % overwrite_output ,& verbose = verbose ) end if ! compute and save data if ( trim ( main_control % process ) == 'scatter' ) then call run_exdm_scatter ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , expt , & dm_model , verbose = verbose ) else if ( trim ( main_control % process ) == 'absorption' ) then call run_exdm_absorption ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , expt , & dm_model , verbose = verbose ) else if ( trim ( main_control % process ) == 'dielectric' ) then call run_exdm_dielectric ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , verbose = verbose ) else call print_error_message (& 'Process : ' // trim ( main_control % process ) // ' is not implemented.' , & verbose = verbose ) stop end if ! save input data common to all processes if ( proc_id == root_process ) then call target_mat % save ( io_files % out_filename , verbose = verbose ) call io_files % save ( io_files % out_filename , verbose = verbose ) call main_control % save ( io_files % out_filename , verbose = verbose ) if ( trim ( main_control % process ) /= 'dielectric' ) then call dm_model % save ( io_files % out_filename , verbose = verbose ) call expt % save ( io_files % out_filename , verbose = verbose ) end if call save_version ( io_files % out_filename , verbose = verbose ) end if ! Time program if ( proc_id == root_process ) then time ( 2 ) = MPI_Wtime () call print_timing_info ( time ( 2 ) - time ( 1 ), verbose = verbose ) call save_timing_info ( io_files % out_filename , time ( 2 ) - time ( 1 ), verbose = verbose ) end if call exdm_shutdown_message ( proc_id , root_process ) call MPI_FINALIZE ( err ) end program","tags":"","loc":"sourcefile/exdm.f90.html"},{"title":"io_input.f90 – EXCEED-DM","text":"Contents Modules io_input Source Code io_input.f90 Source Code module io_input !! Input and output filenames. use info_messages implicit none type io_files_t !! All input and output filenames. character ( len = 512 ) :: nml_input_filename = '' !! Namelist input filename character ( len = 512 ) :: PW_data_filename = '' !! Bloch wave function coefficient file name character ( len = 64 ) :: run_description = '' !! description of the calculation character ( len = 512 ) :: out_folder = '.' !! Ouput folder character ( len = 512 ) :: out_filename = '' !! Output filename !! !! Setting this variable overrides the settings of out_folder !! and run_description character ( len = 512 ) :: sto_data_filename = '' !! Input file specifying the Slater type orbital (sto) !! wave function coefficients for the core electron !! states character ( len = 512 ) :: core_elec_config_filename = '' !! File specifying the core electron configuration character ( len = 512 ) :: dielectric_filename = '' !! File specifying the dielectric function. If the dielectric !! will be computed this will be where the computed values are !! stored. If this file already exists, the dielectric function !! will be loaded from this file. contains procedure :: print => print_io procedure :: load => load_io_nml procedure :: save => save_io end type contains subroutine save_io ( self , filename , verbose ) !! Saves `io_files`. use hdf5 use h5lt use info_messages implicit none class ( io_files_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving I/O parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'io' , group_id , error ) ! write data call h5ltmake_dataset_string_f ( file_id , & 'io/nml_input_filename' , & trim ( self % nml_input_filename ), & error ) call h5ltmake_dataset_string_f ( file_id , & 'io/PW_data_filename' , & trim ( self % PW_data_filename ), & error ) call h5ltmake_dataset_string_f ( file_id , & 'io/sto_data_filename' , & trim ( self % sto_data_filename ), & error ) call h5ltmake_dataset_string_f ( file_id , & 'io/core_elec_config_filename' , & trim ( self % core_elec_config_filename ), & error ) call h5ltmake_dataset_string_f ( file_id , & 'io/dielectric_filename' , & trim ( self % dielectric_filename ), & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine print_io ( self , verbose ) !! Prints `io_files` components. implicit none class ( io_files_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ---' print * , '    I/O' print * , '    ---' print * print * , '        PW data file         : ' , trim ( self % PW_data_filename ) print * , '        STO data file        : ' , trim ( self % sto_data_filename ) print * , '        Core electron config : ' , trim ( self % core_elec_config_filename ) print * , '        Dielectric           : ' , trim ( self % dielectric_filename ) print * call print_section_seperator () print * end if end subroutine subroutine load_io_nml ( self , filename , verbose ) !! Loads `io` parameters from a namelist. implicit none class ( io_files_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error ! namelist character ( len = 512 ) :: PW_data_filename = '' !! DFT calculations input file character ( len = 64 ) :: run_description = '' !! description of the calculation character ( len = 512 ) :: out_folder = '.' !! Ouput folder character ( len = 512 ) :: out_filename = '' !! Output filename !! !! Setting this variable overrides the settings of out_folder !! and run_description character ( len = 512 ) :: sto_data_filename = '' !! Input file specifying the Slater type orbital (sto) !! wave function coefficients for the core electron !! states character ( len = 512 ) :: core_elec_config_filename = '' !! File specifying the core electron configuration character ( len = 512 ) :: dielectric_filename = '' !! File specifying the dielectric function. If the dielectric !! will be computed this will be where the computed values are !! stored. If this file already exists, the dielectric function !! will be loaded from this file. NAMELIST / io / PW_data_filename , & run_description , & out_folder , & out_filename , & sto_data_filename , & core_elec_config_filename , & dielectric_filename if ( verbose ) then print * , 'Loading IO parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = io , iostat = error ) close ( 100 ) if ( error /= 0 ) then call print_error_message (& 'Problem reading IO namelist.' , & verbose = verbose ) stop end if self % nml_input_filename = filename self % PW_data_filename = PW_data_filename self % sto_data_filename = sto_data_filename self % core_elec_config_filename = core_elec_config_filename self % dielectric_filename = dielectric_filename if ( trim ( out_filename ) . eq . '' ) then if ( trim ( run_description ) . eq . '' ) then out_filename = trim ( out_folder ) // '/EXDMout.hdf5' else out_filename = trim ( out_folder ) // '/EXDMout_' // trim ( run_description ) // '.hdf5' end if end if self % run_description = run_description self % out_folder = out_folder self % out_filename = out_filename call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for IO parameters : ' // trim ( filename ) // ' does NOT exist.' ,& verbose = verbose ) stop end if end subroutine recursive subroutine create_output_file ( io_files , overwrite_output , verbose ) !! Creates the output file, if the file already exists, tries to create a new file with a random number !! attached recursively until a number is found. use hdf5 use h5lt use prec implicit none type ( io_files_t ) :: io_files character ( len = 512 ) :: out_filename character ( len = 512 ) :: new_filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer :: error logical :: overwrite_output real ( dp ) :: r character ( len = 64 ) :: rand_num_str if ( verbose ) then print * , 'Creating output file...' print * end if out_filename = io_files % out_filename inquire ( file = out_filename , exist = file_exists ) if ( ( . not . file_exists ) . or . ( overwrite_output ) ) then call h5open_f ( error ) call h5fcreate_f ( trim ( out_filename ), H5F_ACC_TRUNC_F , file_id , error ) if ( error /= 0 ) then call print_error_message (& 'Could not create output file : ' // trim ( out_filename ),& verbose = verbose ) stop end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call random_number ( r ) write ( rand_num_str , * ) int ( 10 ** 3 * r ) new_filename = './EXDMout_' // trim ( adjustl ( rand_num_str )) // '.hdf5' call print_warning_message (& 'Output file : ' // trim ( out_filename ) // & ' already exists. Attempting to set output filename to :' // & trim ( new_filename ),& verbose = verbose ) io_files % out_filename = new_filename call create_output_file ( io_files , . FALSE ., verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/io_input.f90.html"},{"title":"abs_calc_PI.f90 – EXCEED-DM","text":"Contents Modules abs_calc_PI Source Code abs_calc_PI.f90 Source Code module abs_calc_PI !! Computes self-energies,  \\Pi_{\\mathcal{O}_1, \\mathcal{O}_2} , for absorption rate calculations. use mpi use hdf5 use h5lt use prec use constants use width_parameters_type use PW_dataset_type use dm_model_type use material_type use MPI_util implicit none interface calc_pi_v2_v2 module procedure calc_pi_v2_v2_no_spin module procedure calc_pi_v2_v2_spin end interface interface calc_pi_1_1_mat module procedure calc_pi_1_1_mat_no_spin module procedure calc_pi_1_1_mat_spin end interface interface calc_pi_vi_vj module procedure calc_pi_vi_vj_no_spin module procedure calc_pi_vi_vj_spin end interface interface calc_abs_Pi module procedure calc_abs_Pi_no_spin module procedure calc_abs_Pi_spin end interface contains subroutine calc_abs_Pi_no_spin ( proc_id , root_process , & tran_form_1_job , tran_form_v_job , tran_form_v2_job , & pi_v2_v2 , pi_vi_vj , pi_1_1_mat , ik_manager , job_id_to_ik , & PW_dataset , widths , dm_model , target_mat , filename , verbose ) !! Compute the self energies with spin independent wave functions. implicit none integer :: proc_id integer :: root_process complex ( dp ) :: tran_form_1_job (:, :) complex ( dp ) :: tran_form_v_job (:, :, :) complex ( dp ) :: tran_form_v2_job (:, :) complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: pi_1_1_mat (:, :, :, :) type ( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:, :) type ( PW_dataset_t ) :: PW_dataset type ( width_parameters_t ) :: widths type ( dm_model_t ) :: dm_model type ( material_t ) :: target_mat character ( len =* ) :: filename logical , optional :: verbose complex ( dp ), allocatable :: pi_v2_v2_job (:, :, :) !! Dim : [n_omega, n_widths, n_tran_per_proc] !! !! self energy with two v&#94;2 insertions !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_1_1_mat_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! self energy, without q_vec's !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_vi_vj_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! Units : eV&#94;2 integer :: j , job_id , val_id , k if ( verbose ) then print * , 'Computing self energies...' print * end if ! allocate job variables allocate ( pi_v2_v2_job ( size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_v2_v2_job = ( 0.0_dp , 0.0_dp ) allocate ( pi_vi_vj_job ( 3 , 3 , size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_vi_vj_job = ( 0.0_dp , 0.0_dp ) allocate ( pi_1_1_mat_job ( 3 , 3 , size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_1_1_mat_job = ( 0.0_dp , 0.0_dp ) do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then val_id = job_id_to_ik ( job_id , 1 ) k = job_id_to_ik ( job_id , 2 ) call calc_pi_v2_v2 ( pi_v2_v2_job (:, :, j ), tran_form_v2_job ( j , :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) call calc_pi_1_1_mat ( pi_1_1_mat_job (:, :, :, :, j ), tran_form_v_job (:, j , :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) call calc_pi_vi_vj ( pi_vi_vj_job (:, :, :, :, j ), tran_form_v_job (:, j , :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) end if end do if ( verbose ) then print * , 'Done computing self energies!' print * end if call ik_manager % comm_self_energies ( proc_id , root_process , & pi_v2_v2_job , pi_1_1_mat_job , pi_vi_vj_job , & pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose = verbose ) if ( proc_id == root_process ) then call save_self_energies ( filename , pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose = verbose ) end if end subroutine subroutine calc_abs_Pi_spin ( proc_id , root_process , & tran_form_1_job , tran_form_v_job , tran_form_v2_job , & pi_v2_v2 , pi_vi_vj , pi_1_1_mat , ik_manager , job_id_to_ik , & PW_dataset , widths , dm_model , target_mat , filename , verbose ) !! Compute the self energies with spin dependent wave functions. implicit none integer :: proc_id integer :: root_process complex ( dp ) :: tran_form_1_job (:, :, :, :) complex ( dp ) :: tran_form_v_job (:, :, :, :, :) complex ( dp ) :: tran_form_v2_job (:, :, :, :) complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: pi_1_1_mat (:, :, :, :) type ( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:, :) type ( PW_dataset_t ) :: PW_dataset type ( width_parameters_t ) :: widths type ( dm_model_t ) :: dm_model type ( material_t ) :: target_mat character ( len =* ) :: filename logical , optional :: verbose complex ( dp ), allocatable :: pi_v2_v2_job (:, :, :) !! Dim : [n_omega, n_widths, n_tran_per_proc] !! !! self energy with two v&#94;2 insertions !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_1_1_mat_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! self energy, without q_vec's !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_vi_vj_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! Units : eV&#94;2 integer :: j , job_id , val_id , k if ( verbose ) then print * , 'Computing self energies...' print * end if ! allocate job variables allocate ( pi_v2_v2_job ( size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_v2_v2_job = ( 0.0_dp , 0.0_dp ) allocate ( pi_vi_vj_job ( 3 , 3 , size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_vi_vj_job = ( 0.0_dp , 0.0_dp ) allocate ( pi_1_1_mat_job ( 3 , 3 , size ( pi_v2_v2 , 1 ), size ( pi_v2_v2 , 2 ), ik_manager % n_jobs_per_proc )) pi_1_1_mat_job = ( 0.0_dp , 0.0_dp ) do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then val_id = job_id_to_ik ( job_id , 1 ) k = job_id_to_ik ( job_id , 2 ) call calc_pi_v2_v2 ( pi_v2_v2_job (:, :, j ), tran_form_v2_job ( j , :, :, :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) call calc_pi_1_1_mat ( pi_1_1_mat_job (:, :, :, :, j ), tran_form_v_job (:, j , :, :, :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) call calc_pi_vi_vj ( pi_vi_vj_job (:, :, :, :, j ), tran_form_v_job (:, j , :, :, :), & dm_model , widths , PW_dataset , target_mat , val_id , k ) end if end do if ( verbose ) then print * , 'Done computing self energies!' print * end if call ik_manager % comm_self_energies ( proc_id , root_process , & pi_v2_v2_job , pi_1_1_mat_job , pi_vi_vj_job , & pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose = verbose ) if ( proc_id == root_process ) then call save_self_energies ( filename , pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose = verbose ) end if end subroutine subroutine calc_pi_v2_v2_no_spin ( pi_v2_v2 , tran_form_v2 , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !* Compute  \\Pi_{\\bar v&#94;2, \\bar v&#94;2}  from spin independent wave functions. ! ! Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown ! that  \\mathrm{Im} \\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2} \\sim \\omega&#94;2  as  \\omega \\rightarrow 0  (for the gapped targets of ! interest here). See discussion in calculation of  \\Pi_{v_i, v_j}  for more details. ! ! [TODO] Check if this procedure is valid for  \\mathrm{Re} \\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2}  or !  \\mathrm{Re}\\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2} +  (constant term). implicit none complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: tran_form_v2 (:) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id real ( dp ) :: omega , width , omega_if do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v2 , 1 ) cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_v2_v2 ( w , p ) = pi_v2_v2 ( w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * ( 0.25_dp ) * & ( omega / omega_if ) ** 2 * & (& ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & abs ( tran_form_v2 ( f )) ** 2 * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine calc_pi_v2_v2_spin ( pi_v2_v2 , tran_form_v2 , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !* Compute  \\Pi_{\\bar v&#94;2, \\bar v&#94;2}  from spin dependent wave functions. ! ! Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown ! that  \\mathrm{Im} \\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2} \\sim \\omega&#94;2  as  \\omega \\rightarrow 0  (for the gapped targets of ! interest here). See discussion in calculation of  \\Pi_{v_i, v_j}  for more details. ! ! [TODO] Check if this procedure is valid for  \\mathrm{Re} \\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2}  or !  \\mathrm{Re}\\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2} +  (constant term). implicit none complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: tran_form_v2 (:, :, :) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id , s real ( dp ) :: omega , width , omega_if complex ( dp ) :: tf do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v2 , 1 ) tf = ( 0.0_dp , 0.0_dp ) do s = 1 , 2 tf = tf + tran_form_v2 ( f , s , s ) end do cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_v2_v2 ( w , p ) = pi_v2_v2 ( w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * ( 0.25_dp ) * & ( omega / omega_if ) ** 2 * & (& ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & abs ( tf ) ** 2 * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine calc_pi_1_1_mat_no_spin ( pi_1_1_mat , tran_form_v , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !! Compute  \\mathbf{\\Pi}_{11}  from spin independent wave functions. implicit none complex ( dp ) :: pi_1_1_mat (:, :, :, :) complex ( dp ) :: tran_form_v (:, :) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id , i , j real ( dp ) :: omega , width , omega_if complex ( dp ) :: outer_ff ( 3 , 3 , size ( tran_form_v , 2 )) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val do i = 1 , 3 do j = 1 , 3 omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) outer_ff ( i , j , f ) = ( m_elec / omega_if ) ** 2 * conjg ( tran_form_v ( i , f )) * tran_form_v ( j , f ) end do end do end do do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_1_1_mat (:, :, w , p ) = pi_1_1_mat (:, :, w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * & ( & ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & outer_ff (:, :, f ) * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine calc_pi_1_1_mat_spin ( pi_1_1_mat , tran_form_v , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !! Compute  \\mathbf{\\Pi}_{11}  from spin dependent wave functions. implicit none complex ( dp ) :: pi_1_1_mat (:, :, :, :) complex ( dp ) :: tran_form_v (:, :, :, :) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id , s , i , j real ( dp ) :: omega , width , omega_if complex ( dp ) :: outer_ff ( 3 , 3 , size ( tran_form_v , 2 )) complex ( dp ) :: tf_v ( 3 ) do f = 1 , size ( tran_form_v , 2 ) tf_v = ( 0.0_dp , 0.0_dp ) do s = 1 , 2 tf_v = tf_v + tran_form_v (:, f , s , s ) end do cond_id = f + PW_dataset % n_val do i = 1 , 3 do j = 1 , 3 omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) outer_ff ( i , j , f ) = ( m_elec / omega_if ) ** 2 * conjg ( tf_v ( i )) * tf_v ( j ) end do end do end do do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_1_1_mat (:, :, w , p ) = pi_1_1_mat (:, :, w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * & ( & ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & outer_ff (:, :, f ) * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine calc_pi_vi_vj_no_spin ( pi_vi_vj , tran_form_v , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !* Compute  \\Pi_{v&#94;i, v&#94;j}  from spin independent wave functions. ! ! Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown ! that  \\mathrm{Im} \\Pi_{v_i, v_j} \\sim \\omega&#94;2  as  \\omega \\rightarrow 0  (for the gapped targets of interest ! here). If one naively computes  \\Pi_{v_i, v_j}  numerically you find that  \\Pi_{v_i, v_j} \\sim \\delta  as  ! \\omega \\rightarow 0 . While alone this does not look problematic since  \\Pi_{v_i, v_j}  itself is converging, the ! calculation of other physical quantities, such as the dielectric  \\propto \\Pi_{v_i, v_j}/\\omega&#94;2 , will diverge. ! ! This is remedied by explicitly only computing the first non-divergent term, which can be shown, see ! https://journals.aps.org/prb/pdf/10.1103/PhysRevB.48.11705, to be related to the naive calculation with the addition of a !  ( \\omega / \\omega_{ii'\\mathbf{k}})&#94;2  term inside the 1BZ sum. We follow that procedure here. ! ! [TODO] Check if this procedure is valid for  \\mathrm{Re} \\Pi_{v_i, v_j}  or  \\mathrm{Re} \\Pi_{v_i, v_j} +  ! (constant term). implicit none complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: tran_form_v (:, :) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id , i , j real ( dp ) :: omega , width , omega_if complex ( dp ) :: outer_ff ( 3 , 3 , size ( tran_form_v , 2 )) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val do i = 1 , 3 do j = 1 , 3 omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) outer_ff ( i , j , f ) = conjg ( tran_form_v ( i , f )) * tran_form_v ( j , f ) end do end do end do do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_vi_vj (:, :, w , p ) = pi_vi_vj (:, :, w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * & ( omega / omega_if ) ** 2 * & ( & ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & outer_ff (:, :, f ) * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine calc_pi_vi_vj_spin ( pi_vi_vj , tran_form_v , & dm_model , widths , PW_dataset , target_mat , val_id , k ) !* Compute  \\Pi_{v&#94;i, v&#94;j}  from spin dependent wave functions. ! ! Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown ! that  \\mathrm{Im} \\Pi_{v_i, v_j} \\sim \\omega&#94;2  as  \\omega \\rightarrow 0  (for the gapped targets of interest ! here). If one naively computes  \\Pi_{v_i, v_j}  numerically you find that  \\Pi_{v_i, v_j} \\sim \\delta  as  ! \\omega \\rightarow 0 . While alone this does not look problematic since  \\Pi_{v_i, v_j}  itself is converging, the ! calculation of other physical quantities, such as the dielectric  \\propto \\Pi_{v_i, v_j}/\\omega&#94;2 , will diverge. ! ! This is remedied by explicitly only computing the first non-divergent term, which can be shown, see ! https://journals.aps.org/prb/pdf/10.1103/PhysRevB.48.11705, to be related to the naive calculation with the addition of a !  ( \\omega / \\omega_{ii'\\mathbf{k}})&#94;2  term inside the 1BZ sum. We follow that procedure here. ! ! [TODO] Check if this procedure is valid for  \\mathrm{Re} \\Pi_{v_i, v_j}  or  \\mathrm{Re} \\Pi_{v_i, v_j} +  ! (constant term). implicit none complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: tran_form_v (:, :, :, :) type ( dm_model_t ) :: dm_model type ( width_parameters_t ) :: widths type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat integer :: val_id , k integer :: w , p , f , cond_id , s , i , j real ( dp ) :: omega , width , omega_if complex ( dp ) :: outer_ff ( 3 , 3 , size ( tran_form_v , 2 )) complex ( dp ) :: tf_v ( 3 ) do f = 1 , size ( tran_form_v , 2 ) tf_v = ( 0.0_dp , 0.0_dp ) do s = 1 , 2 tf_v = tf_v + tran_form_v (:, f , s , s ) end do cond_id = f + PW_dataset % n_val do i = 1 , 3 do j = 1 , 3 omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) outer_ff ( i , j , f ) = conjg ( tf_v ( i )) * tf_v ( j ) end do end do end do do p = 1 , widths % n do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) width = widths % get_width ( p , omega ) do f = 1 , size ( tran_form_v , 2 ) cond_id = f + PW_dataset % n_val omega_if = PW_dataset % energy_bands ( k , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( abs ( omega - omega_if ) < widths % sigma * width ) then pi_vi_vj (:, :, w , p ) = pi_vi_vj (:, :, w , p ) + & ( target_mat % pc_vol ) ** ( - 1 ) * PW_dataset % k_weight ( k ) * & ( omega / omega_if ) ** 2 * & ( & ( omega - omega_if + ii * width ) ** ( - 1 ) - & ( omega + omega_if - ii * width ) ** ( - 1 ) & ) * & outer_ff (:, :, f ) * ( PW_dataset % spin_degen / 2.0_dp ) end if end do end do end do end subroutine subroutine save_self_energies ( filename , & pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose ) !! Saves the self energies,  \\Pi_{\\mathcal{O}_1, \\mathcal{O}_2} . implicit none character ( len =* ) :: filename complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: pi_1_1_mat (:, :, :, :) logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer ( HSIZE_T ) :: dims3 ( 3 ) integer :: error integer :: m , f , t integer :: i , fin if ( verbose ) then print * , 'Saving self energies...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'self_energies' , group_id , error ) do i = 1 , size ( pi_v2_v2 , 2 ) call h5gcreate_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))),& group_id , error ) dims1 = [ size ( pi_v2_v2 , 1 )] call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_v2_v2_r' , & size ( dims1 ), dims1 ,& real ( pi_v2_v2 (:, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_v2_v2_c' , & size ( dims1 ), dims1 ,& aimag ( pi_v2_v2 (:, i )), error ) dims3 = [ 3 , 3 , size ( pi_v2_v2 , 1 )] call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_1_1_mat_r' , & size ( dims3 ), dims3 ,& real ( pi_1_1_mat (:, :, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_1_1_mat_c' , & size ( dims3 ), dims3 ,& aimag ( pi_1_1_mat (:, :, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_vi_vj_r' , & size ( dims3 ), dims3 ,& real ( pi_vi_vj (:, :, :, i )), error ) call h5ltmake_dataset_double_f ( file_id ,& 'self_energies' // & '/width_' // trim ( adjustl ( int_to_str ( i ))) // & '/pi_vi_vj_c' , & size ( dims3 ), dims3 ,& aimag ( pi_vi_vj (:, :, :, i )), error ) end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/abs_calc_pi.f90.html"},{"title":"abs_tran_form_calc.f90 – EXCEED-DM","text":"Contents Modules abs_tran_form_calc Source Code abs_tran_form_calc.f90 Source Code module abs_tran_form_calc !! Computes the transition form factors,  f , for absorption rate calculation. use prec use constants use MPI_util use PW_dataset_type use numerics_abs implicit none ! Compute different transition form factors for spin-independent ! and spin-dependent wave functions interface calc_tran_form_1 module procedure calc_tran_form_1_no_spin module procedure calc_tran_form_1_spin end interface interface calc_tran_form_v module procedure calc_tran_form_v_no_spin module procedure calc_tran_form_v_spin end interface interface calc_tran_form_v2 module procedure calc_tran_form_v2_no_spin module procedure calc_tran_form_v2_spin end interface contains subroutine calc_abs_tran_form ( proc_id , root_process , & tran_form_1_no_spin_job , tran_form_1_spin_job , & tran_form_v_no_spin_job , tran_form_v_spin_job , & tran_form_v2_no_spin_job , tran_form_v2_spin_job , & PW_dataset , ik_manager , job_id_to_ik , numerics , & filename , & verbose ) !! Computes all of the transition form factors, !!  f_{i, i', \\mathbf{k}}, \\mathbf{f}_{i, i', \\mathbf{k}}, \\widetilde{f}_{i, i', \\mathbf{k}}  !! (with extra  s, s'  spin indicies if the wave functions are spin dependent) for the !! DM absorption calculation. implicit none integer :: proc_id integer :: root_process complex ( dp ) :: tran_form_1_no_spin_job (:, :) complex ( dp ) :: tran_form_1_spin_job (:, :, :, :) complex ( dp ) :: tran_form_v_no_spin_job (:, :, :) complex ( dp ) :: tran_form_v_spin_job (:, :, :, :, :) complex ( dp ) :: tran_form_v2_no_spin_job (:, :) complex ( dp ) :: tran_form_v2_spin_job (:, :, :, :) type ( PW_dataset_t ) :: PW_dataset type ( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:, :) type ( numerics_abs_t ) :: numerics character ( len =* ) :: filename logical , optional :: verbose complex ( dp ), allocatable :: tran_form_1_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ), allocatable :: tran_form_1_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_no_spin (:, :, :, :) !! Dim : [3, n_init, n_fin, n_k] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_spin (:, :, :, :, :, :) !! Dim : [3, n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None integer :: j , job_id , f integer :: val_id , k , cond_id complex ( dp ), allocatable :: wfc_FT_ik (:) complex ( dp ), allocatable :: wfc_FT_fk (:) complex ( dp ), allocatable :: wfc_FT_iks (:, :) complex ( dp ), allocatable :: wfc_FT_fks (:, :) if ( verbose ) then print * , 'Computing transition form factors...' print * end if ! allocate wave function data if ( PW_dataset % include_spin ) then allocate ( wfc_FT_iks ( PW_dataset % n_G , 2 )) allocate ( wfc_FT_fks ( PW_dataset % n_G , 2 )) else allocate ( wfc_FT_ik ( PW_dataset % n_G )) allocate ( wfc_FT_fk ( PW_dataset % n_G )) end if ! compute processor specific variables do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then val_id = job_id_to_ik ( job_id , 1 ) k = job_id_to_ik ( job_id , 2 ) if ( PW_dataset % include_spin ) then ! load initial wave function call PW_dataset % load_wfc_FT_ik_spin ( val_id , k , wfc_FT_iks ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f ! load final wave function call PW_dataset % load_wfc_FT_ik_spin ( cond_id , k , wfc_FT_fks ) call calc_tran_form_1 ( tran_form_1_spin_job ( j , f , :, :), & PW_dataset , val_id , cond_id , k , wfc_FT_iks , wfc_FT_fks ) call calc_tran_form_v ( tran_form_v_spin_job (:, j , f , :, :), & PW_dataset , val_id , cond_id , k , wfc_FT_iks , wfc_FT_fks ) call calc_tran_form_v2 ( tran_form_v2_spin_job ( j , f , :, :), & PW_dataset , val_id , cond_id , k , wfc_FT_iks , wfc_FT_fks ) end do else ! load initial wave function call PW_dataset % load_wfc_FT_ik_no_spin ( val_id , k , wfc_FT_ik ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f call PW_dataset % load_wfc_FT_ik_no_spin ( cond_id , k , wfc_FT_fk ) call calc_tran_form_1 ( tran_form_1_no_spin_job ( j , f ), & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) call calc_tran_form_v ( tran_form_v_no_spin_job (:, j , f ), & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) call calc_tran_form_v2 ( tran_form_v2_no_spin_job ( j , f ), & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) end do end if end if end do if ( verbose ) then print * , 'Done computing transition form factors!' print * end if if ( numerics % save_tran_form ) then if ( proc_id == root_process ) then allocate ( tran_form_1_no_spin ( numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k )) tran_form_1_no_spin = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_1_spin ( numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k , 2 , 2 )) tran_form_1_spin = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_no_spin ( 3 , numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k )) tran_form_v_no_spin = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_spin ( 3 , numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k , 2 , 2 )) tran_form_v_spin = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_no_spin ( numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k )) tran_form_v2_no_spin = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_spin ( numerics % n_val_max , numerics % n_cond_max , PW_dataset % n_k , 2 , 2 )) tran_form_v2_spin = ( 0.0_dp , 0.0_dp ) end if ! communicate the jobs to the main processor call ik_manager % comm_abs_tran_form ( proc_id , root_process , job_id_to_ik , & tran_form_1_no_spin_job , tran_form_1_spin_job , & tran_form_v_no_spin_job , tran_form_v_spin_job , & tran_form_v2_no_spin_job , tran_form_v2_spin_job , & tran_form_1_no_spin , tran_form_1_spin , & tran_form_v_no_spin , tran_form_v_spin , & tran_form_v2_no_spin , tran_form_v2_spin , numerics , verbose = verbose ) ! save data if ( proc_id == root_process ) then call save_tran_form ( filename , & tran_form_1_no_spin , tran_form_1_spin , & tran_form_v_no_spin , tran_form_v_spin , & tran_form_v2_no_spin , tran_form_v2_spin , & PW_dataset % include_spin , verbose = verbose ) end if end if end subroutine subroutine calc_tran_form_1_no_spin ( tran_form_1 , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin independent scalar transition form factor: !! !! \\begin{align} !!      f_{i, i', \\mathbf{k}} = \\sum_\\mathbf{G} \\widetilde{u}_{i' \\mathbf{k} \\mathbf{G}}&#94;* \\widetilde{u}_{i \\mathbf{k} !! \\mathbf{G}} = \\delta_{i i'} \\nonumber !! \\end{align} !! !! for a given i, i', k. !! !! Have this function here for a consistent interface. This vanished by orthogonality of the !! wave functions. complex ( dp ) :: tran_form_1 type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:) complex ( dp ) :: wfc_FT_fk (:) if ( val_id /= cond_id ) then tran_form_1 = ( 0.0_dp , 0.0_dp ) end if end subroutine subroutine calc_tran_form_1_spin ( tran_form_1 , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin dependent scalar transition form factor: !! !! \\begin{align} !!      f_{i, i', \\mathbf{k}}&#94;{ss'} = \\sum_\\mathbf{G} {\\widetilde{u}_{i' \\mathbf{k} \\mathbf{G}}&#94;{s'}}&#94;* \\widetilde{u}_{i \\mathbf{k} !! \\mathbf{G}}&#94;s \\nonumber !! \\end{align} !! !! for a given i, i', k. !! !! Note: !! \\begin{align} !!      \\sum_{s} f_{i, i', \\mathbf{k}}&#94;{s s} = \\delta_{i i'} !! \\end{align} complex ( dp ) :: tran_form_1 (:, :) type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:, :) complex ( dp ) :: wfc_FT_fk (:, :) integer :: s , sp tran_form_1 = ( 0.0_dp , 0.0_dp ) if ( val_id /= cond_id ) then do s = 1 , 2 do sp = 1 , 2 tran_form_1 ( s , sp ) = tran_form_1 ( s , sp ) + sum ( conjg ( wfc_FT_fk (:, sp )) * wfc_FT_ik (:, s )) end do end do else tran_form_1 = ( 0.0_dp , 0.0_dp ) end if end subroutine subroutine calc_tran_form_v_no_spin ( tran_form_v , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin independent vector transition form factor: !! !! \\begin{align*} !!      \\mathbf{f}_{i, i', \\mathbf{k}} = \\frac{1}{m_e} \\sum_\\mathbf{G} (\\mathbf{k} + \\mathbf{G}) \\widetilde{u}_{i' \\mathbf{k} \\mathbf{G}}&#94;* \\widetilde{u}_{i \\mathbf{k} !! \\mathbf{G}} !! \\end{align*} !! !! for a given i, i', k. complex ( dp ) :: tran_form_v (:) type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:) complex ( dp ) :: wfc_FT_fk (:) integer :: g real ( dp ) :: p_vec ( 3 ) do g = 1 , PW_dataset % n_G p_vec = PW_dataset % k_grid_xyz ( k , :) + PW_dataset % G_grid_xyz ( g , :) tran_form_v = tran_form_v + & ( p_vec / m_elec ) * conjg ( wfc_FT_fk ( g )) * wfc_FT_ik ( g ) end do end subroutine subroutine calc_tran_form_v_spin ( tran_form_v , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin dependent vector transition form factor: !! !! \\begin{align*} !!      \\mathbf{f}_{i, i', \\mathbf{k}, s, s'} = \\frac{1}{m_e} \\sum_\\mathbf{G} (\\mathbf{k} + \\mathbf{G}) !! \\widetilde{u}_{i' \\mathbf{k} \\mathbf{G} s'}&#94;* \\widetilde{u}_{i \\mathbf{k} \\mathbf{G} s} !! \\end{align*} !! !! for a given i, i', k. complex ( dp ) :: tran_form_v (:, :, :) type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:, :) complex ( dp ) :: wfc_FT_fk (:, :) integer :: g , s , sp real ( dp ) :: p_vec ( 3 ) do s = 1 , 2 do sp = 1 , 2 do g = 1 , PW_dataset % n_G p_vec = PW_dataset % k_grid_xyz ( k , :) + PW_dataset % G_grid_xyz ( g , :) tran_form_v (:, s , sp ) = tran_form_v (:, s , sp ) + & ( p_vec / m_elec ) * conjg ( wfc_FT_fk ( g , sp )) * wfc_FT_ik ( g , s ) end do end do end do end subroutine subroutine calc_tran_form_v2_no_spin ( tran_form_v2 , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin independent  v&#94;2  transition form factor: !! !! \\begin{align} !!      \\widetilde{f}_{i, i', \\mathbf{k}} = \\frac{1}{m_e&#94;2} !!  \\sum_\\mathbf{G} ( \\mathbf{k} + \\mathbf{G} )&#94;2 \\widetilde{u}_{i' \\mathbf{k} \\mathbf{G}}&#94;* !! \\widetilde{u}_{i \\mathbf{k} \\mathbf{G}} !! \\end{align} !! !! for a given i, i', k. complex ( dp ) :: tran_form_v2 type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:) complex ( dp ) :: wfc_FT_fk (:) integer :: g real ( dp ) :: p_vec ( 3 ) real ( dp ) :: p_sq do g = 1 , PW_dataset % n_G p_vec = PW_dataset % k_grid_xyz ( k , :) + PW_dataset % G_grid_xyz ( g , :) p_sq = norm2 ( p_vec ) ** 2 tran_form_v2 = tran_form_v2 + & ( p_sq / m_elec ** 2 ) * conjg ( wfc_FT_fk ( g )) * wfc_FT_ik ( g ) end do end subroutine subroutine calc_tran_form_v2_spin ( tran_form_v2 , & PW_dataset , val_id , cond_id , k , wfc_FT_ik , wfc_FT_fk ) !! Computes the spin dependent  v&#94;2  transition form factor: !! !! \\begin{align} !!      \\widetilde{f}_{i, i', \\mathbf{k}, s, s'} = \\frac{1}{m_e&#94;2} !!  \\sum_\\mathbf{G} ( \\mathbf{k} + \\mathbf{G} )&#94;2 \\widetilde{u}_{i' \\mathbf{k} \\mathbf{G} s'}&#94;* !! \\widetilde{u}_{i \\mathbf{k} \\mathbf{G} s} !! \\end{align} !! !! for a given i, i', k. complex ( dp ) :: tran_form_v2 (:, :) type ( PW_dataset_t ) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex ( dp ) :: wfc_FT_ik (:, :) complex ( dp ) :: wfc_FT_fk (:, :) integer :: g , s , sp real ( dp ) :: p_vec ( 3 ) real ( dp ) :: p_sq do s = 1 , 2 do sp = 1 , 2 do g = 1 , PW_dataset % n_G p_vec = PW_dataset % k_grid_xyz ( k , :) + PW_dataset % G_grid_xyz ( g , :) p_sq = norm2 ( p_vec ) ** 2 tran_form_v2 ( s , sp ) = tran_form_v2 ( s , sp ) + & ( p_sq / m_elec ** 2 ) * conjg ( wfc_FT_fk ( g , sp )) * wfc_FT_ik ( g , s ) end do end do end do end subroutine subroutine save_tran_form ( filename , & tran_form_1_no_spin , tran_form_1_spin , & tran_form_v_no_spin , tran_form_v_spin , & tran_form_v2_no_spin , tran_form_v2_spin , & include_spin , verbose ) !! Saves the transition form factors,  f_{i, i', \\mathbf{k}}, !! \\mathbf{f}_{i, i', \\mathbf{k}}, \\widetilde{f}_{i, i', k}, !! with  s, s'  indicies if the wave functions are spin dependent. use info_messages implicit none character ( len =* ) :: filename logical , optional :: verbose logical :: include_spin complex ( dp ) :: tran_form_1_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_1_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v_no_spin (:, :, :, :) !! Dim : [3, n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_v_spin (:, :, :, :, :, :) !! Dim : [3, n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v2_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_v2_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer ( HSIZE_T ) :: dims3 ( 3 ) integer ( HSIZE_T ) :: dims4 ( 4 ) integer :: error integer :: m , f , t integer :: i , fin if ( verbose ) then print * , 'Saving absorption transition form factors...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'abs_tran_form' , group_id , error ) do i = 1 , size ( tran_form_1_no_spin , 1 ) call h5gcreate_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))),& group_id , error ) do fin = 1 , size ( tran_form_1_no_spin , 2 ) call h5gcreate_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))),& group_id , error ) if ( include_spin ) then dims3 = [ size ( tran_form_1_no_spin , 3 ), 2 , 2 ] call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_1_spin_r' , & size ( dims3 ), dims3 ,& real ( tran_form_1_spin ( i , fin , :, :, :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_1_spin_c' , & size ( dims3 ), dims3 ,& aimag ( tran_form_1_spin ( i , fin , :, :, :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v2_spin_r' , & size ( dims3 ), dims3 ,& real ( tran_form_v2_spin ( i , fin , :, :, :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v2_spin_c' , & size ( dims3 ), dims3 ,& aimag ( tran_form_v2_spin ( i , fin , :, :, :)), error ) dims4 = [ 3 , size ( tran_form_1_no_spin , 3 ), 2 , 2 ] call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v_spin_r' , & size ( dims4 ), dims4 ,& real ( tran_form_v_spin (:, i , fin , :, :, :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v_spin_c' , & size ( dims4 ), dims4 ,& aimag ( tran_form_v_spin (:, i , fin , :, :, :)), error ) else dims1 = [ size ( tran_form_1_no_spin , 3 )] call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v2_r' , & size ( dims1 ), dims1 ,& real ( tran_form_v2_no_spin ( i , fin , :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v2_c' , & size ( dims1 ), dims1 ,& aimag ( tran_form_v2_no_spin ( i , fin , :)), error ) dims2 = [ 3 , size ( tran_form_1_no_spin , 3 )] call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v_r' , & size ( dims2 ), dims2 ,& real ( tran_form_v_no_spin (:, i , fin , :)), error ) call h5ltmake_dataset_double_f ( file_id ,& 'abs_tran_form' // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/fin_' // trim ( adjustl ( int_to_str ( fin ))) // & '/tran_form_v_c' , & size ( dims2 ), dims2 ,& aimag ( tran_form_v_no_spin (:, i , fin , :)), error ) end if end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/abs_tran_form_calc.f90.html"},{"title":"exdm_absorption.f90 – EXCEED-DM","text":"Contents Modules exdm_absorption Source Code exdm_absorption.f90 Source Code module exdm_absorption !! Computes DM absorption rates. !! !! Note : currently specific to valence to conduction transitions use mpi use hdf5 use h5lt use prec use control_input use io_input use MPI_util use material_type use dm_model_type use expt_type use PW_dataset_type use width_parameters_type use numerics_abs use abs_tran_form_calc use abs_calc_PI use rate_calc_vector use rate_calc_ps use rate_calc_scalar use rate_calc_scalar_LO implicit none contains subroutine run_exdm_absorption ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , expt , dm_model , & verbose ) !! Computes DM absorption rates. !! !! Note : currently specific to valence to conduction transitions implicit none integer :: proc_id integer :: root_process integer :: n_proc type ( io_files_t ) :: io_files type ( control_t ) :: main_control type ( material_t ) :: target_mat type ( expt_t ) :: expt type ( dm_model_t ) :: dm_model logical , optional :: verbose type ( PW_dataset_t ) :: PW_dataset type ( width_parameters_t ) :: widths type ( numerics_abs_t ) :: numerics type ( parallel_manager_t ) :: ik_manager type ( parallel_manager_t ) :: v_manager integer , allocatable :: job_id_to_ik (:, :) complex ( dp ), allocatable :: tran_form_1_no_spin_job (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_1_spin_job (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_no_spin_job (:, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_spin_job (:, :, :, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_no_spin_job (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_spin_job (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ), allocatable :: pi_v2_v2 (:, :) !! Dim : [n_mX, n_widths] !! !!  \\Pi_{\\bar v&#94;2, \\bar v&#94;2}  - self energy with two v&#94;2 insertions. !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_1_1_mat (:, :, :, :) !! Dim : [3, 3, n_omega, n_widths] !! !!  \\mathbf{\\Pi}_{11}  self energy, without q_vec's, i.e. !! !! \\begin{align*} !!      \\Pi_{11} = \\frac{\\mathbf{q}}{m_e} \\cdot \\mathbf{Pi}_{11} \\cdot \\frac{ \\mathbf{q} }{m_e} !! \\end{align*} !! !! Units : eV&#94;2 complex ( dp ), allocatable :: pi_vi_vj (:, :, :, :) !! Dim : [3, 3, n_omega, n_widths] !! !!  \\Pi_{v&#94;i, v&#94;j}  self energy. !! !! Units : eV&#94;2 real ( dp ), allocatable :: abs_rate (:, :, :) !! Dim : [ dm_model%n_mX, widths%n, expt%n_time ] !! !! Absorption rate, assuming the mediator-electron coupling,  g = 1 . !! !! Units : None real ( dp ) :: v_vec ( 3 ) integer :: j , v_id call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call widths % load ( io_files % nml_input_filename , verbose = verbose ) call numerics % load ( io_files % nml_input_filename , & PW_dataset % n_val , PW_dataset % n_cond , dm_model , verbose = verbose ) ! Compute the relevant transition form factors ! parallelize over {i, k} call ik_manager % init ( PW_dataset % n_k * numerics % n_val_max , verbose = verbose ) allocate ( job_id_to_ik ( ik_manager % n_jobs , 4 )) job_id_to_ik = 0 call numerics % create_val_id_list ( PW_dataset % n_val ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ik_manager % create_job_to_2d_ID_table (& numerics % val_id_list , & numerics % k_id_list , & job_id_to_ik , verbose = verbose ) ! allocate/initialize processor specific variables allocate ( tran_form_1_no_spin_job ( ik_manager % n_jobs_per_proc , numerics % n_cond_max )) tran_form_1_no_spin_job = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_1_spin_job ( ik_manager % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_1_spin_job = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_no_spin_job ( 3 , ik_manager % n_jobs_per_proc , numerics % n_cond_max )) tran_form_v_no_spin_job = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_spin_job ( 3 , ik_manager % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_v_spin_job = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_no_spin_job ( ik_manager % n_jobs_per_proc , numerics % n_cond_max )) tran_form_v2_no_spin_job = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_spin_job ( ik_manager % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_v2_spin_job = ( 0.0_dp , 0.0_dp ) ! compute the transition form factors call calc_abs_tran_form ( proc_id , root_process , & tran_form_1_no_spin_job , tran_form_1_spin_job , & tran_form_v_no_spin_job , tran_form_v_spin_job , & tran_form_v2_no_spin_job , tran_form_v2_spin_job , & PW_dataset , ik_manager , job_id_to_ik , numerics , & io_files % out_filename , & verbose = verbose ) ! compute Pi's ! allocate pi variables allocate ( pi_v2_v2 ( dm_model % n_mX , widths % n )) pi_v2_v2 = ( 0.0_dp , 0.0_dp ) allocate ( pi_1_1_mat ( 3 , 3 , dm_model % n_mX , widths % n )) pi_1_1_mat = ( 0.0_dp , 0.0_dp ) allocate ( pi_vi_vj ( 3 , 3 , dm_model % n_mX , widths % n )) pi_vi_vj = ( 0.0_dp , 0.0_dp ) if ( PW_dataset % include_spin ) then call calc_abs_Pi ( proc_id , root_process , & tran_form_1_spin_job , tran_form_v_spin_job , tran_form_v2_spin_job , & pi_v2_v2 , pi_vi_vj , pi_1_1_mat , ik_manager , job_id_to_ik , & PW_dataset , widths , dm_model , target_mat , io_files % out_filename , verbose = verbose ) else call calc_abs_Pi ( proc_id , root_process , & tran_form_1_no_spin_job , tran_form_v_no_spin_job , tran_form_v2_no_spin_job , & pi_v2_v2 , pi_vi_vj , pi_1_1_mat , ik_manager , job_id_to_ik , & PW_dataset , widths , dm_model , target_mat , io_files % out_filename , verbose = verbose ) end if ! compute rates if ( verbose ) then print * , 'Computing absorption rates...' print * end if allocate ( abs_rate ( dm_model % n_mX , widths % n , expt % n_time )) abs_rate = 0.0_dp ! parallelize velocity integral call v_manager % init ( size ( numerics % v_mesh , 1 ), verbose = verbose ) do j = 1 , v_manager % n_jobs_per_proc v_id = v_manager % job_table ( proc_id + 1 , j ) if ( v_id /= 0 ) then v_vec = numerics % v_mesh ( v_id , :) if ( trim ( dm_model % particle_type ) == 'vector' ) then call calc_rate_vector ( pi_1_1_mat , v_vec , & dm_model , expt , widths , target_mat , numerics , & abs_rate , verbose = verbose ) else if ( trim ( dm_model % particle_type ) == 'ps' ) then call calc_rate_ps ( pi_1_1_mat , v_vec , & dm_model , expt , widths , target_mat , numerics , & abs_rate , verbose = verbose ) else if ( trim ( dm_model % particle_type ) == 'scalar' ) then if ( trim ( main_control % calc_mode ) == 'LO' ) then call calc_rate_scalar_LO ( pi_v2_v2 , v_vec , & dm_model , expt , widths , target_mat , numerics , & abs_rate , verbose = verbose ) else call calc_rate_scalar ( pi_1_1_mat , pi_v2_v2 , v_vec , & dm_model , expt , widths , target_mat , numerics , & abs_rate , verbose = verbose ) end if end if end if end do if ( verbose ) then print * , 'Done computing absorption rates!' print * end if call ik_manager % comm_abs_rate ( proc_id , root_process , abs_rate , & verbose = verbose ) if ( proc_id == root_process ) then call PW_dataset % save ( io_files % out_filename , verbose = verbose ) call widths % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) call save_abs_rate ( io_files % out_filename , abs_rate , verbose = verbose ) end if end subroutine subroutine save_abs_rate ( filename , abs_rate , verbose ) !! Save the absorption rate data. implicit none character ( len =* ) :: filename real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: p , t integer :: i , fin if ( verbose ) then print * , 'Saving absorption rates...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'abs_rates' , group_id , error ) do t = 1 , size ( abs_rate , 3 ) call h5gcreate_f ( file_id ,& 'abs_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))),& group_id , error ) do p = 1 , size ( abs_rate , 2 ) dims1 = [ size ( abs_rate , 1 )] call h5ltmake_dataset_double_f ( file_id ,& 'abs_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/width_' // trim ( adjustl ( int_to_str ( p ))),& size ( dims1 ), dims1 ,& abs_rate (:, p , t ), error ) end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/exdm_absorption.f90.html"},{"title":"numerics_abs.f90 – EXCEED-DM","text":"Contents Modules numerics_abs Source Code numerics_abs.f90 Source Code module numerics_abs !! Numerics parameters specific to DM absorption rate calculations. use info_messages use math_mod use physics_abs_functions implicit none type numerics_abs_t !! Numerics parameters specific to DM absorption calculations. integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands integer , allocatable :: val_id_list (:) !! Dim : [n_val_max] !! !! List of valence ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_k] !! !! List of k's to compute for. logical :: save_tran_form = . FALSE . !! If .TRUE. will save the transition form factors to the output file. integer :: n_v !! Number of  v  points in integration over  \\mathbf{v}  integer :: n_v_theta !! Number of  \\theta  points in integration over  \\mathbf{v}  integer :: n_v_phi !! Number of  \\phi  points in integration over  \\mathbf{v}  real ( dp ), allocatable :: v_angular_mesh (:, :) !! Dim : [ n_v_theta*n_v_phi, 2] !! !! List of  \\theta, \\phi  points in integral over  \\mathbf{v}  !! !! Units : None real ( dp ), allocatable :: v_list (:) !! Dim : [n_v] !! !! List of  |\\mathbf{v}|  points in velocity integral !! !! Units : None real ( dp ), allocatable :: v_mesh (:, :) !! Dim : [ n_v*n_v_theta*n_v_phi, 3] !! !! All points in the  \\mathbf{v}  integration. !! !! Units : None contains procedure :: print => numerics_abs_print procedure :: load => numerics_abs_load_nml procedure :: save => numerics_abs_save procedure :: create_val_id_list => abs_create_val_id_list procedure :: create_k_id_list => abs_create_k_id_list end type contains subroutine abs_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the DM absorption rate calculation. implicit none class ( numerics_abs_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine abs_create_val_id_list ( self , n_val ) !! Specify the indicies for each valence band that should be included. !! Specific to the DM absorption rate calculation. implicit none class ( numerics_abs_t ) :: self integer :: n_val integer :: j allocate ( self % val_id_list ( self % n_val_max )) do j = 1 , self % n_val_max self % val_id_list ( j ) = n_val - j + 1 end do end subroutine subroutine numerics_abs_save ( self , filename , verbose ) !! Saves `numerics_abs`. use hdf5 use h5lt implicit none class ( numerics_abs_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving numerics - abs parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_abs' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_abs/n_val_max' , & size ( dims1 ), dims1 , & self % n_val_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_abs/n_cond_max' , & size ( dims1 ), dims1 , & self % n_cond_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_abs/n_v' , & size ( dims1 ), dims1 , & self % n_v , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_abs/n_v_theta' , & size ( dims1 ), dims1 , & self % n_v_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_abs/n_v_phi' , & size ( dims1 ), dims1 , & self % n_v_phi , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_abs_load_nml ( self , filename , n_val , n_cond , dm_model , verbose ) !! Loads `numerics_abs` parameters from a namelist. implicit none class ( numerics_abs_t ) :: self character ( len =* ) :: filename integer :: n_val , n_cond type ( dm_model_t ) :: dm_model logical , optional :: verbose logical :: file_exists integer :: error integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands logical :: save_tran_form = . FALSE . integer :: n_v = 1 integer :: n_v_theta = 1 integer :: n_v_phi = 1 integer :: v , a , v_id NAMELIST / numerics_abs / n_val_max , & n_cond_max , & save_tran_form , & n_v , & n_v_theta , & n_v_phi if ( verbose ) then print * , 'Loading numerics parameters for absorption calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_abs , iostat = error ) close ( 100 ) if ( n_val_max == 0 ) then self % n_val_max = n_val else self % n_val_max = min ( n_val , n_val_max ) end if if ( n_cond_max == 0 ) then self % n_cond_max = n_cond else self % n_cond_max = min ( n_cond , n_cond_max ) end if self % save_tran_form = save_tran_form self % n_v = n_v self % n_v_theta = n_v_theta self % n_v_phi = n_v_phi allocate ( self % v_angular_mesh ( self % n_v_theta * self % n_v_phi , 2 )) self % v_angular_mesh = generate_uniform_points_on_sphere ( self % n_v_theta , & self % n_v_phi ) allocate ( self % v_list ( self % n_v )) self % v_list = uniform_list ( self % n_v , 0.0_dp , dm_model % vX_max ) ! create the v mesh allocate ( self % v_mesh ( self % n_v * self % n_v_theta * self % n_v_phi , 3 )) v_id = 0 do v = 1 , self % n_v do a = 1 , size ( self % v_angular_mesh , 1 ) v_id = v_id + 1 self % v_mesh ( v_id , 1 ) = self % v_list ( v ) * sin ( self % v_angular_mesh ( a , 1 )) * & cos ( self % v_angular_mesh ( a , 2 )) self % v_mesh ( v_id , 2 ) = self % v_list ( v ) * sin ( self % v_angular_mesh ( a , 1 )) * & sin ( self % v_angular_mesh ( a , 2 )) self % v_mesh ( v_id , 3 ) = self % v_list ( v ) * cos ( self % v_angular_mesh ( a , 1 )) end do end do ! chech the MB integration. call check_mb_dist_normalization ( self % v_mesh , dm_model , & boost_vec_in = dm_model % vE * [ 0 , 0 , 1 ], verbose = verbose ) call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-absorption parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_abs_print ( self , verbose ) !! Prints `numerics_abs` components. implicit none class ( numerics_abs_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ---------------------' print * , '    Numerics - Absorption' print * , '    ---------------------' print * print * , '        Maximum number of valence bands    : ' , trim ( adjustl ( int_to_str ( self % n_val_max ))) print * , '        Maximum number of conduction bands : ' , trim ( adjustl ( int_to_str ( self % n_cond_max ))) print * print * , '        v Integration' print * , '            Number of |v| points   : ' , trim ( adjustl ( int_to_str ( self % n_v ))) print * , '            Number of theta points : ' , trim ( adjustl ( int_to_str ( self % n_v_theta ))) print * , '            Number of phi points   : ' , trim ( adjustl ( int_to_str ( self % n_v_phi ))) print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/numerics_abs.f90.html"},{"title":"physics_abs_functions.f90 – EXCEED-DM","text":"Contents Modules physics_abs_functions Source Code physics_abs_functions.f90 Source Code module physics_abs_functions !! Physics functions needed for DM absorption rate calcuations. use prec use constants use dm_model_type implicit none contains function mb_vel_distribution ( v_vec , dm_model , boost_vec_in ) result ( mb_val ) !! Maxwell-Boltzmann velocity distribution, boosted with  \\mathbf{v}_\\text{boost} . !! !! \\begin{align*} !! f(\\mathbf{v}) = \\frac{1}{N_0} \\exp( - |\\mathbf{v} + \\mathbf{v}_\\text{boost}|&#94;2/v_0&#94;2) !! \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_\\text{boost}|) !! \\end{align*} implicit none real ( dp ) :: v_vec ( 3 ) type ( dm_model_t ) :: dm_model real ( dp ), optional :: boost_vec_in ( 3 ) real ( dp ) :: mb_val real ( dp ) :: v_mag real ( dp ) :: boost_vec ( 3 ) real ( dp ) :: v_p ( 3 ), v_p_mag ! boost the distribution if ( present ( boost_vec_in ) ) then boost_vec = boost_vec_in else boost_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if v_p = v_vec + boost_vec v_p_mag = norm2 ( v_p ) if ( v_p_mag < dm_model % vEsc ) then mb_val = ( dm_model % g_func_N0 ) ** ( - 1 ) * exp ( - ( v_p_mag / dm_model % v0 ) ** 2 ) else mb_val = 0.0_dp end if end function subroutine check_mb_dist_normalization ( v_mesh , dm_model , boost_vec_in , verbose ) !! Check the integral of the MB velocity distribution. If the samepling is fine !! enough, the value of the integral should be 1. implicit none real ( dp ) :: v_mesh (:, :) type ( dm_model_t ) :: dm_model real ( dp ), optional :: boost_vec_in ( 3 ) logical , optional :: verbose integer :: v , t , p real ( dp ) :: int_val real ( dp ) :: boost_vec ( 3 ) real ( dp ) :: v_vec ( 3 ) real ( dp ) :: v_mag , v_theta , v_phi real ( dp ) :: v_max if ( present ( boost_vec_in ) ) then boost_vec = boost_vec_in else boost_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if int_val = 0.0_dp do v = 1 , size ( v_mesh , 1 ) v_vec = v_mesh ( v , :) v_mag = norm2 ( v_vec ) int_val = int_val + v_mag ** 2 * ( 4.0_dp * pi * dm_model % vX_max ) * & ( 1.0_dp * size ( v_mesh , 1 )) ** ( - 1 ) * & mb_vel_distribution ( v_vec , dm_model , boost_vec_in = boost_vec ) end do if ( verbose ) then print * , 'Integral of MB velocity distrubution : ' , int_val print * end if end subroutine end module","tags":"","loc":"sourcefile/physics_abs_functions.f90.html"},{"title":"rate_calc_ps.f90 – EXCEED-DM","text":"Contents Modules rate_calc_ps Source Code rate_calc_ps.f90 Source Code module rate_calc_ps !! Compute the pseudoscalar DM absorption rate. use prec use constants use math_mod use dm_model_type use expt_type use material_type use width_parameters_type use numerics_abs use physics_abs_functions implicit none contains subroutine calc_rate_ps ( pi_1_1_mat , v_vec , dm_model , expt , widths , & target_mat , numerics , abs_rate , verbose ) !! Compute the pseudoscalar DM absorption rate at a given  \\mathbf{v} . implicit none complex ( dp ) :: pi_1_1_mat (:, :, :, :) real ( dp ) :: v_vec ( 3 ) type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( width_parameters_t ) :: widths type ( material_t ) :: target_mat type ( numerics_abs_t ) :: numerics real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_mag , v_max real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val complex ( dp ) :: pi_eigvals ( 3 ) complex ( dp ) :: pi_eigvectors ( 3 , 3 ) complex ( dp ) :: pi_mat ( 3 , 3 ) integer :: i v_mag = norm2 ( v_vec ) do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) do p = 1 , widths % n pi_mat = e_EM ** 2 * ( omega / m_elec ) ** 2 * pi_1_1_mat (:, :, w , p ) call calc_eigvals_33 ( pi_mat , pi_eigvals ) do t = 1 , expt % n_time ve_vec = dm_model % vE * expt % vE_direction ( t , :) av_rate = 0.0_dp q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then gam = - omega ** 2 * ( 4.0_dp * m_elec ** 2 * omega * e_EM ** 2 ) ** ( - 1 ) * & aimag ( sum ( pi_eigvals )) rate = ( dm_model % rhoX / target_mat % rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , dm_model , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * dm_model % vX_max ) * & ( 1.0_dp * size ( numerics % v_mesh , 1 )) ** ( - 1 ) * rate * mb_val end if abs_rate ( w , p , t ) = abs_rate ( w , p , t ) + av_rate * expt % m_T * expt % exposure end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_ps.f90.html"},{"title":"rate_calc_scalar.f90 – EXCEED-DM","text":"Contents Modules rate_calc_scalar Source Code rate_calc_scalar.f90 Source Code module rate_calc_scalar !! Compute the scalar DM absorption rate. use prec use constants use math_mod use dm_model_type use expt_type use material_type use width_parameters_type use numerics_abs use physics_abs_functions implicit none contains subroutine calc_rate_scalar ( pi_1_1_mat , pi_v2_v2 , v_vec , dm_model , expt , widths , & target_mat , numerics , abs_rate , verbose ) !! Compute the scalar DM absorption rate at a given  \\mathbf{v} . implicit none complex ( dp ) :: pi_1_1_mat (:, :, :, :) complex ( dp ) :: pi_v2_v2 (:, :) real ( dp ) :: v_vec ( 3 ) type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( width_parameters_t ) :: widths type ( material_t ) :: target_mat type ( numerics_abs_t ) :: numerics real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_mag , v_max real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: pi_1_1 real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val v_mag = norm2 ( v_vec ) do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) do p = 1 , widths % n do t = 1 , expt % n_time ve_vec = dm_model % vE * expt % vE_direction ( t , :) av_rate = 0.0_dp q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then pi_1_1 = dot_product ( q_vec / m_elec , matmul ( pi_1_1_mat (:, :, w , p ), q_vec / m_elec ) ) gam = - ( omega ) ** ( - 1 ) * aimag (& pi_v2_v2 ( w , p ) + & ( e_EM ) ** ( - 2 ) * ( q_mag ** 2 ) * & ( q_mag ** 2 ) * & ( q_mag ** 2 - e_EM ** 2 * pi_1_1 ) ** ( - 1 )& ) rate = ( dm_model % rhoX / target_mat % rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , dm_model , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * dm_model % vX_max ) * & ( 1.0_dp * size ( numerics % v_mesh , 1 )) ** ( - 1 ) * rate * mb_val end if abs_rate ( w , p , t ) = abs_rate ( w , p , t ) + av_rate * expt % m_T * expt % exposure end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_scalar.f90.html"},{"title":"rate_calc_scalar_LO.f90 – EXCEED-DM","text":"Contents Modules rate_calc_scalar_LO Source Code rate_calc_scalar_LO.f90 Source Code module rate_calc_scalar_LO !! Compute the scalar DM absorption rate (leading order contribution, from  \\Pi_{\\bar{v}&#94;2, \\bar{v}&#94;2}  ), only). use prec use constants use math_mod use dm_model_type use expt_type use material_type use width_parameters_type use numerics_abs use physics_abs_functions implicit none contains subroutine calc_rate_scalar_LO ( pi_v2_v2 , v_vec , dm_model , expt , widths , & target_mat , numerics , abs_rate , verbose ) !! Compute the scalar DM absorption rate from the LO contribution, at a given  \\mathbf{v} . implicit none complex ( dp ) :: pi_v2_v2 (:, :) real ( dp ) :: v_vec ( 3 ) type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( width_parameters_t ) :: widths type ( material_t ) :: target_mat type ( numerics_abs_t ) :: numerics real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: v_mag , v_max real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: pi_1_1 real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val v_mag = norm2 ( v_vec ) do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) do p = 1 , widths % n do t = 1 , expt % n_time ve_vec = dm_model % vE * expt % vE_direction ( t , :) av_rate = 0.0_dp q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then gam = - ( omega ) ** ( - 1 ) * aimag ( pi_v2_v2 ( w , p ) ) rate = ( dm_model % rhoX / target_mat % rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , dm_model , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * dm_model % vX_max ) * & ( 1.0_dp * size ( numerics % v_mesh , 1 )) ** ( - 1 ) * rate * mb_val end if abs_rate ( w , p , t ) = abs_rate ( w , p , t ) + av_rate * expt % m_T * expt % exposure end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_scalar_lo.f90.html"},{"title":"rate_calc_vector.f90 – EXCEED-DM","text":"Contents Modules rate_calc_vector Source Code rate_calc_vector.f90 Source Code module rate_calc_vector !! Compute the vector DM absorption rate. use prec use constants use math_mod use dm_model_type use expt_type use material_type use width_parameters_type use numerics_abs use physics_abs_functions implicit none contains subroutine calc_rate_vector ( pi_1_1_mat , v_vec , dm_model , expt , widths , & target_mat , numerics , abs_rate , verbose ) !! Compute the vector DM absorption rate at a given  \\mathbf{v} . implicit none complex ( dp ) :: pi_1_1_mat (:, :, :, :) real ( dp ) :: v_vec ( 3 ) type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( width_parameters_t ) :: widths type ( material_t ) :: target_mat type ( numerics_abs_t ) :: numerics real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose real ( dp ) :: v_mag integer :: w , p , t , v , a real ( dp ) :: gam real ( dp ) :: av_rate , rate real ( dp ) :: omega real ( dp ) :: q_vec ( 3 ), q_mag real ( dp ) :: pi_r , pi_c real ( dp ) :: ve_vec ( 3 ) real ( dp ) :: mb_val complex ( dp ) :: pi_eigvals ( 3 ) complex ( dp ) :: pi_eigvectors ( 3 , 3 ) complex ( dp ) :: pi_mat ( 3 , 3 ) integer :: i v_mag = norm2 ( v_vec ) do w = 1 , dm_model % n_mX omega = dm_model % mX ( w ) do p = 1 , widths % n pi_mat = e_EM ** 2 * ( omega / m_elec ) ** 2 * pi_1_1_mat (:, :, w , p ) call calc_eigvals_33 ( pi_mat , pi_eigvals ) do t = 1 , expt % n_time ve_vec = dm_model % vE * expt % vE_direction ( t , :) av_rate = 0.0_dp q_vec = omega * v_vec q_mag = norm2 ( q_vec ) if ( q_mag > 0.0_dp ) then gam = 0.0_dp ! sum over (diagonalized) polarizations do i = 1 , 3 ! pi_r = real(pi_eigvals(i)) ! pi_c = aimag(pi_eigvals(i)) gam = gam + & ( - 1.0_dp ) * e_EM ** ( - 2 ) * ( 3.0_dp * omega ) ** ( - 1 ) * & aimag ( omega ** 2 * pi_eigvals ( i ) / ( omega ** 2 - pi_eigvals ( i ) ) ) ! gam = gam + & !     (-1.0_dp)*(3.0_dp*omega)**(-1)*& !     omega**4*( ( omega**2 - e_EM**2*pi_r )**2 + ( e_EM**2*pi_c )**2 )**(-1)*& !     pi_c end do rate = ( dm_model % rhoX / target_mat % rho_T ) * ( omega ) ** ( - 1 ) * gam mb_val = mb_vel_distribution ( v_vec , dm_model , boost_vec_in = ve_vec ) av_rate = av_rate + v_mag ** 2 * ( 4.0_dp * pi * dm_model % vX_max ) * & ( 1.0_dp * size ( numerics % v_mesh , 1 )) ** ( - 1 ) * rate * mb_val end if abs_rate ( w , p , t ) = abs_rate ( w , p , t ) + av_rate * expt % m_T * expt % exposure end do end do end do end subroutine end module","tags":"","loc":"sourcefile/rate_calc_vector.f90.html"},{"title":"constants.f90 – EXCEED-DM","text":"Contents Modules constants Source Code constants.f90 Source Code module constants !! Collection of useful constants: !!  m_e, \\alpha, a_0, \\pi, i, e . use prec implicit none real ( dp ), parameter :: m_elec = 51 1.0e3_dp !! Electron mass !! !! Units : eV real ( dp ), parameter :: alpha_EM = 1.0_dp / 13 7.0_dp !! Fine structure constant real ( dp ), parameter :: a0 = 2.681336e-4_dp !! Bohr radius !! !! Units : eV&#94;(-1) real ( dp ), parameter :: pi = 4.0_dp * atan ( 1.0_dp ) complex ( dp ), parameter :: ii = ( 0.0_dp , 1.0_dp ) !! Imaginary unit real ( dp ), parameter :: e_EM = sqrt ( 4 * pi * alpha_EM ) !! Unit of electric charge end module","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"info_messages.f90 – EXCEED-DM","text":"Contents Modules info_messages Source Code info_messages.f90 Source Code module info_messages !! Procedures for printing program information and errrors/warnings. implicit none integer :: sec_length = 80 contains subroutine exdm_shutdown_message ( proc_id , root_process ) !! Message to display when EXCEED-DM starts. use iso_fortran_env use timing implicit none integer :: proc_id integer :: root_process integer :: n_proc character ( len = 64 ) :: version character ( len = 64 ) :: n_proc_str if ( proc_id == root_process ) then call print_section_seperator () print * print * , '    Ended at' , trim ( pretty_date_and_time ()) print * call print_section_seperator () print * end if end subroutine subroutine print_timing_info ( dt , verbose ) !! Prints a program timing info. use timing implicit none real ( dp ) :: dt logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ------' print * , '    Timing' print * , '    ------' print * print * , '        Run time : ' print * , '        ' , trim ( pretty_time_format ( dt )) print * call print_section_seperator () print * end if end subroutine subroutine print_warning_message ( message , verbose ) !! Prints a warning message. implicit none character ( len =* ) :: message logical , optional :: verbose if ( verbose ) then call print_warning_msg_header () print * print * , '    ' , message print * call print_warning_msg_seperator () print * end if end subroutine subroutine print_error_message ( message , verbose ) !! Prints an error message. implicit none character ( len =* ) :: message logical , optional :: verbose if ( verbose ) then call print_error_msg_header () print * print * , '    ' , message print * call print_error_msg_seperator () print * end if end subroutine subroutine exdm_startup_message ( proc_id , root_process , n_proc , version ) !! Message to display when EXCEED-DM starts. use iso_fortran_env use timing implicit none integer :: proc_id integer :: root_process integer :: n_proc character ( len = 64 ) :: version character ( len = 64 ) :: n_proc_str if ( proc_id == root_process ) then n_proc_str = int_to_str ( n_proc ) print * call print_section_seperator () print * print * , '    EXCEED-DM - v' , trim ( version ) print * print * , '    Running on ' , trim ( adjustl ( n_proc_str )), ' processors' print * , '    Compiled with ' , compiler_version () print * print * , '    Started at' , trim ( pretty_date_and_time ()) print * call print_section_seperator () print * end if end subroutine subroutine print_section_seperator () !! Prints the section seperator. implicit none print * , repeat ( '-' , sec_length ) end subroutine subroutine print_error_msg_header () !! Prints the error message header. implicit none print * , repeat ( '!' , 3 ) // ' ERROR ' // repeat ( '!' , sec_length - 10 ) end subroutine subroutine print_error_msg_seperator () !! Prints the error message seperator. implicit none print * , repeat ( '!' , sec_length ) end subroutine subroutine print_warning_msg_header () !! Prints the warning message header. implicit none print * , repeat ( '~' , 3 ) // ' WARNING ' // repeat ( '~' , sec_length - 12 ) end subroutine subroutine print_warning_msg_seperator () !! Prints the warning message seperator. implicit none print * , repeat ( '~' , sec_length ) end subroutine function int_to_str ( num ) result ( string ) !! Converts an integer to a string. implicit none integer :: num character ( len = 64 ) :: string write ( string , * ) num end function end module","tags":"","loc":"sourcefile/info_messages.f90.html"},{"title":"math_mod.f90 – EXCEED-DM","text":"Contents Modules math_mod Source Code math_mod.f90 Source Code module math_mod !! Collection of math functions. use prec use special_functions use constants implicit none contains function integrate_log_interpolate ( x_data , dydx_data , x1 , x2 ) result ( integral ) !* Given  \\frac{dy}{dx}  evaluated at a list of points in  x , numerically integrate between  [ x_1, x_2 ] !while modelling  \\frac{dy}{dx}  as a power law between points. real ( dp ) :: x_data (:) real ( dp ) :: dydx_data (:) real ( dp ) :: x1 , x2 real ( dp ) :: integral integer :: n_enclosed_pts integer :: x1_index integer :: x2_index integer :: xL_index integer :: xR_index real ( dp ) :: xL , xR real ( dp ) :: dydx_L , dydx_R real ( dp ) :: power_law_b integer :: i real ( dp ) :: b_1 , b_2 integral = 0.0_dp ! make sure input bounds make sense if ( x2 < x1 ) then return end if ! make sure bounds overlap computed data if ( x2 < x_data ( 1 ) ) then return end if if ( x1 > x_data ( size ( x_data )) ) then return end if ! find all points enclosed by [x1, x2] ! x1_index is the index of the closest x point which is > x1 ! x2_index is the index of the closest x point which is < x2 if ( x1 < x_data ( 1 ) ) then x1_index = 1 else do i = 1 , size ( x_data ) - 1 if ( ( x_data ( i ) < x1 ) . and . ( x1 < x_data ( i + 1 ) ) ) then x1_index = i + 1 end if end do end if if ( x2 > x_data ( size ( x_data )) ) then x2_index = size ( x_data ) else do i = 1 , size ( x_data ) - 1 if ( ( x_data ( i ) < x2 ) . and . ( x2 < x_data ( i + 1 ) ) ) then x2_index = i end if end do end if ! Number of x_data points between x1, x2 n_enclosed_pts = x2_index - x1_index + 1 ! integration bounds are between points. if ( n_enclosed_pts == 0 ) then xL = x1 xR = x2 b_1 = ( log ( dydx_data ( x1_index )) - log ( dydx_data ( x2_index ))) / & ( log ( x_data ( x1_index )) - log ( x_data ( x2_index ))) dydx_L = dydx_data ( x2_index ) * ( x1 / x_data ( x2_index ) ) ** b_1 dydx_R = dydx_data ( x2_index ) * ( x2 / x_data ( x2_index ) ) ** b_1 integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end if ! only edge cases if ( n_enclosed_pts == 1 ) then ! if x1 < x_data(1) ignore if ( x1 > x_data ( 1 ) ) then ! if x1 is close to an already computed data point, ignore if ( abs ( x1 - x_data ( x1_index )) > 1.0e-8_dp ) then b_1 = ( log ( dydx_data ( x1_index )) - log ( dydx_data ( x1_index - 1 ))) / & ( log ( x_data ( x1_index )) - log ( x_data ( x1_index - 1 ))) xL = x1 xR = x_data ( x1_index ) dydx_L = dydx_data ( x1_index - 1 ) * ( x1 / x_data ( x1_index - 1 ) ) ** b_1 dydx_R = dydx_data ( x1_index ) integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end if end if if ( x2 < x_data ( size ( x_data )) ) then ! if x2 is close to an already computed data point, ignore if ( abs ( x2 - x_data ( x2_index )) > 1.0e-8_dp ) then b_2 = ( log ( dydx_data ( x2_index + 1 )) - log ( dydx_data ( x2_index ))) / & ( log ( x_data ( x2_index + 1 )) - log ( x_data ( x2_index ))) xL = x_data ( x2_index ) xR = x2 dydx_L = dydx_data ( x2_index ) dydx_R = dydx_data ( x2_index ) * ( x2 / x_data ( x2_index ) ) ** b_2 integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end if end if end if ! make sure at least two points are enclosed if ( n_enclosed_pts > 1 ) then ! go through pairs of points and add to the integral do i = 1 , n_enclosed_pts - 1 xL_index = x1_index + ( i - 1 ) xR_index = xL_index + 1 xL = x_data ( xL_index ) xR = x_data ( xR_index ) dydx_L = dydx_data ( xL_index ) dydx_R = dydx_data ( xR_index ) ! Here we choose a specific interpolation method. To change the method just change this function. integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end do ! and add contribution from the end points. ! if x1 < x_data(1) ignore if ( x1 > x_data ( 1 ) ) then ! if x1 is close to an already computed data point, ignore if ( abs ( x1 - x_data ( x1_index )) > 1.0e-8_dp ) then b_1 = ( log ( dydx_data ( x1_index )) - log ( dydx_data ( x1_index - 1 ))) / & ( log ( x_data ( x1_index )) - log ( x_data ( x1_index - 1 ))) xL = x1 xR = x_data ( x1_index ) dydx_L = dydx_data ( x1_index - 1 ) * ( x1 / x_data ( x1_index - 1 ) ) ** b_1 dydx_R = dydx_data ( x1_index ) integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end if end if ! if x2 > ( last x point ) ignore if ( x2 < x_data ( size ( x_data )) ) then ! if x2 is close to an already computed data point, ignore if ( abs ( x2 - x_data ( x2_index )) > 1.0e-8_dp ) then b_2 = ( log ( dydx_data ( x2_index + 1 )) - log ( dydx_data ( x2_index ))) / & ( log ( x_data ( x2_index + 1 )) - log ( x_data ( x2_index ))) xL = x_data ( x2_index ) xR = x2 dydx_L = dydx_data ( x2_index ) dydx_R = dydx_data ( x2_index ) * ( x2 / x_data ( x2_index ) ) ** b_2 integral = integral + int_method_power_law_interp ( xL , xR , & dydx_L , dydx_R ) end if end if end if end function function Q_func ( x , a , b , Q_max ) result ( Q ) !!  Q = \\text{min} \\left( Q_\\text{max}, 1 + \\lfloor \\frac{x - a}{b} \\rfloor \\right)  !! !! Note :  1 \\leq Q \\leq Q_\\text{max} . implicit none integer :: Q , Q_max real ( dp ) :: x , a , b Q = max ( min ( Q_max , 1 + floor (( x - a ) / b ) ), 1 ) end function function uniform_list ( N , x1 , x2 ) result ( li ) !! Returns a list of `N` uniformly distributed numbers between `x1` and `x2`, !! including `x1` and `x2`. !! !! Note : `N`  \\geq  1  integer :: N real ( dp ) :: x1 real ( dp ) :: x2 real ( dp ) :: li ( N ) integer :: i do i = 1 , N li ( i ) = x1 + ( x2 - x1 ) * ( i - 1 ) / max ( N - 1 , 1 ) end do end function subroutine calc_eigvals_33 ( mat , eigval ) !! Compute the eigenvalues of a 3x3 complex matrix. implicit none complex ( dp ) :: mat ( 3 , 3 ) complex ( dp ) :: eig_vec ( 3 , 3 ) complex ( dp ) :: eigval ( 3 ) complex ( dp ) :: lwork ( 6 ), rwork ( 6 ) complex ( dp ) :: dummy_1 ( 1 , 1 ) complex ( dp ) :: dummy_2 ( 1 , 1 ) integer :: info call zgeev ( 'N' , 'N' , 3 , mat , 3 , eigval , dummy_1 , 1 , dummy_2 , 1 , lwork , 6 , rwork , info ) end subroutine subroutine calc_eig_system_33 ( mat , eig_val , eig_vec ) !! Compute the eigenvalues and (right) eigenvectors of a complex 3x3 matrix. implicit none complex ( dp ) :: mat ( 3 , 3 ) complex ( dp ) :: eig_vec ( 3 , 3 ) complex ( dp ) :: eig_val ( 3 ) complex ( dp ) :: lwork ( 6 ), rwork ( 6 ) complex ( dp ) :: dummy ( 1 , 1 ) integer :: info call zgeev ( 'N' , 'V' , 3 , mat , 3 , eig_val , dummy , 1 , eig_vec , 3 , lwork , 6 , rwork , info ) end subroutine function pauli_spin_matrix ( i ) result ( mat ) !! Returns the ith Pauli spin matrix,  \\sigma&#94;i. Identity matrix is defined as the !!  0 th component. implicit none integer :: i complex ( dp ) :: mat ( 2 , 2 ) mat = ( 0.0_dp , 0.0_dp ) select case ( i ) case ( 0 ) mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 1.0_dp , 0.0_dp ) case ( 1 ) mat ( 1 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 1.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 0.0_dp , 0.0_dp ) case ( 2 ) mat ( 1 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 1 , 2 ) = - ii mat ( 2 , 1 ) = ii mat ( 2 , 2 ) = ( 0.0_dp , 0.0_dp ) case ( 3 ) mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( - 1.0_dp , 0.0_dp ) case default mat ( 1 , 1 ) = ( 1.0_dp , 0.0_dp ) mat ( 1 , 2 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 1 ) = ( 0.0_dp , 0.0_dp ) mat ( 2 , 2 ) = ( 1.0_dp , 0.0_dp ) end select end function function int_method_power_law_interp ( x1 , x2 , dydx1 , dydx2 ) result ( integral ) !! Integration method assuming  dy/dx  is a power law between points. !! !! \\begin{align*} !!  \\frac{dy}{dx}(x) & = \\frac{dy}{dx}_1 \\left( \\frac{x}{x_1} \\right)&#94;b \\\\ !!  b & = \\frac{ \\log{\\left( \\frac{dy}{dx}_2 \\right)} - \\log{\\left( \\frac{dy}{dx}_1 \\right)}}{ \\log{x_2} - \\log{x_1}} \\\\ !!  \\mathcal{I} & = \\int_{x_1}&#94;{x_2} \\frac{dy}{dx}(x) dx \\\\ !! & = \\frac{dy}{dx}_1 \\frac{x_1}{b + 1} ( \\exp( (b + 1) \\log(x_2/x_1) ) - 1 ) !! \\end{align*} !! !! The complicated implementation is due to problems when  b  is large. implicit none real ( dp ) :: x1 , x2 real ( dp ) :: dydx1 , dydx2 real ( dp ) :: integral real ( dp ) :: b real ( dp ) :: eps eps = 1.0e-8_dp b = ( log ( dydx2 ) - log ( dydx1 )) / ( log ( x2 ) - log ( x1 )) if ( abs ( b + 1.0_dp ) < eps ) then integral = dydx1 * x1 * log ( x2 / x1 ) else integral = dydx1 * ( b + 1.0_dp ) ** ( - 1 ) * x1 * ( exp ( ( b + 1.0_dp ) * log ( x2 / x1 ) ) - 1.0_dp ) end if end function function integrate_power_law ( b , x1 , x2 , x_s ) result ( integral ) !! Integral of a power law function. !! \\begin{align*} !!  & = \\int_{x_1}&#94;{x_2} \\left( \\frac{x}{x_s} \\right)&#94;b dx \\\\ !!  & = x_1 \\left( \\frac{x_1}{x_s} \\right)&#94;b \\int_{1}&#94;{x_2/x_1} y&#94;b dy \\\\ !!  & = \\frac{x_1}{b + 1} \\exp( b \\log(x_1/x_s) ) ( \\exp( (b + 1) \\log(x_2/x_1) ) - 1 ) !! \\end{align*} !! !! The complicated implementation is due to problems when  b  is large. implicit none real ( dp ) :: b real ( dp ) :: x1 , x2 , x_s real ( dp ) :: integral real ( dp ) :: eps eps = 1.0e-8_dp if ( abs ( b + 1.0_dp ) < eps ) then integral = x_s * log ( x2 / x1 ) else integral = ( b + 1.0_dp ) ** ( - 1 ) * x1 * exp ( b * log ( x1 / x_s ) ) * & ( exp ( ( b + 1.0_dp ) * log ( x2 / x1 ) ) - 1.0_dp ) end if end function function power_law_fit ( log_x_pts , log_y_pts ) result ( fit_params ) !! Finds  \\beta  such that  y_2 = y_1 \\left( \\frac{x_2}{x_1} \\right)&#94;\\beta . implicit none real ( dp ) :: log_x_pts ( 2 ) real ( dp ) :: log_y_pts ( 2 ) real ( dp ) :: fit_params real ( dp ) :: b if ( log_x_pts ( 2 ) > log_x_pts ( 1 ) ) then fit_params = ( log_y_pts ( 2 ) - log_y_pts ( 1 )) / ( log_x_pts ( 2 ) - log_x_pts ( 1 )) else print * , 'ERROR' end if end function function generate_uniform_points_on_sphere ( n_theta , n_phi ) result ( angular_mesh ) !! Generates an (`n_theta`  \\times  `n_phi`) list of  \\theta, \\phi  coordinates !! which are uniformly distributed on the sphere. implicit none integer :: n_theta , n_phi real ( dp ) :: angular_mesh ( n_theta * n_phi , 2 ) integer :: t , p , i real ( dp ) :: theta , phi i = 1 do t = 1 , n_theta do p = 1 , n_phi theta = acos (& 2.0_dp * (( t - 1.0_dp ) / max ( 1.0_dp , n_theta - 1.0_dp )) - 1.0_dp & ) phi = 2.0_dp * pi * ( p - 1.0_dp ) / ( max ( n_phi - 1.0_dp , 1.0_dp )) angular_mesh ( i , :) = [ theta , phi ] i = i + 1 end do end do end function function factorial ( n ) result ( fact ) !!  n!  function. implicit none integer :: n , fact , i fact = 1 if ( n . gt . 1 ) then do i = 1 , n fact = fact * i end do end if end function recursive function sph_harmonic ( l , m , theta , phi ) result ( y_lm ) !! Spherical harmonic function,  Y&#94;m_l  with phase convention identical to Mathematica. implicit none integer :: l , m real ( dp ) :: theta , phi , c_theta real ( dp ) :: legendre_pol real ( dp ) :: norm complex ( dp ) :: y_lm if ( m < 0 ) then y_lm = ( - 1 ) ** m * conjg ( sph_harmonic ( l , - m , theta , phi )) else c_theta = cos ( theta ) norm = sqrt (( 2 * l + 1 ) * factorial ( l - m ) / ( 4.0_dp * pi * factorial ( l + m ))) call lpmv ( 1.0_dp * l , m , c_theta , legendre_pol ) y_lm = norm * exp ( ii * m * phi ) * legendre_pol end if end function function get_phi ( n_hat ) result ( phi ) !! Returns the  \\phi  value of a unit direction vector, `n_hat`. implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: phi phi = atan2 ( n_hat ( 2 ), n_hat ( 1 )) if ( phi . lt . 0.0_dp ) then phi = phi + 2.0_dp * pi end if end function function get_theta ( n_hat ) result ( theta ) !! Returns the  \\theta  value of a unit direction vector, `n_hat`. implicit none real ( dp ) :: n_hat ( 3 ) real ( dp ) :: theta theta = acos ( n_hat ( 3 )) end function function get_max_r_inside_parallelepiped ( n_grid , red_to_xyz , verbose ) result ( r_max ) !* Given a cube of points in reduced coordinates, find the largest sphere which sits inside the parallelipipid in xyz !coordinates. The 8 corners of the parallelipipid are related to the 8 corners in reduced coordinates by the transformation !matrix, `red_to_xyz`. ! ! This function is useful for: ! ! 1) Finding the maximum  q  an FFT is \"consistent\" for. ! ! Consider a 2D FFT computed on two square grids in xyz coordinates of dimension, 1)  [N, N]  and 2)  [2 N, 2 N] , ! so the second grid includes all of the points in the first grid. Now consider two functions,  f_1( \\mathbf{q} ) ,  ! f_2( \\mathbf{q} ) , coming from the FFT of the same function on these grids, binned in  q .  \\bar{f}_1  will ! equal  \\bar{f}_2  up to some  q ; in this case  q = N/2 , since, e.g., the  q = \\sqrt{2} N/2  value of  ! \\bar{f}_1  will be different in grid 2 since grid 2 includes all  \\mathbf{q}  with magnitude  \\sqrt{2} N/2 , ! whereas grid 1 only contains some of them (i.e., it's missing  \\mathbf{q} = [\\sqrt{2} N/2, 0]  ). ! ! However all grids larger than grid 1 will contain all  q \\le N/2  and therefore in this example `r_max`  = N/2). ! More generally (3d, `red_to_xyz`  \\neq \\mathbf{1} ) `q_max` corresponds to `r_max` when the `red_to_xyz` ! matrix is set to `k_red_to_xyz`, and `n_grid` is the size of the FFT `<FFT_grid_t>%n_grid`. implicit none integer :: n_grid ( 3 ) real ( dp ) :: red_to_xyz ( 3 , 3 ) logical , optional :: verbose real ( dp ) :: r_max real ( dp ) :: corners_xyz ( 8 , 3 ) real ( dp ) :: faces_xyz ( 6 , 3 , 3 ) real ( dp ) :: dist_to_face ( 6 ) integer :: f real ( dp ) :: basis_vecs ( 2 , 3 ) real ( dp ) :: corner_to_origin ( 3 ) real ( dp ) :: face_to_origin ( 3 ) corners_xyz ( 1 , :) = matmul ( red_to_xyz , [ - n_grid ( 1 ), - n_grid ( 2 ), - n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 2 , :) = matmul ( red_to_xyz , [ n_grid ( 1 ), - n_grid ( 2 ), - n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 3 , :) = matmul ( red_to_xyz , [ n_grid ( 1 ), - n_grid ( 2 ), n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 4 , :) = matmul ( red_to_xyz , [ - n_grid ( 1 ), - n_grid ( 2 ), n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 5 , :) = matmul ( red_to_xyz , [ - n_grid ( 1 ), n_grid ( 2 ), - n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 6 , :) = matmul ( red_to_xyz , [ n_grid ( 1 ), n_grid ( 2 ), - n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 7 , :) = matmul ( red_to_xyz , [ n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 ) ] ) / 2.0_dp corners_xyz ( 8 , :) = matmul ( red_to_xyz , [ - n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 ) ] ) / 2.0_dp ! face 1, [1, 4, 3, 2] faces_xyz ( 1 , 1 , :) = corners_xyz ( 1 , :) faces_xyz ( 1 , 2 , :) = corners_xyz ( 4 , :) faces_xyz ( 1 , 3 , :) = corners_xyz ( 2 , :) ! face 2, [1, 5, 8, 4] faces_xyz ( 2 , 1 , :) = corners_xyz ( 1 , :) faces_xyz ( 2 , 2 , :) = corners_xyz ( 5 , :) faces_xyz ( 2 , 3 , :) = corners_xyz ( 4 , :) ! face 3, [5, 6, 7, 8] faces_xyz ( 3 , 1 , :) = corners_xyz ( 5 , :) faces_xyz ( 3 , 2 , :) = corners_xyz ( 6 , :) faces_xyz ( 3 , 3 , :) = corners_xyz ( 8 , :) ! face 4, [2, 3, 7, 6] faces_xyz ( 4 , 1 , :) = corners_xyz ( 2 , :) faces_xyz ( 4 , 2 , :) = corners_xyz ( 3 , :) faces_xyz ( 4 , 3 , :) = corners_xyz ( 6 , :) ! face 5, [1, 2, 6, 5] faces_xyz ( 5 , 1 , :) = corners_xyz ( 1 , :) faces_xyz ( 5 , 2 , :) = corners_xyz ( 2 , :) faces_xyz ( 5 , 3 , :) = corners_xyz ( 5 , :) ! face 6, [3, 4, 8, 7] faces_xyz ( 6 , 1 , :) = corners_xyz ( 3 , :) faces_xyz ( 6 , 2 , :) = corners_xyz ( 4 , :) faces_xyz ( 6 , 3 , :) = corners_xyz ( 7 , :) do f = 1 , 6 ! shift coordinates to first corner corner_to_origin = - faces_xyz ( f , 1 , :) ! define the basis vectors of the plane basis_vecs ( 1 , :) = ( faces_xyz ( f , 2 , :) + corner_to_origin ) / norm2 ( faces_xyz ( f , 2 , :) + corner_to_origin ) basis_vecs ( 2 , :) = ( faces_xyz ( f , 3 , :) + corner_to_origin ) / norm2 ( faces_xyz ( f , 3 , :) + corner_to_origin ) ! get magnitude of vector pointing from the origin perpendicular to the face face_to_origin = corner_to_origin & - basis_vecs ( 1 , :) * dot_product ( basis_vecs ( 1 , :), corner_to_origin )& - basis_vecs ( 2 , :) * dot_product ( basis_vecs ( 2 , :), corner_to_origin ) dist_to_face ( f ) = norm2 ( face_to_origin ) end do r_max = minval ( dist_to_face ) end function function get_q_max_1BZ ( k_red_to_xyz , verbose ) result ( q_max ) !* Given a reduce to xyz transformation matrix for points in k-space, `k_red_to_xyz`, ! compute the radius of the largest sphere which can fit inside, `q_max`. implicit none real ( dp ) :: k_red_to_xyz ( 3 , 3 ) logical , optional :: verbose real ( dp ) :: q_max real ( dp ) :: dist_to_nearest_lattice_pts ( 26 ) real ( dp ) :: k_lat_vec_xyz ( 3 ) real ( dp ) :: k_lat_mag_min real ( dp ) :: k_lat_mag integer :: i , j , k , counter counter = 0 do i = - 1 , 1 do j = - 1 , 1 do k = - 1 , 1 if ( ( i /= 0 ) . or . ( j /= 0 ) . or . ( k /= 0 ) ) then counter = counter + 1 k_lat_vec_xyz = matmul ( k_red_to_xyz , 1.0_dp * [ i , j , k ]) ! distance to lattice point k_lat_mag = norm2 ( k_lat_vec_xyz ) dist_to_nearest_lattice_pts ( counter ) = k_lat_mag end if end do end do end do ! minimum distance to lattice point k_lat_mag_min = minval ( dist_to_nearest_lattice_pts ) q_max = k_lat_mag_min / 2.0_dp end function end module","tags":"","loc":"sourcefile/math_mod.f90.html"},{"title":"prec.f90 – EXCEED-DM","text":"Contents Modules prec Source Code prec.f90 Source Code module prec !! Double precision (dp) definition. use , intrinsic :: iso_fortran_env , only : dp => real64 end module","tags":"","loc":"sourcefile/prec.f90.html"},{"title":"timing.f90 – EXCEED-DM","text":"Contents Modules timing Source Code timing.f90 Source Code module timing !! Useful functions for timing a program. use prec implicit none real ( dp ) :: time ( 100 ) !! holds raw timing variables real ( dp ) :: delta_t ( 100 ) !! holds difference in timing variables contains subroutine save_timing_info ( filename , dt , verbose ) !! Saves the version number. use hdf5 use h5lt implicit none character ( len =* ) :: filename logical , optional :: verbose real ( dp ) :: dt integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] logical :: file_exists integer :: error if ( verbose ) then print * , 'Saving timing parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'timing' , group_id , error ) ! write data call h5ltmake_dataset_string_f ( file_id , & 'timing/total_run_time_str' , & trim ( adjustl ( pretty_time_format ( dt ))), & error ) call h5ltmake_dataset_string_f ( file_id , & 'timing/start_date_str' , & trim ( adjustl ( pretty_date_and_time ())), & error ) call h5ltmake_dataset_double_f ( file_id , & 'timing/total_run_time_s' , & size ( dims1 ), dims1 , & dt , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) end if end subroutine function pretty_time_format ( t ) result ( time_str ) !! Returns a nicely formatted string of the time. implicit none real ( dp ) :: t integer :: time_hr integer :: time_min integer :: time_sec character ( len = 30 ) :: hr_str character ( len = 30 ) :: min_str character ( len = 30 ) :: s_str character ( len = 30 ) :: ms_str character ( len = 512 ) :: time_str if ( t < 1.0_dp ) then write ( ms_str , * ) t * 10 ** 3 write ( time_str , * ) trim ( adjustl ( ms_str )) // ' ms' else time_hr = floor ( t / 360 0.0_dp ) time_min = floor (( t - time_hr * 360 0.0_dp ) / 6 0.0_dp ) time_sec = nint ( t - time_hr * 360 0.0_dp - time_min * 6 0.0_dp ) write ( hr_str , * ) time_hr write ( min_str , * ) time_min write ( s_str , * ) time_sec write ( time_str , * ) trim ( adjustl ( hr_str )) // ' hr ' // & trim ( adjustl ( min_str )) // ' min ' // & trim ( adjustl ( s_str )) // ' s' end if end function function pretty_date_and_time () result ( dt_str ) !! Returns a nicely formatted string of the current date and time. implicit none integer :: dt_values ( 8 ) character ( len = 512 ) :: dt_str character ( len = 30 ) :: hr_str character ( len = 30 ) :: min_str character ( len = 30 ) :: s_str character ( len = 30 ) :: ms_str character ( len = 30 ) :: month_str character ( len = 30 ) :: day_str character ( len = 30 ) :: year_str call date_and_time ( values = dt_values ) write ( year_str , * ) dt_values ( 1 ) write ( month_str , * ) dt_values ( 2 ) write ( day_str , * ) dt_values ( 3 ) ! ! append zeros for pretty printing if ( dt_values ( 5 ) < 10 ) then write ( hr_str , * ) dt_values ( 5 ) write ( hr_str , * ) '0' // trim ( adjustl ( hr_str )) else write ( hr_str , * ) dt_values ( 5 ) end if if ( dt_values ( 6 ) < 10 ) then write ( min_str , * ) dt_values ( 6 ) write ( min_str , * ) '0' // trim ( adjustl ( min_str )) else write ( min_str , * ) dt_values ( 6 ) end if if ( dt_values ( 7 ) < 10 ) then write ( s_str , * ) dt_values ( 7 ) write ( s_str , * ) '0' // trim ( adjustl ( s_str )) else write ( s_str , * ) dt_values ( 7 ) end if if ( dt_values ( 8 ) < 10 ) then write ( ms_str , * ) dt_values ( 8 ) write ( ms_str , * ) '00' // trim ( adjustl ( ms_str )) end if if ( ( dt_values ( 8 ) >= 10 ) . and . ( dt_values ( 8 ) < 100 ) ) then write ( ms_str , * ) dt_values ( 8 ) write ( ms_str , * ) '0' // trim ( adjustl ( ms_str )) end if if ( dt_values ( 8 ) >= 100 ) then write ( ms_str , * ) dt_values ( 8 ) end if write ( dt_str , * ) trim ( adjustl ( hr_str )),& ':' , trim ( adjustl ( min_str )),& ':' , trim ( adjustl ( s_str )),& '.' , trim ( adjustl ( ms_str )), & ' ' , trim ( adjustl ( month_str )),& '/' , trim ( adjustl ( day_str )),& '/' , trim ( adjustl ( year_str )) end function end module","tags":"","loc":"sourcefile/timing.f90.html"},{"title":"units.f90 – EXCEED-DM","text":"Contents Modules units Source Code units.f90 Source Code module units !! Unit conversion factors. !! !! To convert a variable from  x  units to  y  units: var_y = x_to_y * var_x. use prec implicit none real ( dp ) :: inv_Ang_to_eV = 197 3.37_dp real ( dp ) :: inv_eV_to_cm = 1.97327e-5_dp real ( dp ) :: Ang_to_inv_eV = 5.068e-4_dp real ( dp ) :: g_to_eV = 5.61e32_dp real ( dp ) :: kg_to_eV = 5.61e35_dp real ( dp ) :: inv_cm_to_eV = 1.97327e-5_dp real ( dp ) :: eV_to_inv_cm = 5.06773e4_dp real ( dp ) :: km_per_sec_to_none = 3.33563e-6_dp real ( dp ) :: yr_to_inv_eV = 4.7912e22_dp end module","tags":"","loc":"sourcefile/units.f90.html"},{"title":"calc_dielectric_vc.f90 – EXCEED-DM","text":"Contents Modules calc_dielectric_vc Source Code calc_dielectric_vc.f90 Source Code module calc_dielectric_vc !! Compute contributions to the dielectric,  \\varepsilon , from valence  \\rightarrow  conduction !! transitions. use prec use constants use units use math_mod use width_parameters_type use bins_dielectric_type use expt_type use material_type use dm_model_type use PW_dataset_type use numerics_dielectric use transition_form_factor use FFT_util implicit none interface dielectric_calc_vc module procedure dielectric_calc_vc_no_spin module procedure dielectric_calc_vc_spin end interface contains subroutine dielectric_calc_vc_spin ( di , & FFT_grid , PW_dataset , target_mat , bins , & widths , numerics , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , & verbose ) !! Compute contributions to the dielectric,  \\varepsilon , from valence  \\rightarrow  conduction !! transitions with spin dependent wave functions. implicit none complex ( dp ) :: di (:, :, :, :) type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_dielectric_t ) :: bins type ( width_parameters_t ) :: widths type ( numerics_dielectric_t ) :: numerics complex ( dp ) :: wfc_ik (:, :, :, :) complex ( dp ) :: wfc_fkf (:, :, :, :) integer :: val_id integer :: cond_id integer :: k integer :: kf logical , optional :: verbose real ( dp ) :: omega real ( dp ) :: q_vec ( 3 ) integer :: g1 , g2 , g3 real ( dp ) :: f_sq ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) integer :: w complex ( dp ) :: elec_props ( bins % n_E ) real ( dp ) :: d_omega real ( dp ) :: delta integer :: q_bin , q_theta_bin , q_phi_bin real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_mag , q_phi , q_theta real ( dp ) :: Ei , Ef integer :: q1 , q2 , q3 real ( dp ) :: q_red ( 3 ) integer :: q_ind ( 3 ) real ( dp ) :: ddi ( bins % n_E , bins % n_q , bins % n_q_theta , bins % n_q_phi ) ddi = ( 0.0_dp , 0.0_dp ) call calc_tff_pw_pw ([ 1 , 1 ], f_sq , wfc_ik , wfc_fkf , & FFT_grid % n_grid , FFT_grid % plan , verbose = . FALSE .) Ei = PW_dataset % energy_bands ( k , val_id ) Ef = PW_dataset % energy_bands ( kf , cond_id ) do w = 1 , bins % n_E omega = bins % E_width * ( w - 0.5_dp ) d_omega = Ef - Ei ! currently, only compute with one  \\delta  parameterization at a time. delta = widths % get_width ( 1 , omega ) elec_props ( w ) = ( omega - d_omega + ii * delta ) ** ( - 1 ) - & ( omega + d_omega - ii * delta ) ** ( - 1 ) end do do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) q_vec = PW_dataset % k_grid_xyz ( kf , :) & - PW_dataset % k_grid_xyz ( k , :) + & FFT_grid % sym_G_grid_xyz ( g1 , g2 , g3 , :) q_red = PW_dataset % k_grid_red ( kf , :) & - PW_dataset % k_grid_red ( k , :) + & FFT_grid % sym_G_grid_red ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > 1.0e-8_dp ) . and . & ( q_mag < bins % n_q * bins % q_width ) ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) q_theta_bin = Q_func ( q_theta , 0.0_dp ,& pi / max ( 1.0_dp , 1.0_dp * bins % n_q_theta ), bins % n_q_theta ) q_phi_bin = Q_func ( q_phi , 0.0_dp ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * bins % n_q_phi ), bins % n_q_phi ) q_bin = 1 + floor ( q_mag / bins % q_width ) ddi (:, q_bin , q_theta_bin , q_phi_bin ) = & ddi (:, q_bin , q_theta_bin , q_phi_bin ) + & ( - 1.0_dp ) * ( PW_dataset % spin_degen / 2.0_dp ) * & ( e_EM ** 2 / q_mag ** 2 ) * ( target_mat % pc_vol ) ** ( - 1 ) * & PW_dataset % k_weight ( k ) * ( 1.0_dp * FFT_grid % n ) ** ( - 2 ) * & elec_props (:) * f_sq ( g1 , g2 , g3 ) end if end do end do end do ! divide by the number of elements in each bin do q1 = 1 , bins % n_q do q2 = 1 , bins % n_q_theta do q3 = 1 , bins % n_q_phi ddi (:, q1 , q2 , q3 ) = ddi (:, q1 , q2 , q3 ) / max ( 1 , numerics % n_q_bin ( q1 , q2 , q3 )) end do end do end do di = di + ddi end subroutine subroutine dielectric_calc_vc_no_spin ( di , & FFT_grid , PW_dataset , target_mat , bins , & widths , numerics , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , & verbose ) !! Compute contributions to the dielectric,  \\varepsilon , from valence  \\rightarrow  conduction !! transitions with spin independent wave functions. implicit none complex ( dp ) :: di (:, :, :, :) type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_dielectric_t ) :: bins type ( width_parameters_t ) :: widths type ( numerics_dielectric_t ) :: numerics complex ( dp ) :: wfc_ik (:, :, :) complex ( dp ) :: wfc_fkf (:, :, :) integer :: val_id integer :: cond_id integer :: k integer :: kf logical , optional :: verbose real ( dp ) :: omega real ( dp ) :: q_vec ( 3 ) integer :: g1 , g2 , g3 real ( dp ) :: f_sq ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) integer :: w complex ( dp ) :: elec_props ( bins % n_E ) real ( dp ) :: d_omega real ( dp ) :: delta integer :: q_bin , q_theta_bin , q_phi_bin real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_mag , q_phi , q_theta real ( dp ) :: Ei , Ef integer :: q1 , q2 , q3 real ( dp ) :: q_red ( 3 ) integer :: q_ind ( 3 ) complex ( dp ) :: ddi ( bins % n_E , bins % n_q , bins % n_q_theta , & bins % n_q_phi ) ddi = ( 0.0_dp , 0.0_dp ) call calc_tff_pw_pw ([ 1 , 1 ], f_sq , wfc_ik , wfc_fkf , & FFT_grid % n_grid , FFT_grid % plan , verbose = . FALSE .) Ei = PW_dataset % energy_bands ( k , val_id ) Ef = PW_dataset % energy_bands ( kf , cond_id ) do w = 1 , bins % n_E omega = bins % E_width * ( w - 0.5_dp ) d_omega = Ef - Ei ! currently, only compute with one  \\delta  parameterization at a time. delta = widths % get_width ( 1 , omega ) elec_props ( w ) = ( omega - d_omega + ii * delta ) ** ( - 1 ) - & ( omega + d_omega - ii * delta ) ** ( - 1 ) end do do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) q_vec = PW_dataset % k_grid_xyz ( kf , :) & - PW_dataset % k_grid_xyz ( k , :) + & FFT_grid % sym_G_grid_xyz ( g1 , g2 , g3 , :) q_red = PW_dataset % k_grid_red ( kf , :) & - PW_dataset % k_grid_red ( k , :) + & FFT_grid % sym_G_grid_red ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > 1.0e-8_dp ) . and . & ( q_mag < bins % n_q * bins % q_width ) ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) q_theta_bin = Q_func ( q_theta , 0.0_dp ,& pi / max ( 1.0_dp , 1.0_dp * bins % n_q_theta ), bins % n_q_theta ) q_phi_bin = Q_func ( q_phi , 0.0_dp ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * bins % n_q_phi ), bins % n_q_phi ) q_bin = 1 + floor ( q_mag / bins % q_width ) ddi (:, q_bin , q_theta_bin , q_phi_bin ) = & ddi (:, q_bin , q_theta_bin , q_phi_bin ) + & ( - 1.0_dp ) * ( PW_dataset % spin_degen / 2.0_dp ) * & ( e_EM ** 2 / q_mag ** 2 ) * ( target_mat % pc_vol ) ** ( - 1 ) * & PW_dataset % k_weight ( k ) * ( 1.0_dp * FFT_grid % n ) ** ( - 2 ) * & elec_props (:) * f_sq ( g1 , g2 , g3 ) end if end do end do end do ! divide by the number of elements in each bin do q1 = 1 , bins % n_q do q2 = 1 , bins % n_q_theta do q3 = 1 , bins % n_q_phi ddi (:, q1 , q2 , q3 ) = ddi (:, q1 , q2 , q3 ) / max ( 1 , numerics % n_q_bin ( q1 , q2 , q3 )) end do end do end do di = di + ddi end subroutine end module","tags":"","loc":"sourcefile/calc_dielectric_vc.f90.html"},{"title":"exdm_dielectric.f90 – EXCEED-DM","text":"Contents Modules exdm_dielectric Source Code exdm_dielectric.f90 Source Code module exdm_dielectric !! Compute the dielectric function,  \\varepsilon(\\mathbf{q}, \\omega) . !! !! Note : currently only includes valence  \\rightarrow  conduction contributions. !! !! Equations: !! !!\\begin{align*} !!      \\varepsilon(\\mathbf{q}, \\omega) & = 1 - \\frac{e&#94;2}{q&#94;2} \\Pi_{11}(\\mathbf{q}, \\omega) \\\\ !!      \\Pi_{11} & = \\frac{1}{V} \\sum_{II'} G(\\omega, \\Delta \\omega_{II'}) !!      | \\langle I' | e&#94;{i \\mathbf{q} \\cdot \\mathbf{x}} | I \\rangle |&#94;2 \\\\ !!      G(\\omega, \\Delta \\omega) & = \\frac{1}{\\omega - \\Delta \\omega + i \\delta} !!      - \\frac{1}{\\omega + \\Delta \\omega - i \\delta } !! \\end{align*} use mpi use prec use io_input use control_input use bins_dielectric_type use dm_model_type use expt_type use material_type use PW_dataset_type use width_parameters_type use FFT_util use MPI_util use numerics_dielectric use calc_dielectric_vc implicit none contains subroutine run_exdm_dielectric ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , verbose ) !! Compute the dielectric function,  \\varepsilon(\\mathbf{q}, \\omega) . !! !! Note : currently only includes valence  \\rightarrow  conduction contributions. !! !! Equations: !! !!\\begin{align*} !!      \\varepsilon(\\mathbf{q}, \\omega) & = 1 - \\frac{e&#94;2}{q&#94;2} \\Pi_{11}(\\mathbf{q}, \\omega) \\\\ !!      \\Pi_{11} & = \\frac{1}{V} \\sum_{II'} G(\\omega, \\Delta \\omega_{II'}) !!      | \\langle I' | e&#94;{i \\mathbf{q} \\cdot \\mathbf{x}} | I \\rangle |&#94;2 \\\\ !!      G(\\omega, \\Delta \\omega) & = \\frac{1}{\\omega - \\Delta \\omega + i \\delta} !!      - \\frac{1}{\\omega + \\Delta \\omega - i \\delta } !! \\end{align*} implicit none integer :: proc_id , root_process , n_proc type ( io_files_t ) :: io_files type ( control_t ) :: main_control type ( material_t ) :: target_mat logical , optional :: verbose logical :: file_exists type ( PW_dataset_t ) :: PW_dataset type ( bins_dielectric_t ) :: bins type ( numerics_dielectric_t ) :: numerics type ( FFT_grid_t ) :: FFT_grid type ( parallel_manager_t ) :: ik_manager type ( width_parameters_t ) :: widths integer :: i integer :: n_FFT_grid ( 3 ) integer , allocatable :: job_id_to_ik (:, :) complex ( dp ), allocatable :: wfc_ik (:, :, :) complex ( dp ), allocatable :: wfc_iks (:, :, :, :) complex ( dp ), allocatable :: wfc_fkf (:, :, :) complex ( dp ), allocatable :: wfc_fkfs (:, :, :, :) integer :: job_id , j integer :: val_id , cond_id , f , k , kf complex ( dp ), allocatable :: dielec (:, :, :, :) !! Dim : [ bins%n_E, bins%n_q, bins%n_q_theta, bins%n_q_phi ] !! !!\\begin{align*} !!      \\eps(\\mathbf{q}, \\omega) & = 1 - \\frac{e&#94;2}{q&#94;2} \\Pi_{11}(\\mathbf{q}, \\omega) !!      \\Pi_{11} & = \\frac{1}{V} \\sum_{II'} G(\\omega, \\Delta \\omega_{II'}) !!      | \\langle I' | e&#94;{i \\mathbf{q} \\cdot \\mathbf{x} | I \\rangle |&#94;2 \\\\ !!      G(\\omega, \\Delta \\omega) & = \\frac{1}{\\omega - \\Delta \\omega + i \\delta} !!      - \\frac{1}{\\omega + \\Delta \\omega - i \\delta } !! \\end{align*} !! !! Units : None character ( len = 512 ) :: dielectric_output_filename if ( trim ( main_control % process ) == 'dielectric' ) then dielectric_output_filename = io_files % out_filename else dielectric_output_filename = io_files % dielectric_filename end if call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call numerics % load ( io_files % nml_input_filename , & PW_dataset % n_val , PW_dataset % n_cond , verbose = verbose ) if ( verbose ) then print * , 'Starting dielectric calculation...' print * end if call bins % load ( io_files % nml_input_filename , verbose = verbose ) call widths % load ( io_files % nml_input_filename , verbose = verbose ) ! doubled to avoid wrapping problems do i = 1 , 3 n_FFT_grid ( i ) = 2 * (& maxval ( PW_dataset % G_grid_red (:, i )) - minval ( PW_dataset % G_grid_red (:, i ))& ) + 1 end do call FFT_grid % init ( n_FFT_grid , PW_dataset % k_red_to_xyz , 'b' , verbose = verbose ) call FFT_grid % print ( verbose = verbose ) ! create job table, parallelizing over {i, k} call ik_manager % init ( PW_dataset % n_k * numerics % n_val_max , verbose = verbose ) call check_dielectric_memory ( ik_manager % n_jobs_per_proc * & bins % n_E * bins % n_q * bins % n_q_theta * bins % n_q_phi , verbose = verbose ) allocate ( job_id_to_ik ( ik_manager % n_jobs , 4 )) job_id_to_ik = 0 call numerics % create_val_id_list ( PW_dataset % n_val ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ik_manager % create_job_to_2d_ID_table (& numerics % val_id_list , & numerics % k_id_list , & job_id_to_ik , verbose = verbose ) allocate ( dielec ( bins % n_E , bins % n_q , bins % n_q_theta , bins % n_q_phi )) ! factor of 1 in dielectric formula dielec = ( 1.0_dp , 0.0_dp ) call numerics % define_q_grid ( bins % n_q * bins % q_width , & PW_dataset , FFT_grid ) call numerics % compute_n_q_bin ( bins , PW_dataset , verbose = verbose ) ! time calculation if ( ( proc_id == root_process ) . and . ( main_control % timer ) ) then call time_exdm_dielectric_calc ( FFT_grid , PW_dataset , target_mat , & bins , widths , numerics , ik_manager % n_jobs_per_proc , & PW_dataset % n_val , PW_dataset % n_val + 1 , 1 , 1 , verbose = verbose ) end if ! allocate wave functions if ( PW_dataset % include_spin ) then allocate ( wfc_iks ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkfs ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) else allocate ( wfc_ik ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) end if if ( verbose ) then print * , 'Calculating the dielectric...' print * end if do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then ! count states down from highest valence band val_id = job_id_to_ik ( job_id , 1 ) k = job_id_to_ik ( job_id , 2 ) if ( PW_dataset % include_spin ) then ! load initial wave function call PW_dataset % load_wfc_ik_expanded_spin ( val_id , k , FFT_grid , wfc_iks ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f do kf = 1 , PW_dataset % n_k ! load final wave function call PW_dataset % load_wfc_ik_expanded_spin ( cond_id , kf , FFT_grid , wfc_fkfs ) ! compute dielectric call dielectric_calc_vc ( dielec , & FFT_grid , PW_dataset , target_mat , bins , widths , numerics , & wfc_iks , wfc_fkfs , val_id , cond_id , k , kf , verbose = . FALSE .) end do end do else ! load initial wave function call PW_dataset % load_wfc_ik_expanded_no_spin ( val_id , k , FFT_grid , wfc_ik ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f do kf = 1 , PW_dataset % n_k ! load final wave function call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) ! compute dielectric call dielectric_calc_vc ( dielec , & FFT_grid , PW_dataset , target_mat , bins , widths , numerics , & wfc_ik , wfc_fkf , val_id , cond_id , k , kf , verbose = . FALSE .) end do end do end if end if end do if ( verbose ) then print * , 'Done calculating the dielectric!' print * end if call comm_reduce_dielectric ( proc_id , root_process , dielec , verbose = verbose ) if ( proc_id == root_process ) then call numerics % save ( dielectric_output_filename , verbose = verbose ) call bins % save ( dielectric_output_filename , verbose = verbose ) call save_dielectric ( dielectric_output_filename , dielec , verbose = verbose ) end if end subroutine subroutine time_exdm_dielectric_calc ( FFT_grid , PW_dataset , target_mat , & bins , widths , numerics , n_jobs_per_proc , val_id , cond_id , k , kf , verbose ) !! Clocks the valence  \\rightarrow  conduction dielectric calculation !! by running a smaller version of the program. use timing use mpi implicit none type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_dielectric_t ) :: bins type ( width_parameters_t ) :: widths type ( numerics_dielectric_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id , cond_id , k , kf logical , optional :: verbose complex ( dp ), allocatable :: wfc_ik (:, :, :) complex ( dp ), allocatable :: wfc_iks (:, :, :, :) complex ( dp ), allocatable :: wfc_fkf (:, :, :) complex ( dp ), allocatable :: wfc_fkfs (:, :, :, :) complex ( dp ) :: dielec ( bins % n_E , bins % n_q , bins % n_q_theta , bins % n_q_phi ) if ( verbose ) then print * , 'Timing dielectric calculation...' print * end if if ( PW_dataset % include_spin ) then allocate ( wfc_iks ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkfs ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) call PW_dataset % load_wfc_ik_expanded_spin ( val_id , k , FFT_grid , wfc_iks ) else allocate ( wfc_ik ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) call PW_dataset % load_wfc_ik_expanded_no_spin ( val_id , k , FFT_grid , wfc_ik ) end if ! factor of 1 in dielectric formula dielec = ( 1.0_dp , 0.0_dp ) time ( 3 ) = MPI_Wtime () if ( PW_dataset % include_spin ) then call PW_dataset % load_wfc_ik_expanded_spin ( cond_id , kf , FFT_grid , wfc_fkfs ) call dielectric_calc_vc ( dielec , & FFT_grid , PW_dataset , target_mat , & bins , widths , numerics , & wfc_iks , wfc_fkfs , & val_id , cond_id , k , kf , verbose = . FALSE .) else call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) call dielectric_calc_vc ( dielec , & FFT_grid , PW_dataset , target_mat , & bins , widths , numerics , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , verbose = . FALSE .) end if time ( 4 ) = MPI_Wtime () if ( verbose ) then call print_section_seperator () print * , '    --------------------------' print * , '    Timing - Dielectric (TEST)' print * , '    --------------------------' print * print * , '        (TEST) Run time: ' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        Expected run time for whole calculation : ' print * , '            ' , trim ( pretty_time_format (& n_jobs_per_proc * PW_dataset % n_k * numerics % n_cond_max * ( time ( 4 ) - time ( 3 ))& )) print * call print_section_seperator () print * end if end subroutine subroutine save_dielectric ( filename , dielectric , verbose ) !! Saves the dielectric. implicit none character ( len =* ) :: filename complex ( dp ) :: dielectric (:, :, :, :) logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] ! integer(HSIZE_T) :: dims2(2) integer ( HSIZE_T ) :: dims4 ( 4 ) integer :: error if ( verbose ) then print * , 'Saving dielectric...' print * end if ! open the file to write call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'dielectric' , group_id , error ) dims4 = [ size ( dielectric , 1 ), & size ( dielectric , 2 ), & size ( dielectric , 3 ), & size ( dielectric , 4 )] call h5ltmake_dataset_double_f ( file_id , 'dielectric/dielectric_r' , & size ( dims4 ), dims4 ,& real ( dielectric ), error ) call h5ltmake_dataset_double_f ( file_id , 'dielectric/dielectric_c' , & size ( dims4 ), dims4 ,& aimag ( dielectric ), error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) end subroutine end module","tags":"","loc":"sourcefile/exdm_dielectric.f90.html"},{"title":"numerics_dielectric.f90 – EXCEED-DM","text":"Contents Modules numerics_dielectric Source Code numerics_dielectric.f90 Source Code module numerics_dielectric !! Numerics parameters specific to the dielectric calculation. use prec use info_messages implicit none type numerics_dielectric_t !! Numerics parameters specific to the dielectric calculation. integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands integer , allocatable :: val_id_list (:) !! Dim : [n_val_max] !! !! List of valence ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_k] !! !! List of k's to compute for. integer :: n_k_vec ( 3 ) !! Number of  \\mathbf{k}  vectors in each direction. real ( dp ) :: q_grid_min ( 3 ) !! Offset parameter to map  \\mathbf{q}  coordinates to !! indicies. integer :: n_q_grid ( 3 ) !! Number of points in the q grid with  q < bins%n_q*bins%q_width  integer , allocatable :: n_q_bin (:, :, :) !! Dim : [n_q, n_q_theta, n_q_phi] !! !! Number of points in the dielectric  \\mathbf{q}  grid in each  \\{q, \\theta_q, \\phi_q \\}  bin. contains procedure :: print => numerics_dielectric_print procedure :: load => numerics_dielectric_load_nml procedure :: save => numerics_dielectric_save procedure :: create_val_id_list => dielectric_create_val_id_list procedure :: create_k_id_list => dielectric_create_k_id_list procedure :: define_q_grid procedure :: compute_n_q_bin end type contains subroutine compute_n_q_bin ( self , bins , PW_dataset , verbose ) !! Find the number of  \\mathbf{q}  points from the uniformly spaced grid that are in each !! in a  \\{q, \\theta_q, \\phi_q \\}  bin. use bins_dielectric_type use PW_dataset_type use math_mod implicit none class ( numerics_dielectric_t ) :: self type ( bins_dielectric_t ) :: bins type ( PW_dataset_t ) :: PW_dataset logical , optional :: verbose integer :: q1 , q2 , q3 real ( dp ) :: q_mag , q_theta , q_phi real ( dp ) :: q_red ( 3 ) real ( dp ) :: q_vec ( 3 ) real ( dp ) :: q_hat ( 3 ) integer :: q_bin , q_theta_bin , q_phi_bin allocate ( self % n_q_bin ( bins % n_q , bins % n_q_theta , bins % n_q_phi )) self % n_q_bin = 0 ! now bin the unbinned dielectric do q3 = 1 , self % n_q_grid ( 3 ) do q2 = 1 , self % n_q_grid ( 2 ) do q1 = 1 , self % n_q_grid ( 1 ) q_red ( 1 ) = ( 1.0_dp / self % n_k_vec ( 1 )) * ( q1 - 1 ) + self % q_grid_min ( 1 ) q_red ( 2 ) = ( 1.0_dp / self % n_k_vec ( 2 )) * ( q2 - 1 ) + self % q_grid_min ( 2 ) q_red ( 3 ) = ( 1.0_dp / self % n_k_vec ( 3 )) * ( q3 - 1 ) + self % q_grid_min ( 3 ) q_vec = matmul ( PW_dataset % k_red_to_xyz , q_red ) q_mag = norm2 ( q_vec ) if ( ( q_mag > 1.0e-8_dp ) . and . & ( q_mag < bins % n_q * bins % q_width ) ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) q_theta_bin = Q_func ( q_theta , 0.0_dp ,& pi / max ( 1.0_dp , 1.0_dp * bins % n_q_theta ), bins % n_q_theta ) q_phi_bin = Q_func ( q_phi , 0.0_dp ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * bins % n_q_phi ), bins % n_q_phi ) q_bin = 1 + floor ( q_mag / bins % q_width ) self % n_q_bin ( q_bin , q_theta_bin , q_phi_bin ) = & self % n_q_bin ( q_bin , q_theta_bin , q_phi_bin ) + 1 end if end do end do end do end subroutine subroutine define_q_grid ( self , q_max , PW_dataset , FFT_grid ) !! Given a uniform grid  in the 1BZ for  \\mathbf{k}, \\mathbf{k}' , !! and a uniform grid of  \\mathbf{G} 's, finds the uniform lattice of !!  \\mathbf{q} = \\mathbf{k}' - \\mathbf{k}  + \\mathbf{G}  points which have  q < q_\\text{max} . !! !! The fundamental lattice spacing is  1/\\mathbf{N}_\\mathbf{k} , !! where  \\mathbf{N}_\\mathbf{k}  is the numebr of  \\mathbf{k}  points in each direction. Therefore every  \\mathbf{q}  point !! in the grid is uniquely indexed, `index` = [1, 1, 1] !! +  \\mathbf{N}_\\mathbf{k} ( \\mathbf{q}_\\text{red} - \\mathbf{q}_\\text{red, min} )  once the minimum  !! \\mathbf{q}_\\text{red}  in the grid is known. We also find the number of  \\mathbf{q}  points in the !! grid,  \\mathbf{N}_q = \\mathbf{N}_k \\left( \\mathbf{q}_\\text{red, max} - \\mathbf{q}_\\text{red, min} \\right) . use PW_dataset_type use FFT_util implicit none class ( numerics_dielectric_t ) :: self real ( dp ) :: q_max type ( PW_dataset_t ) :: PW_dataset type ( FFT_grid_t ) :: FFT_grid integer :: k , kp , g1 , g2 , g3 real ( dp ) :: q_mag real ( dp ) :: q_xyz ( 3 ) real ( dp ) :: dk_red ( 3 ) real ( dp ) :: dk_red_min ( 3 ) real ( dp ) :: dk_red_max ( 3 ) integer :: G_red ( 3 ) integer :: G_red_min ( 3 ) integer :: G_red_max ( 3 ) real ( dp ) :: q_red ( 3 ) real ( dp ) :: q_red_min ( 3 ) real ( dp ) :: q_red_max ( 3 ) q_red_min = 0.0_dp q_red_max = 0.0_dp do k = 1 , PW_dataset % n_k do kp = 1 , PW_dataset % n_k dk_red = PW_dataset % k_grid_red ( kp , :) - PW_dataset % k_grid_red ( k , :) do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) G_red = FFT_grid % sym_G_grid_red ( g1 , g2 , g3 , :) q_red = dk_red + G_red q_xyz = matmul ( PW_dataset % k_red_to_xyz , q_red ) q_mag = norm2 ( q_xyz ) if ( q_mag <= q_max ) then q_red_min ( 1 ) = min ( q_red ( 1 ), q_red_min ( 1 )) q_red_min ( 2 ) = min ( q_red ( 2 ), q_red_min ( 2 )) q_red_min ( 3 ) = min ( q_red ( 3 ), q_red_min ( 3 )) q_red_max ( 1 ) = max ( q_red ( 1 ), q_red_max ( 1 )) q_red_max ( 2 ) = max ( q_red ( 2 ), q_red_max ( 2 )) q_red_max ( 3 ) = max ( q_red ( 3 ), q_red_max ( 3 )) end if end do end do end do end do end do self % n_q_grid ( 1 ) = 1 + int ( self % n_k_vec ( 1 ) * ( q_red_max ( 1 ) - q_red_min ( 1 ) ) ) self % n_q_grid ( 2 ) = 1 + int ( self % n_k_vec ( 2 ) * ( q_red_max ( 2 ) - q_red_min ( 2 ) ) ) self % n_q_grid ( 3 ) = 1 + int ( self % n_k_vec ( 3 ) * ( q_red_max ( 3 ) - q_red_min ( 3 ) ) ) self % q_grid_min = q_red_min end subroutine subroutine dielectric_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the dielectric calculation. implicit none class ( numerics_dielectric_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine dielectric_create_val_id_list ( self , n_val ) !! Specify the indicies for each valence band that should be included. !! Specific to the dielectric calculation. implicit none class ( numerics_dielectric_t ) :: self integer :: n_val integer :: j allocate ( self % val_id_list ( self % n_val_max )) do j = 1 , self % n_val_max self % val_id_list ( j ) = n_val - j + 1 end do end subroutine subroutine numerics_dielectric_save ( self , filename , verbose ) !! Saves `numerics_dielectric`. use hdf5 use h5lt implicit none class ( numerics_dielectric_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving numerics - dielectric parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_dielectric' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_dielectric/n_val_max' , & size ( dims1 ), dims1 , & self % n_val_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_dielectric/n_cond_max' , & size ( dims1 ), dims1 , & self % n_cond_max , & error ) dims1 = [ 3 ] call h5ltmake_dataset_int_f ( file_id , & 'numerics_dielectric/n_k_vec' , & size ( dims1 ), dims1 , & self % n_k_vec , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_dielectric_load_nml ( self , filename , n_val , n_cond , verbose ) !! Loads `numerics_dielectric` parameters from a namelist. implicit none class ( numerics_dielectric_t ) :: self character ( len =* ) :: filename integer :: n_val , n_cond logical , optional :: verbose logical :: file_exists integer :: error integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands integer :: n_k_vec ( 3 ) NAMELIST / numerics_dielectric / n_val_max , & n_cond_max , & n_k_vec if ( verbose ) then print * , 'Loading numerics parameters for dielectric calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_dielectric , iostat = error ) close ( 100 ) if ( n_val_max == 0 ) then self % n_val_max = n_val else self % n_val_max = min ( n_val , n_val_max ) end if if ( n_cond_max == 0 ) then self % n_cond_max = n_cond else self % n_cond_max = min ( n_cond , n_cond_max ) end if self % n_k_vec = n_k_vec call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-dielectric parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_dielectric_print ( self , verbose ) !! Prints `numerics_dielectric` components. implicit none class ( numerics_dielectric_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ---------------------' print * , '    Numerics - Dielectric' print * , '    ---------------------' print * print * , '        Maximum number of valence bands    : ' , trim ( adjustl ( int_to_str ( self % n_val_max ))) print * , '        Maximum number of conduction bands : ' , trim ( adjustl ( int_to_str ( self % n_cond_max ))) print * print * , '        Number of k points in each direction : ' , self % n_k_vec print * call print_section_seperator () print * end if end subroutine subroutine check_dielectric_memory ( n , verbose ) !! Checks to see if the dielectric is going to take up too !! much memory. use info_messages implicit none integer :: n logical , optional :: verbose if ( 1 6.0_dp * n >= 1.0e10_dp ) then call print_warning_message ( 'Attempting to store more than 10 GB of dielectric data on a single processor.' // & 'Try increasing the number of processors or decreasing the number ' // & 'of energy/momentum bins in the dielectric namelist.' , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/numerics_dielectric.f90.html"},{"title":"version_control.f90 – EXCEED-DM","text":"Contents Modules version_control Source Code version_control.f90 Source Code module version_control !! Keeps track of the current version of the program. implicit none character ( len = 64 ) :: version = \"0.2.8\" contains subroutine save_version ( filename , verbose ) !! Saves the version number. use hdf5 use h5lt use info_messages implicit none character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer :: error if ( verbose ) then print * , 'Saving version parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'version' , group_id , error ) ! write data call h5ltmake_dataset_string_f ( file_id , & 'version/number' , & version , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/version_control.f90.html"},{"title":"exdm_scatter.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter Source Code exdm_scatter.f90 Source Code module exdm_scatter !! Compute the DM-electron scattering rate. use mpi use hdf5 use h5lt use prec use control_input use io_input use MPI_util use material_type use dm_model_type use expt_type use binned_scatter_rate_type use bins_scatter_type use in_med_scr_type use exdm_scatter_vc use exdm_scatter_cc use exdm_scatter_vf use exdm_scatter_cf use exdm_scatter_cc_ext implicit none contains subroutine run_exdm_scatter ( proc_id , root_process , n_proc , & io_files , main_control , target_mat , expt , dm_model , & verbose ) !! Compute the DM-electron scattering rate. implicit none integer :: proc_id integer :: root_process integer :: n_proc type ( io_files_t ) :: io_files type ( control_t ) :: main_control type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( bins_scatter_t ) :: bins type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: ierr integer :: t , i type ( binned_scatter_rate_t ), allocatable :: binned_rate_init (:) !! Dim : [ n_init ] !! !! Binned rate per cross section, per kg-year for each initial state !! !! Units : cm&#94;(-2) integer :: n_init !! Number of initial states character ( len = 64 ) :: calc_modes_list ( 5 ) = [ 'vc    ' ,& 'vf    ' ,& 'cc    ' ,& 'cf    ' ,& 'cc_ext' ] if ( verbose ) then print * , 'Starting scattering rate calculation...' print * end if ! load the screening parameters call in_med_scr % load ( proc_id , root_process , n_proc , io_files , main_control , & target_mat , verbose = verbose ) ! load the binning parameters call bins % load ( io_files % nml_input_filename , verbose = verbose ) ! set the n_init parameter if ( trim ( main_control % calc_mode ) == 'vc' ) then call exdm_scatter_vc_set_n_init ( io_files , n_init ) else if ( trim ( main_control % calc_mode ) == 'cc' ) then call exdm_scatter_cc_set_n_init ( io_files , n_init ) else if ( trim ( main_control % calc_mode ) == 'vf' ) then call exdm_scatter_vf_set_n_init ( io_files , n_init ) else if ( trim ( main_control % calc_mode ) == 'cf' ) then call exdm_scatter_cf_set_n_init ( io_files , n_init ) else if ( trim ( main_control % calc_mode ) == 'cc_ext' ) then call exdm_scatter_cc_ext_set_n_init ( io_files , n_init ) end if allocate ( binned_rate_init ( n_init )) do i = 1 , n_init call binned_rate_init ( i )% init ( bins , dm_model , expt ) end do if ( trim ( main_control % calc_mode ) == 'vc' ) then call run_exdm_scatter_vc ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose = verbose ) else if ( trim ( main_control % calc_mode ) == 'cc' ) then call run_exdm_scatter_cc ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose = verbose ) else if ( trim ( main_control % calc_mode ) == 'vf' ) then call run_exdm_scatter_vf ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose = verbose ) else if ( trim ( main_control % calc_mode ) == 'cf' ) then call run_exdm_scatter_cf ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose = verbose ) else if ( trim ( main_control % calc_mode ) == 'cc_ext' ) then call run_exdm_scatter_cc_ext ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose = verbose ) else call print_error_message ( 'Calculation mode : ' // trim ( main_control % calc_mode ) // ' is not a valid option.' , & verbose = verbose ) stop end if ! communicate computed data call comm_reduce_binned_rate_init ( proc_id , root_process , binned_rate_init , & verbose ) ! save data if ( proc_id == root_process ) then call bins % save ( io_files % out_filename , verbose = verbose ) call in_med_scr % save ( io_files % out_filename , verbose = verbose ) call save_scatter_rates ( io_files % out_filename , & bins , expt , dm_model , binned_rate_init , verbose = verbose ) end if end subroutine subroutine save_scatter_rates ( filename , bins , expt , dm_model , & binned_rate_init , verbose ) !! Saves the binned and total scattering rates. implicit none character ( len =* ) :: filename type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( dm_model_t ) :: dm_model type ( binned_scatter_rate_t ) :: binned_rate_init (:) integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id integer :: n_init type ( binned_scatter_rate_t ) :: total_binned_rate !! Total binned scattering rate. !! !! Units : cm&#94;(-2) real ( dp ) :: rate ( dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) logical , optional :: verbose logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: m , f , t integer :: i , fin n_init = size ( binned_rate_init ) call total_binned_rate % init ( bins , dm_model , expt ) ! compute total binned rate do i = 1 , n_init total_binned_rate % binned_rate = total_binned_rate % binned_rate + & binned_rate_init ( i )% binned_rate end do rate = total_binned_rate % compute_rate () if ( verbose ) then print * , 'Saving scattering rates...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'scatter_rates' , group_id , error ) dims2 = [ bins % n_q , bins % n_E ] do t = 1 , expt % n_time call h5gcreate_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))),& group_id , error ) do f = 1 , dm_model % n_med_FF call h5gcreate_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))),& group_id , error ) do m = 1 , dm_model % n_mX call h5gcreate_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))) // & '/m_' // trim ( adjustl ( int_to_str ( m ))),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))) // & '/m_' // trim ( adjustl ( int_to_str ( m ))) // & '/total' , & size ( dims1 ), dims1 ,& rate ( m , f , t ), error ) call h5ltmake_dataset_double_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))) // & '/m_' // trim ( adjustl ( int_to_str ( m ))) // & '/total_binned' , & size ( dims2 ), dims2 ,& total_binned_rate % binned_rate (:, :, m , f , t ), error ) do i = 1 , n_init call h5gcreate_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))) // & '/m_' // trim ( adjustl ( int_to_str ( m ))) // & '/init_' // trim ( adjustl ( int_to_str ( i ))),& group_id , error ) call h5ltmake_dataset_double_f ( file_id ,& 'scatter_rates' // & '/t_' // trim ( adjustl ( int_to_str ( t ))) // & '/f_' // trim ( adjustl ( int_to_str ( f ))) // & '/m_' // trim ( adjustl ( int_to_str ( m ))) // & '/init_' // trim ( adjustl ( int_to_str ( i ))) // & '/binned_i' , & size ( dims2 ), dims2 ,& binned_rate_init ( i )% binned_rate (:, :, m , f , t ), error ) end do end do end do end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter.f90.html"},{"title":"physics_scatter_functions.f90 – EXCEED-DM","text":"Contents Modules physics_scatter_functions Source Code physics_scatter_functions.f90 Source Code module physics_scatter_functions !! Physics functions needed for DM-electron scattering rate calcuations. use prec use constants use units use dm_model_type implicit none contains function v_minus ( q_vec , mX , vE_vec , omega ) result ( v_m ) !!  v_- = \\frac{1}{q} !! | \\mathbf{q} \\cdot \\mathbf{v}_E + \\frac{q&#94;2}{2 m_\\chi} + \\omega |  !! !! Note : assumes  v_- < v_\\text{esc} . !! !! Units : None implicit none real ( dp ) :: mX , omega real ( dp ) :: q_mag real ( dp ) :: v_m real ( dp ) :: q_vec ( 3 ) real ( dp ) :: vE_vec ( 3 ) q_mag = norm2 ( q_vec ) v_m = ( 1 / q_mag ) * abs ( dot_product ( q_vec , vE_vec ) + 0.5_dp * q_mag ** 2 / mX + omega ) end function function g_func ( q , v_m , dm_model ) result ( g_fun ) !! Kinematic,  g(v_-)  function. !! !!  g(\\mathbf{q}, \\omega) = 2 \\pi \\int d&#94;3\\mathbf{v} !! f_\\chi(\\mathbf{v}) \\delta(\\omega - \\omega_\\mathbf{q})  !! !!  g(v_-) = \\frac{2 \\pi&#94;2 v_0&#94;2}{N_0 q} \\left( \\exp{(-v_-&#94;2/v_0&#94;2)} - \\exp{(-v_\\text{esc}&#94;2/v_0&#94;2)} \\right)  !! !! Units :  \\text{eV}&#94;{-1}  implicit none real ( dp ) :: q , v_m type ( dm_model_t ) :: dm_model real ( dp ) :: g_fun g_fun = ( dm_model % g_func_c1 / q ) * ( exp ( - ( v_m / dm_model % v0 ) ** 2 ) - dm_model % g_func_c2 ) end function function red_mass ( m1 , m2 ) result ( mu ) !!  \\mu = \\frac{m_1 m_2}{m_1 + m_2}  implicit none real ( dp ) :: m1 , m2 real ( dp ) :: mu mu = m1 * m2 / ( m1 + m2 ) end function function F_med_sq_func ( q_mag , power ) result ( F_med_sq_val ) !! Mediator form factor squared, !!  \\mathcal{F}_\\text{med}&#94;2 = \\left( \\frac{\\alpha m_e}{q} \\right)&#94;{2 \\beta} . !! !! Units : None implicit none real ( dp ) :: q_mag real ( dp ) :: F_med_sq_val real ( dp ) :: power f_med_sq_val = ( alpha_EM * m_elec / q_mag ) ** ( 2 * power ) end function end module","tags":"","loc":"sourcefile/physics_scatter_functions.f90.html"},{"title":"transition_form_factor.f90 – EXCEED-DM","text":"Contents Modules transition_form_factor Source Code transition_form_factor.f90 Source Code module transition_form_factor ! See the documentation for LaTeX'ed math eqs. !! !! Define general scattering operators such that the scattering rate for !! any DM model can be computed. This will generalize the transition form factor (TFF) defined as !! !! \\begin{align} !!    T_{if}(\\mathcal{O}_1, \\mathcal{O}_2) \\equiv \\langle f | e&#94;{i \\mathbf{q} \\cdot \\mathbf{x}} \\mathcal{O}_1 | i \\rangle !! \\cdot \\langle i | e&#94;{-i \\mathbf{q} \\cdot \\mathbf{x}} \\mathcal{O}_2&#94;* | f \\rangle !! \\end{align} !! !! All spin independent results come from  \\mathcal{O}_1 = \\mathcal{O}_2 = 1 . Note that this quantity is different !! than the mediator form factor and screening factor, both of which can be set independently of this function. !! !! Each  \\mathcal{O}  that the user can specify will have a unique index. !! !! A catalog will be kept of all the operators and their corresponding index. !! !! The calculation can become more difficult technically depending on the operator so a hierarchy will be kept in !! order to simplify the calculation when possible. !! !! TODO: For now we will assume that only a single T_if needs to be computed. Future work could improve on this by !! setting up wrapper functions which compute multiple T's and sum them. This will be necessary when the scattering operator !! has more than one term, e.g.  \\mathcal{O} = \\frac{k}{m_e} + \\mathbf{S}_e . !! !! Catalog : !! <ul> !!     <li> !!         1 -  \\mathcal{O} = 1  [ vc (SI/SD), cc (SI) ] !!     </li> !!     <li> !!         2 -  \\mathcal{O} = \\mathbf{S}_e  [vc (SD)] !!     </li> !! </ul> !! !! Notes : Bracketed quantities indicate what transition types are currently supported, <b>s</b> indicates its only !! supported for spin dependent wave functions. use prec use constants use math_mod implicit none interface calc_tff_pw_pw module procedure calc_tff_pw_pw_no_spin module procedure calc_tff_pw_pw_spin end interface contains subroutine calc_tff_pw_pw_spin ( tff_id , TFF , wfc_i , wfc_f , n_FFT_grid , FFT_plan , verbose ) !! Compute the transition form factor between two spin dependent wave functions defined on a uniform grid in the unit cell. !! !! TFF = FFT(  u_{f, k_f}&#94;* \\mathcal{O}_1 u_{i, k_i}   )  \\times  FFT(  u_{f, k_f}&#94;* \\mathcal{O}_2 u_{i, k_i}  ) !!  &#94;*  !! !! Dim : [ n_FFT_grid ] !! !! Units : None implicit none integer :: tff_id ( 2 ) logical , optional :: verbose integer :: n_FFT_grid ( 3 ) integer :: FFT_plan ( 8 ) complex ( dp ) :: wfc_i ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: Tx_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar overlaps in position space complex ( dp ) :: Tx_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector overlaps in position space complex ( dp ) :: TFF_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar complex ( dp ) :: TFF_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector real ( dp ) :: TFF ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: op ( 2 , 2 ) integer :: i , g1 , g2 , g3 Tx_s_terms = ( 0.0_dp , 0.0_dp ) Tx_v_terms = ( 0.0_dp , 0.0_dp ) TFF_s_terms = ( 0.0_dp , 0.0_dp ) TFF_v_terms = ( 0.0_dp , 0.0_dp ) if ( tff_id ( 1 ) == tff_id ( 2 ) ) then ! only have to compute one element since the other is the complex conjugate select case ( tff_id ( 1 ) ) case ( 1 ) ! 1 do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) Tx_s_terms ( 1 , g1 , g2 , g3 ) = & conjg ( wfc_f ( 1 , g1 , g2 , g3 )) * wfc_i ( 1 , g1 , g2 , g3 ) + & conjg ( wfc_f ( 2 , g1 , g2 , g3 )) * wfc_i ( 2 , g1 , g2 , g3 ) end do end do end do call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) ! TFF_s_terms(2, :, :, :) = conjg(TFF_s_terms(1, :, :, :)) TFF = abs ( TFF_s_terms ( 1 , :, :, :)) ** 2 case ( 2 ) ! pauli matrix operator,  \\sigma&#94;i  do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) Tx_v_terms ( 1 , 1 , g1 , g2 , g3 ) = & conjg ( wfc_f ( 1 , g1 , g2 , g3 )) * wfc_i ( 2 , g1 , g2 , g3 ) + & conjg ( wfc_f ( 2 , g1 , g2 , g3 )) * wfc_i ( 1 , g1 , g2 , g3 ) Tx_v_terms ( 2 , 1 , g1 , g2 , g3 ) = & - ii * conjg ( wfc_f ( 1 , g1 , g2 , g3 )) * wfc_i ( 2 , g1 , g2 , g3 ) + & ii * conjg ( wfc_f ( 2 , g1 , g2 , g3 )) * wfc_i ( 1 , g1 , g2 , g3 ) Tx_v_terms ( 3 , 1 , g1 , g2 , g3 ) = & conjg ( wfc_f ( 1 , g1 , g2 , g3 )) * wfc_i ( 1 , g1 , g2 , g3 ) - & conjg ( wfc_f ( 2 , g1 , g2 , g3 )) * wfc_i ( 2 , g1 , g2 , g3 ) end do end do end do do i = 1 , 3 call dfftw_execute_dft ( FFT_plan , Tx_v_terms ( i , 1 , :, :, :) , TFF_v_terms ( i , 1 , :, :, :)) ! TFF_v_terms(i, 2, :, :, :) = conjg(TFF_v_terms(i, 1, :, :, :)) TFF = TFF + abs ( TFF_v_terms ( i , 1 , :, :, :)) ** 2 end do case default do g3 = 1 , n_FFT_grid ( 3 ) do g2 = 1 , n_FFT_grid ( 2 ) do g1 = 1 , n_FFT_grid ( 1 ) Tx_s_terms ( 1 , g1 , g2 , g3 ) = & conjg ( wfc_f ( 1 , g1 , g2 , g3 )) * wfc_i ( 1 , g1 , g2 , g3 ) + & conjg ( wfc_f ( 2 , g1 , g2 , g3 )) * wfc_i ( 2 , g1 , g2 , g3 ) end do end do end do call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) ! TFF_s_terms(2, :, :, :) = conjg(TFF_s_terms(1, :, :, :)) TFF = abs ( TFF_s_terms ( 1 , :, :, :)) ** 2 end select end if end subroutine subroutine calc_tff_pw_pw_no_spin ( tff_id , TFF , wfc_i , wfc_f , n_FFT_grid , FFT_plan , verbose ) !! Compute the transition form factor between two spin independent wave functions defined on a uniform grid in the unit cell. !! !! TFF = FFT(  u_{f, k_f}&#94;* \\mathcal{O}_1 u_{i, k_i}   )  \\times  FFT(  u_{f, k_f}&#94;* \\mathcal{O}_2 u_{i, k_i}  ) !!  &#94;*  !! !! Dim : [ n_FFT_grid ] !! !! Units : None implicit none logical , optional :: verbose integer :: tff_id ( 2 ) integer :: n_FFT_grid ( 3 ) integer :: FFT_plan ( 8 ) complex ( dp ) :: wfc_i ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: wfc_f ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) complex ( dp ) :: Tx_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar overlap in position space complex ( dp ) :: Tx_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector overlap in position space complex ( dp ) :: TFF_s_terms ( 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! scalar complex ( dp ) :: TFF_v_terms ( 3 , 2 , n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) !! vector real ( dp ) :: TFF ( n_FFT_grid ( 1 ), n_FFT_grid ( 2 ), n_FFT_grid ( 3 )) Tx_s_terms = ( 0.0_dp , 0.0_dp ) Tx_v_terms = ( 0.0_dp , 0.0_dp ) TFF_s_terms = ( 0.0_dp , 0.0_dp ) TFF_v_terms = ( 0.0_dp , 0.0_dp ) if ( tff_id ( 1 ) == tff_id ( 2 ) ) then ! only have to compute one element since the other is the complex conjugate select case ( tff_id ( 1 ) ) case ( 1 ) ! 1 Tx_s_terms ( 1 , :, :, :) = conjg ( wfc_f ) * wfc_i call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) ! TFF_s_terms(2, :, :, :)  = conjg(TFF_s_terms(1, :, :, :)) TFF = abs ( TFF_s_terms ( 1 , :, :, :)) ** 2 case default Tx_s_terms ( 1 , :, :, :) = conjg ( wfc_f ) * wfc_i call dfftw_execute_dft ( FFT_plan , Tx_s_terms ( 1 , :, :, :) , TFF_s_terms ( 1 , :, :, :)) ! TFF_s_terms(2, :, :, :)  = conjg(TFF_s_terms(1, :, :, :)) TFF = abs ( TFF_s_terms ( 1 , :, :, :)) ** 2 end select end if end subroutine end module","tags":"","loc":"sourcefile/transition_form_factor.f90.html"},{"title":"calc_exdm_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_cc Source Code calc_exdm_scatter_cc.f90 Source Code module calc_exdm_scatter_cc !! Compute i, f, \\mathbf{k}_f  contributions to the core  \\rightarrow  conduction DM-electron scattering rate. use prec use constants use units use math_mod use binned_scatter_rate_type use bins_scatter_type use expt_type use material_type use dm_model_type use PW_dataset_type use core_electron_type use in_med_scr_type use FFT_util use physics_scatter_functions use transition_form_factor implicit none contains subroutine exdm_scatter_cc_calc ( binned_rate ,& FFT_grid , core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_i , wfc_fkf , & init_id , cond_id , kf , verbose ) !! Compute i, f, \\mathbf{k}_f  contributions to the core  \\rightarrow  conduction DM-electron scattering rate. implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( FFT_grid_t ) :: FFT_grid type ( core_electron_t ) :: core_electron type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr integer :: init_id , cond_id , k , kf logical , optional :: verbose complex ( dp ) :: wfc_i (:, :, :) complex ( dp ) :: wfc_fkf (:, :, :) real ( dp ) :: f_sq ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) real ( dp ) :: omega , omega_max real ( dp ) :: Ei , Ef integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: scr integer :: q_bin , E_bin real ( dp ) :: f_sq_val real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) b_rate = 0.0_dp f_sq = ( 0.0_dp , 0.0_dp ) Ei = core_electron % energy ( init_id ) ! make sure Ef > 0 Ef = PW_dataset % energy_bands ( kf , cond_id ) & - minval ( PW_dataset % energy_bands (:, PW_dataset % n_val + 1 :)) omega = Ef - Ei E_bin = Q_func ( omega , & target_mat % band_gap , & bins % E_width , & bins % n_E ) if ( ( PW_dataset % energy_bands ( kf , cond_id ) <= PW_dataset % Ef_max ) & . and . ( omega >= expt % E_threshold ) ) then call calc_tff_pw_pw ( dm_model % tff_id , f_sq , wfc_i , wfc_fkf , & FFT_grid % n_grid , FFT_grid % plan , verbose = . FALSE .) ! particle physics do m = 1 , dm_model % n_mX omega_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 if ( omega < omega_max ) then q_min = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& FFT_grid % q_max , & dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) q_vec = PW_dataset % k_grid_xyz ( kf , :) & + FFT_grid % sym_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = in_med_scr % screening ( q_vec , omega ) q_bin = Q_func ( q_mag , 0.0_dp , & bins % q_width , & bins % n_q ) do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , & dm_model % med_FF ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), & dm_model % vE * expt % vE_direction ( t , :), & omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) b_rate ( q_bin , E_bin , m , :, t ) = & b_rate ( q_bin , E_bin , m , :, t ) + & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if ! multiply overall constants do m = 1 , dm_model % n_mX b_rate (:, :, m , :, :) = ( core_electron % config ( init_id , 5 ) * pi ) * & ( dm_model % rhoX / target_mat % rho_T ) * ( 2 * target_mat % pc_vol ) ** ( - 2 ) * & 2.0_dp * PW_dataset % k_weight ( kf ) * & red_mass ( dm_model % mX ( m ), m_elec ) ** ( - 2 ) * ( dm_model % mX ( m )) ** ( - 1 ) * & ( 1.0_dp * FFT_grid % n ) ** ( - 2 ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & b_rate (:, :, m , :, :) end do ! add new contributions binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_cc.f90.html"},{"title":"exdm_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_cc Source Code exdm_scatter_cc.f90 Source Code module exdm_scatter_cc !! Compute the core  \\rightarrow  conduction DM-electron scattering rate. use mpi use prec use info_messages use io_input use control_input use binned_scatter_rate_type use dm_model_type use expt_type use material_type use PW_dataset_type use core_electron_type use in_med_scr_type use FFT_util use MPI_util use numerics_scatter_cc use calc_exdm_scatter_cc implicit none contains subroutine exdm_scatter_cc_set_n_init ( io_files , n_init ) !! Sets the number of initial states to record the rate for. !! Specific to the core  \\rightarrow  conduction DM-electron !! scattering rate calculation. implicit none type ( io_files_t ) :: io_files integer :: n_init type ( PW_dataset_t ) :: PW_dataset type ( numerics_scatter_cc_t ) :: numerics type ( core_electron_t ) :: core_electron call PW_dataset % load ( io_files % PW_data_filename , verbose = . FALSE .) call core_electron % load ( io_files % core_elec_config_filename , io_files % sto_data_filename , & verbose = . FALSE .) call numerics % load ( io_files % nml_input_filename , PW_dataset % n_cond , verbose = . FALSE .) call numerics % create_core_id_list ( core_electron ) n_init = size ( numerics % core_id_list ) end subroutine subroutine run_exdm_scatter_cc ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose ) !! Compute the core  \\rightarrow  conduction DM-electron scattering rate. implicit none integer :: n_init integer :: n_proc integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init ( n_init ) type ( control_t ) :: main_control type ( io_files_t ) :: io_files type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose type ( PW_dataset_t ) :: PW_dataset type ( FFT_grid_t ) :: fft_grid type ( parallel_manager_t ) :: ikf_manager type ( numerics_scatter_cc_t ) :: numerics type ( core_electron_t ) :: core_electron integer , allocatable :: job_id_to_ikf (:, :) integer :: init_id , core_id integer :: n_FFT_grid ( 3 ) integer :: n_jobs_per_proc integer :: i , j , f integer :: job_id integer :: cond_id , kf complex ( dp ), allocatable :: wfc_fkf (:, :, :) complex ( dp ), allocatable :: wfc_i (:, :, :) if ( verbose ) then print * , 'Starting c -> c scattering rate calculation...' print * end if call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call core_electron % load (& io_files % core_elec_config_filename , & io_files % STO_data_filename , verbose = verbose ) call numerics % load ( io_files % nml_input_filename ,& PW_dataset % n_cond , verbose = verbose ) ! at least doubled to avoid wrapping problems do i = 1 , 3 n_FFT_grid ( i ) = max (& 2 * (& maxval ( PW_dataset % G_grid_red (:, i )) & - minval ( PW_dataset % G_grid_red (:, i ))& ) + 1 , & numerics % n_FFT_grid ( i )& ) end do call FFT_grid % init ( n_FFT_grid , PW_dataset % k_red_to_xyz , 'b' , verbose = verbose ) call FFT_grid % print ( verbose = verbose ) ! create job table, parallelizing over {i, kf} call ikf_manager % init ( PW_dataset % n_k * n_init , verbose = verbose ) allocate ( job_id_to_ikf ( ikf_manager % n_jobs , 4 )) job_id_to_ikf = 0 call numerics % create_core_id_list ( core_electron ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ikf_manager % create_job_to_2d_ID_table (& numerics % core_id_list , & numerics % k_id_list , & job_id_to_ikf , verbose = verbose ) ! time calculation if ( ( proc_id == root_process ) . and . ( main_control % timer ) ) then call time_exdm_scatter_cc_calc ( FFT_grid , core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , numerics , ikf_manager % n_jobs_per_proc , & core_electron % n_state , PW_dataset % n_val + 1 , 1 , verbose = verbose ) end if ! allocate wave functions allocate ( wfc_i ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) ! do calculation if ( verbose ) then print * , 'Calculating transition rates...' print * end if do j = 1 , ikf_manager % n_jobs_per_proc job_id = ikf_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then core_id = job_id_to_ikf ( job_id , 1 ) kf = job_id_to_ikf ( job_id , 2 ) init_id = job_id_to_ikf ( job_id , 3 ) call core_electron % bloch_wf_on_grid ( FFT_grid % n_grid , & wfc_i , core_id , target_mat % pc_vol , PW_dataset % red_to_xyz , & shift = . TRUE ., verbose = . FALSE .) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f ! load final wave function call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) ! compute rate call exdm_scatter_cc_calc ( binned_rate_init ( init_id ), & FFT_grid , core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_i , wfc_fkf , & core_id , cond_id , kf , verbose = . FALSE .) end do end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if if ( proc_id == root_process ) then call PW_dataset % save ( io_files % out_filename , verbose = verbose ) call core_electron % save ( io_files % out_filename , verbose = verbose ) call fft_grid % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_cc_calc ( FFT_grid , core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , numerics , n_jobs_per_proc , & init_id , cond_id , kf , verbose ) !! Clocks the core  \\rightarrow  conduction DM-electron scattering rate calculation !! by running a smaller version of the program. use timing use mpi implicit none type ( FFT_grid_t ) :: FFT_grid type ( core_electron_t ) :: core_electron type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr type ( numerics_scatter_cc_t ) :: numerics integer :: n_jobs_per_proc integer :: init_id , cond_id , k , kf logical , optional :: verbose type ( binned_scatter_rate_t ) :: b_rate complex ( dp ), allocatable :: wfc_i (:, :, :) complex ( dp ), allocatable :: wfc_fkf (:, :, :) if ( verbose ) then print * , 'Timing c -> c calculation...' print * end if call b_rate % init ( bins , dm_model , expt ) allocate ( wfc_i ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) time ( 3 ) = MPI_Wtime () call core_electron % bloch_wf_on_grid ( FFT_grid % n_grid , & wfc_i , init_id , target_mat % pc_vol , PW_dataset % red_to_xyz , & shift = . TRUE ., verbose = . FALSE .) time ( 4 ) = MPI_Wtime () call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) call exdm_scatter_cc_calc ( b_rate ,& FFT_grid , core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_i , wfc_fkf , & init_id , cond_id , kf , verbose = . FALSE .) time ( 5 ) = MPI_Wtime () if ( verbose ) then call print_section_seperator () print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Compute core WF :' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        (Total) Compute core WF :' print * , '            ' , trim ( pretty_time_format (& n_jobs_per_proc * ( time ( 4 ) - time ( 3 ))& )) print * print * , '        (TEST) Rate : ' print * , '            ' , trim ( pretty_time_format ( time ( 5 ) - time ( 4 ))) print * print * , '        (Total) Rate : ' print * , '            ' , trim ( pretty_time_format (& n_jobs_per_proc * numerics % n_cond_max * ( time ( 5 ) - time ( 4 ))& )) print * print * , '        Expected run time for whole calculation :' print * , '            ' , trim ( pretty_time_format (& n_jobs_per_proc * ( time ( 4 ) - time ( 3 )) & + n_jobs_per_proc * numerics % n_cond_max * ( time ( 5 ) - time ( 4 ))& )) print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_cc.f90.html"},{"title":"numerics_scatter_cc.f90 – EXCEED-DM","text":"Contents Modules numerics_scatter_cc Source Code numerics_scatter_cc.f90 Source Code module numerics_scatter_cc !! Numerics parameters specific to the core  \\rightarrow  conduction DM-electron scattering rate calculation. use info_messages use core_electron_type implicit none type numerics_scatter_cc_t !! Numerics parameters specific to the core  \\rightarrow  conduction DM-electron scattering rate calculation. integer :: n_principal_max = 10 !! Maximum principal quantum number to include. integer :: n_principal_min = 1 !! Minimum principal quantum number to include. integer :: n_cond_max = 0 !! Maximum number of conduction bands. integer :: n_FFT_grid ( 3 ) = [ 0 , 0 , 0 ] !! Dimension of the FFT grid to compute on. integer , allocatable :: core_id_list (:) !! Dim : [n_init] !! !! List of core ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_init] !! !! List of k points to compute for. contains procedure :: print => numerics_scatter_cc_print procedure :: load => numerics_scatter_cc_load_nml procedure :: save => numerics_scatter_cc_save procedure :: create_k_id_list => cc_create_k_id_list procedure :: create_core_id_list => cc_create_core_id_list end type contains subroutine cc_create_core_id_list ( self , core_electron ) !! Specify the indicies for each core state that should be included. !! Specific to the  core  \\rightarrow  conduction DM-electron scattering rate calculation. implicit none class ( numerics_scatter_cc_t ) :: self type ( core_electron_t ) :: core_electron integer :: n integer :: n_init , init_id init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 end if end do n_init = init_id allocate ( self % core_id_list ( n_init )) init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 self % core_id_list ( init_id ) = n end if end do end subroutine subroutine cc_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the core  \\rightarrow  conduction DM-electron scattering rate calculations. implicit none class ( numerics_scatter_cc_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine numerics_scatter_cc_save ( self , filename , verbose ) !! Saves `numerics_scatter_cc`. use hdf5 use h5lt implicit none class ( numerics_scatter_cc_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving numerics - scatter-cc parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_scatter_cc' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc/n_principal_max' , & size ( dims1 ), dims1 , & self % n_principal_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc/n_principal_min' , & size ( dims1 ), dims1 , & self % n_principal_min , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc/n_cond_max' , & size ( dims1 ), dims1 , & self % n_cond_max , & error ) dims1 = [ 3 ] call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc/n_FFT_grid_goal' , & size ( dims1 ), dims1 , & self % n_FFT_grid , & error ) dims1 = [ size ( self % core_id_list )] call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc/core_id_list' , & size ( dims1 ), dims1 , & self % core_id_list , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_cc_load_nml ( self , filename , n_cond , verbose ) !! Loads `numerics_scatter_cc` parameters from a namelist. implicit none class ( numerics_scatter_cc_t ) :: self character ( len =* ) :: filename integer :: n_cond logical , optional :: verbose logical :: file_exists integer :: error integer :: n_principal_max = 10 !! Maximum number of valence bands integer :: n_principal_min = 1 integer :: n_cond_max = 0 !! Maximum number of conduction bands integer :: n_FFT_grid ( 3 ) = [ 0 , 0 , 0 ] !! Dimension of the FFT grid to compute on. NAMELIST / numerics_s_cc / n_principal_max , & n_principal_min , & n_cond_max , & n_FFT_grid if ( verbose ) then print * , 'Loading numerics parameters for scatter-cc calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_s_cc , iostat = error ) close ( 100 ) self % n_principal_max = min ( n_principal_max , 10 ) self % n_principal_min = max ( n_principal_min , 1 ) if ( n_cond_max == 0 ) then self % n_cond_max = n_cond else self % n_cond_max = min ( n_cond , n_cond_max ) end if self % n_FFT_grid = n_FFT_grid call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-scatter-cc parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_cc_print ( self , verbose ) !! Prints `numerics_scatter_cc` components. implicit none class ( numerics_scatter_cc_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------------' print * , '    Numerics - Scatter - cc' print * , '    -----------------------' print * print * , '        Maximum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_max ))) print * , '        Minimum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_min ))) print * print * , '        Maximum number of conduction bands : ' , trim ( adjustl ( int_to_str ( self % n_cond_max ))) print * print * , '        Goal FFT grid size : ' , self % n_FFT_grid print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/numerics_scatter_cc.f90.html"},{"title":"calc_exdm_scatter_cc_ext.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_cc_ext Source Code calc_exdm_scatter_cc_ext.f90 Source Code module calc_exdm_scatter_cc_ext !! Compute  i, f, \\mathbf{k}_f  contributions to the core  \\rightarrow  conduction (extended) DM-electron scattering !! rate. use prec use constants use units use math_mod use binned_scatter_rate_type use bins_scatter_type use expt_type use material_type use dm_model_type use PW_dataset_type use core_electron_type use in_med_scr_type use numerics_scatter_cc_ext use physics_scatter_functions use transition_form_factor implicit none contains subroutine exdm_scatter_cc_ext_calc ( binned_rate , & core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & numerics , & wfc_FT_fkf , & init_id , cond_id , kf , verbose ) implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( core_electron_t ) :: core_electron type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr type ( numerics_scatter_cc_ext_t ) :: numerics integer :: init_id , cond_id , k , kf logical , optional :: verbose real ( dp ) :: dRdq ( numerics % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) complex ( dp ) :: wfc_FT_fkf (:) real ( dp ) :: f_sq real ( dp ) :: omega , omega_max real ( dp ) :: Ei , Ef integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max real ( dp ) :: q_theta , q_phi real ( dp ) :: kf_vec ( 3 ), G_vec ( 3 ) real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: scr integer :: q_bin , E_bin real ( dp ) :: f_sq_val real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) real ( dp ) :: q_list ( numerics % n_q ) complex ( dp ) :: form_fac complex ( dp ) :: wfc_i_FT real ( dp ) :: eq_pos ( 3 ) integer :: w , q , g , a real ( dp ) :: omega_kin_max ! initialize b_rate = 0.0_dp dRdq = 1.0e-100_dp Ei = core_electron % energy ( init_id ) Ef = PW_dataset % energy_bands ( kf , cond_id ) omega = Ef - Ei E_bin = Q_func ( omega , target_mat % band_gap , bins % E_width , bins % n_E ) kf_vec = PW_dataset % k_grid_xyz ( kf , :) eq_pos = matmul ( PW_dataset % red_to_xyz , 1.0_dp * core_electron % eq_pos_red ( core_electron % config ( init_id , 1 ), :)) if ( omega >= expt % E_threshold ) then do m = 1 , dm_model % n_mX omega_kin_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 q_min = max ( numerics % q_min , & dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max ))))) q_max = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) if ( q_max > q_min ) then q_list = 1 0.0_dp ** uniform_list ( numerics % n_q , log10 ( q_min ), log10 ( q_max )) do q = 1 , numerics % n_q q_mag = q_list ( q ) do a = 1 , size ( numerics % q_angular_mesh , 1 ) q_theta = numerics % q_angular_mesh ( a , 1 ) q_phi = numerics % q_angular_mesh ( a , 2 ) q_vec ( 1 ) = q_mag * sin ( q_theta ) * cos ( q_phi ) q_vec ( 2 ) = q_mag * sin ( q_theta ) * sin ( q_phi ) q_vec ( 3 ) = q_mag * cos ( q_theta ) form_fac = ( 0.0_dp , 0.0_dp ) do g = 1 , PW_dataset % n_G G_vec = PW_dataset % G_grid_xyz ( g , :) wfc_i_FT = core_electron % atomic_sto_wf_FT ( init_id , & G_vec + kf_vec - q_vec ) form_fac = form_fac + conjg ( wfc_FT_fkf ( g )) * & wfc_i_FT * & exp ( - ii * dot_product ( G_vec , eq_pos )) end do f_sq_val = conjg ( form_fac ) * form_fac scr = in_med_scr % screening ( q_vec , omega ) do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , & dm_model % med_FF ( f )) end do do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), & dm_model % vE * expt % vE_direction ( t , :), & omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) dRdq ( q , E_bin , m , :, t ) = & dRdq ( q , E_bin , m , :, t ) + & q_mag ** 2 * & scr ** ( - 2 ) * & F_med_sq (:) * & g_func_val * & f_sq_val end if end do end do end do end if ! overall constants dRdq (:, :, m , :, :) = ( 2 * pi ) * PW_dataset % k_weight ( kf ) * & ( dm_model % rhoX / target_mat % rho_T ) * ( 2 * target_mat % pc_vol ** 2 ) ** ( - 1 ) * & (( 4 * pi ) / ( numerics % n_q_theta * numerics % n_q_phi * 1.0_dp )) * & ( dm_model % mX ( m ) * red_mass ( m_elec , dm_model % mX ( m )) ** 2 ) ** ( - 1 ) * & ( 2 * pi ) ** ( - 3 ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & dRdq (:, :, m , :, :) ! interpolate/integrate to get b_rate do w = 1 , bins % n_E do t = 1 , expt % n_time do f = 1 , dm_model % n_med_FF call cc_ext_interpolate_dRdq_to_binned_rate ( q_list , & dRdq (:, w , m , f , t ), & b_rate (:, w , m , f , t ), & bins % q_width ) end do end do end do end do end if binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine subroutine cc_ext_interpolate_dRdq_to_binned_rate ( q_list , dRdq , b_rate , q_bin_width ) implicit none real ( dp ) :: q_list (:) real ( dp ) :: dRdq (:) real ( dp ) :: b_rate (:) real ( dp ) :: q_bin_width real ( dp ) :: q_bin_L , q_bin_R integer :: q real ( dp ) :: eps eps = 1.0e-3_dp ! go through all the bins (except last) if ( size ( b_rate ) > 1 ) then do q = 1 , size ( b_rate ) - 1 q_bin_L = ( q - 1 ) * q_bin_width + eps q_bin_R = q * q_bin_width b_rate ( q ) = integrate_log_interpolate ( q_list , dRdq , q_bin_L , q_bin_R ) end do end if ! last bin integrates over the rest of the list b_rate ( size ( b_rate )) = integrate_log_interpolate ( q_list , dRdq ,& ( size ( b_rate ) - 1 ) * q_bin_width , q_list ( size ( q_list ))) end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_cc_ext.f90.html"},{"title":"exdm_scatter_cc_ext.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_cc_ext Source Code exdm_scatter_cc_ext.f90 Source Code module exdm_scatter_cc_ext !! Compute the core  \\rightarrow  conduction DM-electron scattering rate by computing  \\frac{dR}{dq} . use mpi use prec use info_messages use io_input use control_input use binned_scatter_rate_type use dm_model_type use expt_type use material_type use PW_dataset_type use core_electron_type use in_med_scr_type use FFT_util use MPI_util use numerics_scatter_cc_ext use calc_exdm_scatter_cc_ext contains subroutine exdm_scatter_cc_ext_set_n_init ( io_files , n_init ) !! Sets the number of initial states to record the rate for. !! Specific to the core  \\rightarrow  conduction (extended) DM-electron !! scattering rate calculation. implicit none type ( io_files_t ) :: io_files integer :: n_init type ( PW_dataset_t ) :: PW_dataset type ( numerics_scatter_cc_ext_t ) :: numerics type ( core_electron_t ) :: core_electron call PW_dataset % load ( io_files % PW_data_filename , verbose = . FALSE .) call core_electron % load ( io_files % core_elec_config_filename , io_files % sto_data_filename , & verbose = . FALSE .) call numerics % load ( io_files % nml_input_filename , PW_dataset % n_cond , verbose = . FALSE .) call numerics % create_core_id_list ( core_electron ) n_init = size ( numerics % core_id_list ) end subroutine subroutine run_exdm_scatter_cc_ext ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose ) !! Compute the core  \\rightarrow  conduction DM-electron scattering rate by computing  \\frac{dR}{dq} . implicit none integer :: n_init integer :: n_proc integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init ( n_init ) type ( control_t ) :: main_control type ( io_files_t ) :: io_files type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose type ( PW_dataset_t ) :: PW_dataset type ( parallel_manager_t ) :: ikf_manager type ( numerics_scatter_cc_ext_t ) :: numerics type ( core_electron_t ) :: core_electron integer , allocatable :: job_id_to_ikf (:, :) integer :: init_id , core_id integer :: n_jobs_per_proc integer :: i , j , f integer :: job_id integer :: cond_id , kf complex ( dp ), allocatable :: wfc_FT_fkf (:) if ( verbose ) then print * , 'Starting c -> c (extended) scattering rate calculation...' print * end if call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call core_electron % load (& io_files % core_elec_config_filename , & io_files % STO_data_filename , verbose = verbose ) call numerics % load ( io_files % nml_input_filename ,& PW_dataset % n_cond , verbose = verbose ) ! create job table, parallelizing over {i, kf} call ikf_manager % init ( PW_dataset % n_k * n_init , verbose = verbose ) allocate ( job_id_to_ikf ( ikf_manager % n_jobs , 4 )) job_id_to_ikf = 0 call numerics % create_core_id_list ( core_electron ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ikf_manager % create_job_to_2d_ID_table (& numerics % core_id_list , & numerics % k_id_list , & job_id_to_ikf , verbose = verbose ) allocate ( wfc_FT_fkf ( PW_dataset % n_G )) if ( verbose ) then print * , 'Calculating transition rates...' print * end if do j = 1 , ikf_manager % n_jobs_per_proc job_id = ikf_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then core_id = job_id_to_ikf ( job_id , 1 ) kf = job_id_to_ikf ( job_id , 2 ) init_id = job_id_to_ikf ( job_id , 3 ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f ! load final wave function call PW_dataset % load_wfc_FT_ik_no_spin ( cond_id , kf , wfc_FT_fkf ) ! compute rate call exdm_scatter_cc_ext_calc ( binned_rate_init ( init_id ), & core_electron , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , numerics , & wfc_FT_fkf , & core_id , cond_id , kf , verbose = . FALSE .) end do end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if if ( proc_id == root_process ) then call PW_dataset % save ( io_files % out_filename , verbose = verbose ) call core_electron % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_cc_ext.f90.html"},{"title":"numerics_scatter_cc_ext.f90 – EXCEED-DM","text":"Contents Modules numerics_scatter_cc_ext Source Code numerics_scatter_cc_ext.f90 Source Code module numerics_scatter_cc_ext use info_messages use core_electron_type type numerics_scatter_cc_ext_t !! Numerics parameters specific to the core  \\rightarrow  conduction DM-electron scattering rate calculation. integer :: n_principal_max = 10 !! Maximum principal quantum number to include. integer :: n_principal_min = 1 !! Minimum principal quantum number to include. integer :: n_cond_max = 0 !! Maximum number of conduction bands. integer , allocatable :: core_id_list (:) !! Dim : [n_init] !! !! List of core ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_init] !! !! List of k points to compute for. integer :: n_q real ( dp ) :: q_min integer :: n_q_theta = 1 integer :: n_q_phi = 1 real ( dp ), allocatable :: q_angular_mesh (:, :) !! Dim : [ `n_q_theta` x `n_kf_phi`, 2 ] !! !! Grid of  \\theta, \\phi  points for the angular integration over  \\mathbf{q}  !! !! Units : None contains procedure :: print => numerics_scatter_cc_ext_print procedure :: load => numerics_scatter_cc_ext_load_nml procedure :: save => numerics_scatter_cc_ext_save procedure :: create_k_id_list => cc_ext_create_k_id_list procedure :: create_core_id_list => cc_ext_create_core_id_list end type contains subroutine cc_ext_create_core_id_list ( self , core_electron ) !! Specify the indicies for each core state that should be included. !! Specific to the  core  \\rightarrow  conduction (extended) DM-electron scattering rate calculation. implicit none class ( numerics_scatter_cc_ext_t ) :: self type ( core_electron_t ) :: core_electron integer :: n integer :: n_init , init_id init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 end if end do n_init = init_id allocate ( self % core_id_list ( n_init )) init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 self % core_id_list ( init_id ) = n end if end do end subroutine subroutine cc_ext_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the core  \\rightarrow  conduction DM-electron scattering rate calculations. implicit none class ( numerics_scatter_cc_ext_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine numerics_scatter_cc_ext_save ( self , filename , verbose ) !! Saves `numerics_scatter_cc_ext`. use hdf5 use h5lt implicit none class ( numerics_scatter_cc_ext_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving numerics - scatter-cc_ext parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_scatter_cc_ext' , group_id , error ) ! write data call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cc_ext/q_min' , & size ( dims1 ), dims1 , & self % q_min , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_principal_max' , & size ( dims1 ), dims1 , & self % n_principal_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_principal_min' , & size ( dims1 ), dims1 , & self % n_principal_min , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_cond_max' , & size ( dims1 ), dims1 , & self % n_cond_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_q' , & size ( dims1 ), dims1 , & self % n_q , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_q_theta' , & size ( dims1 ), dims1 , & self % n_q_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/n_q_phi' , & size ( dims1 ), dims1 , & self % n_q_phi , & error ) dims1 = [ size ( self % core_id_list )] call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cc_ext/core_id_list' , & size ( dims1 ), dims1 , & self % core_id_list , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_cc_ext_load_nml ( self , filename , n_cond , verbose ) !! Loads `numerics_scatter_cc` parameters from a namelist. implicit none class ( numerics_scatter_cc_ext_t ) :: self character ( len =* ) :: filename integer :: n_cond logical , optional :: verbose logical :: file_exists integer :: error integer :: n_principal_max = 10 !! Maximum number of valence bands integer :: n_principal_min = 1 integer :: n_cond_max = 0 !! Maximum number of conduction bands integer :: n_q , n_q_theta , n_q_phi real ( dp ) :: q_min NAMELIST / numerics_s_cc_ext / n_principal_max , & n_principal_min , & n_cond_max , & n_q , & n_q_theta , & n_q_phi , & q_min if ( verbose ) then print * , 'Loading numerics parameters for scatter-cc_ext calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_s_cc_ext , iostat = error ) close ( 100 ) self % n_principal_max = min ( n_principal_max , 10 ) self % n_principal_min = max ( n_principal_min , 1 ) if ( n_cond_max == 0 ) then self % n_cond_max = n_cond else self % n_cond_max = min ( n_cond , n_cond_max ) end if self % n_q = n_q self % n_q_theta = n_q_theta self % n_q_phi = n_q_phi self % q_min = q_min allocate ( self % q_angular_mesh ( self % n_q_theta * self % n_q_phi , 2 )) self % q_angular_mesh = generate_uniform_points_on_sphere ( self % n_q_theta , self % n_q_phi ) call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-scatter-cc_ext parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_cc_ext_print ( self , verbose ) !! Prints `numerics_scatter_cc` components. implicit none class ( numerics_scatter_cc_ext_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ---------------------------' print * , '    Numerics - Scatter - cc_ext' print * , '    ---------------------------' print * print * , '        Maximum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_max ))) print * , '        Minimum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_min ))) print * print * , '        Maximum number of conduction bands : ' , trim ( adjustl ( int_to_str ( self % n_cond_max ))) print * print * , '        n_q       = ' , trim ( adjustl ( int_to_str ( self % n_q ))) print * , '        n_q_theta = ' , trim ( adjustl ( int_to_str ( self % n_q_theta ))) print * , '        n_q_phi   = ' , trim ( adjustl ( int_to_str ( self % n_q_phi ))) print * print * , '        q_min = ' , self % q_min / 1.0e3_dp , 'keV' print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/numerics_scatter_cc_ext.f90.html"},{"title":"calc_exdm_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_cf Source Code calc_exdm_scatter_cf.f90 Source Code module calc_exdm_scatter_cf !! Compute  i  contributions to the core  \\rightarrow  free DM-electron scattering rate. use prec use constants use units use math_mod use binned_scatter_rate_type use bins_scatter_type use expt_type use material_type use dm_model_type use core_electron_type use in_med_scr_type use physics_scatter_functions use transition_form_factor use numerics_scatter_cf implicit none contains subroutine exdm_scatter_cf_calc ( binned_rate ,& core_electron , target_mat , bins , dm_model , expt , in_med_scr , & numerics , & init_id , w_id , verbose ) !! Compute  i  contributions to the core  \\rightarrow  free DM-electron scattering rate. implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( core_electron_t ) :: core_electron type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr type ( numerics_scatter_cf_t ) :: numerics integer :: init_id , w_id logical , optional :: verbose real ( dp ) :: dRdw ( bins % n_q , 2 , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) real ( dp ) :: Ei , omega , Ef real ( dp ) :: ki_max , ki_mag , jac_ki , ki_theta , ki_phi real ( dp ) :: ki_vec ( 3 ) real ( dp ) :: kf_mag , kf_theta , kf_phi real ( dp ) :: kf_vec ( 3 ) real ( dp ) :: omega_kin_max real ( dp ) :: q_min , q_max , q_mag real ( dp ) :: q_vec ( 3 ) integer :: q_bin real ( dp ) :: v_m , g_func_val real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: f_sq real ( dp ) :: scr real ( dp ) :: fermi_val , fermi_factor integer :: m , w , ki , a , b , t , f , q b_rate = 0.0_dp dRdw = 1.0e-100_dp Ei = core_electron % energy ( init_id ) ki_max = numerics % ki_s * numerics % Zeff ( init_id ) * alpha_EM * m_elec do m = 1 , dm_model % n_mX omega_kin_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 if ( omega_kin_max > numerics % omega_list ( w_id ) ) then do w = 1 , 2 omega = numerics % omega_list (& min ( w_id + ( w - 1 ), numerics % n_omega )) q_min = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) Ef = Ei + omega if ( ( Ef > 0.0_dp ) & . and . ( omega > expt % E_threshold ) & . and . ( Ef > numerics % Ef_min ) ) then kf_mag = sqrt ( 2.0_dp * m_elec * Ef ) fermi_val = 2.0_dp * pi * numerics % Zeff ( init_id ) * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do ki = 1 , numerics % n_ki ki_mag = ( ki_max / numerics % ki_min ) ** (( ki - 1.0_dp ) / ( numerics % n_ki - 1.0_dp ))& * numerics % ki_min jac_ki = ( 1.0_dp / numerics % n_ki ) * ki_mag ** 3 * log10 ( ki_max / numerics % ki_min ) do a = 1 , size ( numerics % ki_angular_mesh , 1 ) ki_theta = numerics % ki_angular_mesh ( a , 1 ) ki_phi = numerics % ki_angular_mesh ( a , 2 ) ki_vec ( 1 ) = ki_mag * sin ( ki_theta ) * cos ( ki_phi ) ki_vec ( 2 ) = ki_mag * sin ( ki_theta ) * sin ( ki_phi ) ki_vec ( 3 ) = ki_mag * cos ( ki_theta ) f_sq = abs ( core_electron % atomic_sto_wf_FT ( init_id , ki_vec )) ** 2 do b = 1 , size ( numerics % kf_angular_mesh , 1 ) kf_theta = numerics % kf_angular_mesh ( b , 1 ) kf_phi = numerics % kf_angular_mesh ( b , 2 ) kf_vec ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) kf_vec ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) kf_vec ( 3 ) = kf_mag * cos ( kf_theta ) q_vec = kf_vec - ki_vec q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , & dm_model % med_FF ( f )) end do q_bin = Q_func ( q_mag , 0.0_dp , & bins % q_width , bins % n_q ) scr = in_med_scr % screening ( q_vec , omega ) do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), & dm_model % vE * expt % vE_direction ( t , :), & omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) dRdw ( q_bin , w , m , :, t ) = dRdw ( q_bin , w , m , :, t ) + & fermi_factor * & F_med_sq * & g_func_val * & f_sq * & jac_ki * & m_elec * kf_mag * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do ! add overall constants dRdw (:, :, m , :, :) = ( core_electron % config ( init_id , 5 ) * pi ) * & ( dm_model % rhoX / target_mat % rho_T ) * & ( target_mat % pc_vol ) ** ( - 1 ) * red_mass ( dm_model % mX ( m ), m_elec ) ** ( - 2 ) * & dm_model % mX ( m ) ** ( - 1 ) * & ( 2 * pi ) ** ( - 6 ) * ( 4 * pi ) / ( 1.0_dp * numerics % n_ki_theta * numerics % n_ki_phi ) * & ( 4 * pi ) / ( 1.0_dp * numerics % n_kf_theta * numerics % n_kf_phi ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & dRdw (:, :, m , :, :) do q = 1 , bins % n_q do t = 1 , expt % n_time do f = 1 , dm_model % n_med_FF call cf_interpolate_dRdw_to_binned_rate ( w_id , & numerics % omega_list , dRdw ( q , :, m , f , t ), b_rate ( q , :, m , f , t ),& bins % E_width , target_mat % band_gap ) end do end do end do end if end do binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine subroutine cf_interpolate_dRdw_to_binned_rate ( w_id , omega_list , dRdw , b_rate , E_bin_width , band_gap ) !! Given  [\\omega_1, \\omega_2]  and  [ \\frac{dR}{d \\omega}(\\omega_1), \\frac{dR}{d\\omega}(\\omega_2)  ] , !! find the power law fit parameter,  \\beta , such that !!  \\frac{dR}{d \\omega}(\\omega_2) = \\frac{dR}{d \\omega}(\\omega_1) \\left( \\frac{\\omega_2}{\\omega_1} \\right)&#94;\\beta . !! Then integrate this function over each bin,  e ,  \\Delta R_e = \\int_{(e - 1)\\Delta E}&#94;{e \\Delta E} \\frac{dR}{d\\omega} !! d\\omega . Note that  \\frac{dR}{d\\omega}  is assumed to be zero for  \\omega \\notin [\\omega_1, \\omega_2] . !! !! Specific to core  \\rightarrow  free DM-electron scattering rate calculation. implicit none integer :: w_id real ( dp ) :: omega_list (:) real ( dp ) :: dRdw (:) real ( dp ) :: b_rate (:) real ( dp ) :: E_bin_width real ( dp ) :: omega_bounds ( 2 ) real ( dp ) :: dRdw_pair ( 2 ) real ( dp ) :: band_gap real ( dp ) :: fit_params integer :: e real ( dp ) :: E_bin_L , E_bin_R real ( dp ) :: E1 , E2 if ( w_id < size ( omega_list ) ) then if ( size ( b_rate ) > 1 ) then do e = 1 , size ( b_rate ) - 1 E_bin_L = band_gap + ( e - 1 ) * E_bin_width E_bin_R = band_gap + e * E_bin_width b_rate ( e ) = b_rate ( e ) + integrate_log_interpolate (& [ omega_list ( w_id ), omega_list ( w_id + 1 ) ],& dRdw , E_bin_L , E_bin_R ) end do end if ! last bin integrates over the rest of the list b_rate ( size ( b_rate )) = b_rate ( size ( b_rate )) + integrate_log_interpolate (& [ omega_list ( w_id ), omega_list ( w_id + 1 ) ], dRdw ,& band_gap + ( size ( b_rate ) - 1 ) * E_bin_width ,& omega_list ( size ( omega_list ))) end if end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_cf.f90.html"},{"title":"exdm_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_cf Source Code exdm_scatter_cf.f90 Source Code module exdm_scatter_cf !! Compute the core  \\rightarrow  free DM-electron scattering rate. use mpi use prec use info_messages use io_input use control_input use binned_scatter_rate_type use dm_model_type use expt_type use material_type use PW_dataset_type use core_electron_type use in_med_scr_type use FFT_util use MPI_util use numerics_scatter_cf use calc_exdm_scatter_cf implicit none contains subroutine exdm_scatter_cf_set_n_init ( io_files , n_init ) !! Sets the number of initial states to record the rate for. !! Specific to the core  \\rightarrow  free DM-electron !! scattering rate calculation. implicit none type ( io_files_t ) :: io_files integer :: n_init type ( numerics_scatter_cf_t ) :: numerics type ( core_electron_t ) :: core_electron call core_electron % load ( io_files % core_elec_config_filename , io_files % sto_data_filename , & verbose = . FALSE .) call numerics % load ( io_files % nml_input_filename , core_electron , & verbose = . FALSE .) call numerics % create_core_id_list ( core_electron ) n_init = size ( numerics % core_id_list ) end subroutine subroutine run_exdm_scatter_cf ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose ) !! Compute the core  \\rightarrow  free DM-electron scattering rate. implicit none integer :: n_init integer :: n_proc integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init ( n_init ) type ( control_t ) :: main_control type ( io_files_t ) :: io_files type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose type ( core_electron_t ) :: core_electron type ( parallel_manager_t ) :: iw_manager type ( numerics_scatter_cf_t ) :: numerics integer , allocatable :: job_id_to_iw (:, :) integer :: t , f , i , k , j integer :: job_id integer :: init_id , w_id , core_id real ( dp ) :: log_omega_min , log_omega_max if ( verbose ) then print * , 'Starting c -> f scattering rate calculation...' print * end if call core_electron % load (& io_files % core_elec_config_filename , & io_files % STO_data_filename , verbose = verbose ) call numerics % load ( io_files % nml_input_filename , core_electron , & verbose = verbose ) ! parallelize over {i, omega} variables call iw_manager % init ( n_init * numerics % n_omega , verbose = verbose ) allocate ( job_id_to_iw ( iw_manager % n_jobs , 4 )) job_id_to_iw = 0 call numerics % create_core_id_list ( core_electron ) call numerics % create_w_id_list () log_omega_min = log10 ( numerics % Ef_min ) log_omega_max = log10 ( 0.5_dp * dm_model % vX_max ** 2 * maxval ( dm_model % mX )) numerics % omega_list = 1 0.0_dp ** uniform_list ( numerics % n_omega , log_omega_min , log_omega_max ) call iw_manager % create_job_to_2d_ID_table (& numerics % core_id_list , & numerics % w_id_list , & job_id_to_iw , verbose = verbose ) if ( log_omega_max > log_omega_min ) then if ( verbose ) then print * , 'Calculating transition rates...' print * end if do j = 1 , iw_manager % n_jobs_per_proc job_id = iw_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then ! count states down from highest valence band core_id = job_id_to_iw ( job_id , 1 ) w_id = job_id_to_iw ( job_id , 2 ) init_id = job_id_to_iw ( job_id , 3 ) ! compute rate call exdm_scatter_cf_calc ( binned_rate_init ( init_id ), & core_electron , target_mat , & bins , dm_model , expt , in_med_scr , numerics , & core_id , w_id , verbose = . FALSE .) end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if else call print_warning_message (& 'No mass in mX is large enough to warrant the c -> f calculation ' // & 'with the specified omega_min. Skipping c -> f calculation.' , & verbose = verbose ) end if if ( proc_id == root_process ) then call core_electron % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) end if end subroutine ! subroutine time_exdm_scatter_cf_calc(log_omega_table, & !         ki_angular_mesh, kf_angular_mesh, verbose) !     !! Times the v -> f scattering rate calculation !     use timing !     use mpi !     implicit none !     real(dp) :: log_omega_table(n_fin, 2) !     real(dp) :: log_omegas(2) !     real(dp) :: ki_angular_mesh(:, :) !     real(dp) :: kf_angular_mesh(:, :) !     integer :: tran_id !     logical, optional :: verbose !     real(dp) :: b_rate(n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time) !     integer :: init_id, fin_id !     if ( verbose ) then !         print*, 'Timing c -> f calculation...' !         print* !     end if !     ! one of the jobs which takes longer !     tran_id = job_table(12, n_tran_per_proc) !     init_id = tran_to_init_fin_id(tran_id, 1) !     fin_id = tran_to_init_fin_id(tran_id, 2) !     log_omegas = log_omega_table(fin_id, :) !     time(3) = MPI_Wtime() !     call exdm_scatter_cf_calc(b_rate,& !         init_id, log_omegas, n_ki, ki_angular_mesh, kf_angular_mesh, verbose = verbose) !     time(4) = MPI_Wtime() !     if ( verbose ) then !         print*, '----------------------------------------' !         print*, '    -------------' !         print*, '    Timing (TEST)' !         print*, '    -------------' !         print* !         print*, '        (TEST) Run time : ' !         print*, '            ', trim(pretty_time_format(time(4) - time(3))) !         print* !         print*, '        Expected run time for whole calculation :' !         print*, '            ', trim(pretty_time_format(& !             n_tran_per_proc*(time(4) - time(3))& !             )) !         print* !         print*, '----------------------------------------' !         print* !     end if ! end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_cf.f90.html"},{"title":"numerics_scatter_cf.f90 – EXCEED-DM","text":"Contents Modules numerics_scatter_cf Source Code numerics_scatter_cf.f90 Source Code module numerics_scatter_cf !! Numerics parameters specific to the core  \\rightarrow  free DM-electron scattering rate calculation. use prec use info_messages use core_electron_type implicit none type numerics_scatter_cf_t !! Numerics parameters specific to the core  \\rightarrow  free DM-electron scattering rate calculation. integer :: n_principal_max = 10 !! Maximum principal quantum number to include. integer :: n_principal_min = 1 !! Minimum principal quantum number to include. character ( len = 64 ) :: Zeff_type = 'one' !! Specify what Zeff to use !! !! - 'one' - all Zeff = 1 !! !! - 'Eb' - use the binding energy of the core states real ( dp ), allocatable :: Zeff (:) !! Dim : [ n_state ] !! !!  Z_\\text{eff}  parameter in the Fermi form factor. integer :: n_kf_theta = 1 !! Number of  \\theta  points in the integration of  \\mathbf{k}_f  integer :: n_kf_phi = 1 !! Number of  \\phi  points in the integration of  \\mathbf{k}_f  real ( dp ), allocatable :: kf_angular_mesh (:, :) !! Dim : [ n_kf_theta*n_kf_phi, 2 ] !! !! Grid of  \\theta, \\phi  points for the integration over  \\mathbf{k}_f  !! !! Units : None integer :: n_omega !! Number of  \\omega  points to compute for. The core -> free scattering !! rate calculation is done by computing `n_omega` values of  \\frac{dR}{d \\omega}  between !! !!  \\omega_\\text{min} = E_{f, \\text{max}}  !!  \\omega_\\text{max} = \\frac{1}{2} m_\\chi v_\\text{max}&#94;2  !! !! and then interpolated to the user defined grid. real ( dp ), allocatable :: omega_list (:) !! List of  \\omega  points to compute for. The core -> free scattering !! rate calculation is done by computing `n_omega` values of  \\frac{dR}{d \\omega}  between !! !!  \\omega_\\text{min} = E_{f, \\text{max}}  !!  \\omega_\\text{max} = \\frac{1}{2} m_\\chi v_\\text{max}&#94;2  !! !! and then interpolated to the user defined grid. integer :: n_ki = 2 !! Number of  | \\mathbf{k}_i |  points in integration over  \\mathbf{k}_i  integer :: n_ki_theta = 1 !! Number of  \\theta  points in integration over  \\mathbf{k}_i  integer :: n_ki_phi = 1 !! Number of  \\phi  points in integration over  \\mathbf{k}_i  real ( dp ), allocatable :: ki_angular_mesh (:, :) !! Dim : [ n_ki_theta*n_ki_phi, 2 ] !! !! Grid of  \\theta, \\phi  points for the integration over  \\mathbf{k}_i  !! !! Units : None real ( dp ) :: ki_s = 10 0.0_dp !! Scale parameter for maximum  |k_i|  to integrate over. !! !! `ki_max` = `ki_s`  \\times  Z \\alpha m_e  !! !! Generally, this parameters should be  \\gg 1  since  Z \\alpha m_e  is the !! typical momentum scale of the electronic wave functions. !! !! Units : None real ( dp ) :: ki_min = 1.0e3_dp !! Minimum  | \\mathbf{k}_i |  in the integration over  \\mathbf{k}_i  !! !! Units : eV integer , allocatable :: core_id_list (:) !! Dim : [n_init] !! !! List of core ID's to compute for. integer , allocatable :: w_id_list (:) !! Dim : [n_omega] !! !! List of omega ID's to compute for. real ( dp ) :: Ef_min !! Smallest final electron energy to compute for. contains procedure :: print => numerics_scatter_cf_print procedure :: load => numerics_scatter_cf_load_nml procedure :: save => numerics_scatter_cf_save procedure :: create_core_id_list => cf_create_core_id_list procedure :: create_w_id_list => cf_create_w_id_list end type contains subroutine numerics_scatter_cf_save ( self , filename , verbose ) !! Save `numerics_scatter_cf`. use hdf5 use h5lt implicit none class ( numerics_scatter_cf_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving numerics - scatter-cf parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_scatter_cf' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_principal_max' , & size ( dims1 ), dims1 , & self % n_principal_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_principal_min' , & size ( dims1 ), dims1 , & self % n_principal_min , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_kf_theta' , & size ( dims1 ), dims1 , & self % n_kf_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_kf_phi' , & size ( dims1 ), dims1 , & self % n_kf_phi , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_ki_theta' , & size ( dims1 ), dims1 , & self % n_ki_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_ki_phi' , & size ( dims1 ), dims1 , & self % n_ki_phi , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/n_ki' , & size ( dims1 ), dims1 , & self % n_ki , & error ) call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cf/ki_s' , & size ( dims1 ), dims1 , & self % ki_s , & error ) call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cf/ki_min' , & size ( dims1 ), dims1 , & self % ki_min , & error ) call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cf/Ef_min' , & size ( dims1 ), dims1 , & self % Ef_min , & error ) dims1 = [ size ( self % core_id_list )] call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_cf/core_id_list' , & size ( dims1 ), dims1 , & self % core_id_list , & error ) dims1 = [ size ( self % Zeff )] call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cf/Zeff' , & size ( dims1 ), dims1 , & self % Zeff , & error ) dims1 = [ size ( self % omega_list )] call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_cf/omega_list' , & size ( dims1 ), dims1 , & self % omega_list , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_cf_print ( self , verbose ) !! Prints `numerics_scatter_cf` components. implicit none class ( numerics_scatter_cf_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------------' print * , '    Numerics - Scatter - cf' print * , '    -----------------------' print * print * , '        Maximum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_max ))) print * , '        Minimum principal quantum number   : ' , trim ( adjustl ( int_to_str ( self % n_principal_min ))) print * print * , '        ki Integration' print * , '            Number of ki theta points : ' , trim ( adjustl ( int_to_str ( self % n_ki_theta ))) print * , '            Number of ki phi points   : ' , trim ( adjustl ( int_to_str ( self % n_ki_phi ))) print * , '            Number of |ki| points     : ' , trim ( adjustl ( int_to_str ( self % n_ki ))) print * , '            ki scale parameter,       : ' , self % ki_s print * , '            Minimum |ki|              : ' , self % ki_min , 'eV' print * print * , '        kf Integration' print * , '            Number of kf theta points : ' , trim ( adjustl ( int_to_str ( self % n_kf_theta ))) print * , '            Number of kf phi points   : ' , trim ( adjustl ( int_to_str ( self % n_kf_phi ))) print * print * , '        Number of omega points : ' , trim ( adjustl ( int_to_str ( self % n_omega ))) print * , '        Minimum Ef             : ' , self % Ef_min , 'eV' print * print * , '        Zeff type : ' , trim ( self % Zeff_type ) print * call print_section_seperator () print * end if end subroutine subroutine numerics_scatter_cf_load_nml ( self , filename , & core_electron , verbose ) !! Loads `numerics_scatter_cf` parameters from a namelist. implicit none class ( numerics_scatter_cf_t ) :: self character ( len =* ) :: filename type ( core_electron_t ) :: core_electron logical , optional :: verbose logical :: file_exists integer :: error integer :: n_principal_max = 10 !! Maximum number of valence bands integer :: n_principal_min = 1 character ( len = 64 ) :: Zeff_type = 'one' !! Specify what Zeff to use !! !! - 'one' - all Zeff = 1 !! - 'Eb' - use the binding energy of the core states integer :: n_kf_theta = 1 !! Number of  \\theta  points in the integration of  \\mathbf{k}_f  integer :: n_kf_phi = 1 !! Number of  \\phi  points in the integration of  \\mathbf{k}_f  integer :: n_omega !! Number of  \\omega  points to compute for. The core -> free scattering !! rate calculation is done by computing `n_omega` values of  \\frac{dR}{d \\omega}  between !! !!  \\omega_\\text{min} = E_{f, \\text{max}}  !!  \\omega_\\text{max} = \\frac{1}{2} m_\\chi v_\\text{max}&#94;2  !! !! and then interpolated to the user defined grid. integer :: n_ki = 2 !! Number of  | \\mathbf{k}_i |  points in integration over  \\mathbf{k}_i  integer :: n_ki_theta = 1 !! Number of  \\theta  points in integration over  \\mathbf{k}_i  integer :: n_ki_phi = 1 !! Number of  \\phi  points in integration over  \\mathbf{k}_i  real ( dp ) :: ki_s = 10 0.0_dp !! Scale parameter for maximum  |k_i|  to integrate over. !! !! `ki_max` = `ki_s`  \\times  Z \\alpha m_e  !! !! Generally, this parameters should be  \\gg 1  since  Z \\alpha m_e  is the !! typical momentum scale of the electronic wave functions. !! !! Units : None real ( dp ) :: ki_min = 1.0e3_dp !! Minimum  | \\mathbf{k}_i |  in the integration over  \\mathbf{k}_i  !! !! Units : eV real ( dp ) :: Ef_min = 6 0.0_dp integer :: i NAMELIST / numerics_s_cf / n_principal_max , & n_principal_min , & Zeff_type , & n_kf_theta , & n_kf_phi , & n_omega , & n_ki , & n_ki_theta , & n_ki_phi , & ki_s , & ki_min , & Ef_min if ( verbose ) then print * , 'Loading numerics parameters for scatter-cf calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_s_cf , iostat = error ) close ( 100 ) self % n_principal_max = min ( n_principal_max , 10 ) self % n_principal_min = max ( n_principal_min , 1 ) self % Zeff_type = trim ( Zeff_type ) self % n_kf_theta = n_kf_theta self % n_kf_phi = n_kf_phi self % n_omega = n_omega self % n_ki = n_ki self % n_ki_theta = n_ki_theta self % n_ki_phi = n_ki_phi self % ki_s = ki_s self % ki_min = ki_min self % Ef_min = Ef_min allocate ( self % omega_list ( self % n_omega )) self % omega_list = 0.0_dp allocate ( self % Zeff ( core_electron % n_state )) self % Zeff = 1.0_dp allocate ( self % kf_angular_mesh ( self % n_kf_theta * self % n_kf_phi , 2 )) allocate ( self % ki_angular_mesh ( self % n_ki_theta * self % n_ki_phi , 2 )) self % kf_angular_mesh = generate_uniform_points_on_sphere (& self % n_kf_theta , self % n_kf_phi ) self % ki_angular_mesh = generate_uniform_points_on_sphere (& self % n_ki_theta , self % n_ki_phi ) if ( trim ( self % Zeff_type ) == 'Eb' ) then do i = 1 , core_electron % n_state self % Zeff ( i ) = core_electron % config ( i , 2 ) * sqrt (& ( maxval ( core_electron % energy ) & - core_electron % energy ( i ) )& / 1 3.6_dp ) self % Zeff ( i ) = max ( self % Zeff ( i ), 1.0_dp ) end do end if call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-scatter-cf parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine cf_create_w_id_list ( self ) !! Specify the indicies for each  \\omega  point that should be included. !! Specific to the core  \\rightarrow  free DM-electron scattering rate calculation. implicit none class ( numerics_scatter_cf_t ) :: self integer :: i allocate ( self % w_id_list ( self % n_omega )) do i = 1 , self % n_omega self % w_id_list ( i ) = i end do end subroutine subroutine cf_create_core_id_list ( self , core_electron ) !! Create the list of core id's to compute for. implicit none class ( numerics_scatter_cf_t ) :: self type ( core_electron_t ) :: core_electron integer :: n integer :: n_init , init_id init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 end if end do n_init = init_id allocate ( self % core_id_list ( n_init )) init_id = 0 do n = 1 , core_electron % n_state if ( ( core_electron % config ( n , 2 ) >= self % n_principal_min ) & . and . ( core_electron % config ( n , 2 ) <= self % n_principal_max ) ) then init_id = init_id + 1 self % core_id_list ( init_id ) = n end if end do end subroutine end module","tags":"","loc":"sourcefile/numerics_scatter_cf.f90.html"},{"title":"calc_exdm_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_vc Source Code calc_exdm_scatter_vc.f90 Source Code module calc_exdm_scatter_vc !! Compute i, f, \\mathbf{k}_i, \\mathbf{k}_f  contributions to the valence  \\rightarrow  conduction DM-electron scattering rate. use prec use constants use units use math_mod use binned_scatter_rate_type use bins_scatter_type use expt_type use material_type use dm_model_type use PW_dataset_type use in_med_scr_type use physics_scatter_functions use transition_form_factor use FFT_util implicit none interface exdm_scatter_vc_calc module procedure exdm_scatter_vc_calc_no_spin module procedure exdm_scatter_vc_calc_spin end interface contains subroutine exdm_scatter_vc_calc_spin ( binned_rate ,& FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , verbose ) !! Compute i, f, \\mathbf{k}_i, \\mathbf{k}_f  contributions to the valence  \\rightarrow  conduction !! DM-electron scattering rate from spin dependent wave functions. implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr integer :: val_id , cond_id , k , kf logical , optional :: verbose complex ( dp ) :: wfc_ik (:, :, :, :) complex ( dp ) :: wfc_fkf (:, :, :, :) real ( dp ) :: f_sq ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) real ( dp ) :: omega , omega_max integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: scr integer :: q_bin , E_bin real ( dp ) :: f_sq_val real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) b_rate = 0.0_dp f_sq = ( 0.0_dp , 0.0_dp ) omega = PW_dataset % energy_bands ( kf , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( ( PW_dataset % energy_bands ( kf , cond_id ) <= PW_dataset % Ef_max ) & . and . ( omega >= expt % E_threshold ) ) then E_bin = Q_func ( omega , & target_mat % band_gap , & bins % E_width , & bins % n_E ) call calc_tff_pw_pw ( dm_model % tff_id , f_sq , wfc_ik , wfc_fkf , & FFT_grid % n_grid , FFT_grid % plan , verbose = . FALSE .) ! particle physics do m = 1 , dm_model % n_mX omega_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 if ( omega < omega_max ) then q_min = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& FFT_grid % q_max , & dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) q_vec = PW_dataset % k_grid_xyz ( kf , :) & - PW_dataset % k_grid_xyz ( k , :) & + FFT_grid % sym_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = in_med_scr % screening ( q_vec , omega ) q_bin = Q_func ( q_mag , 0.0_dp , & bins % q_width , & bins % n_q ) do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , & dm_model % med_FF ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), & dm_model % vE * expt % vE_direction ( t , :), & omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) b_rate ( q_bin , E_bin , m , :, t ) = & b_rate ( q_bin , E_bin , m , :, t ) + & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if ! multiply overall constants do m = 1 , dm_model % n_mX b_rate (:, :, m , :, :) = ( PW_dataset % spin_degen / 2.0_dp ) * & ( 2 * pi ) * ( dm_model % rhoX / target_mat % rho_T ) * ( 2 * target_mat % pc_vol ) ** ( - 2 ) * & PW_dataset % k_weight ( k ) * PW_dataset % k_weight ( kf ) * & red_mass ( dm_model % mX ( m ), m_elec ) ** ( - 2 ) * ( dm_model % mX ( m )) ** ( - 1 ) * & ( 1.0_dp * FFT_grid % n ) ** ( - 2 ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & b_rate (:, :, m , :, :) end do ! add new contribution binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine subroutine exdm_scatter_vc_calc_no_spin ( binned_rate ,& FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , verbose ) !! Compute i, f, \\mathbf{k}_i, \\mathbf{k}_f  contributions to the valence  \\rightarrow  conduction !! DM-electron scattering rate from spin independent wave functions. implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr integer :: val_id , cond_id , k , kf logical , optional :: verbose complex ( dp ) :: wfc_ik (:, :, :) complex ( dp ) :: wfc_fkf (:, :, :) real ( dp ) :: f_sq ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) real ( dp ) :: omega , omega_max integer :: m , f , t integer :: g1 , g2 , g3 real ( dp ) :: v_m , g_func_val real ( dp ) :: q_vec ( 3 ), q_mag , q_min , q_max real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: scr integer :: q_bin , E_bin real ( dp ) :: f_sq_val real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) b_rate = 0.0_dp f_sq = ( 0.0_dp , 0.0_dp ) omega = PW_dataset % energy_bands ( kf , cond_id ) - PW_dataset % energy_bands ( k , val_id ) if ( ( PW_dataset % energy_bands ( kf , cond_id ) <= PW_dataset % Ef_max ) & . and . ( omega >= expt % E_threshold ) ) then E_bin = Q_func ( omega , & target_mat % band_gap , & bins % E_width , & bins % n_E ) call calc_tff_pw_pw ( dm_model % tff_id , f_sq , wfc_ik , wfc_fkf , & FFT_grid % n_grid , FFT_grid % plan , verbose = . FALSE .) ! particle physics do m = 1 , dm_model % n_mX omega_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 if ( omega < omega_max ) then q_min = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( 1.0_dp - ( omega / omega_max ))) q_max = min (& FFT_grid % q_max , & dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( 1.0_dp - ( omega / omega_max ))) & ) do g3 = 1 , FFT_grid % n_grid ( 3 ) do g2 = 1 , FFT_grid % n_grid ( 2 ) do g1 = 1 , FFT_grid % n_grid ( 1 ) q_vec = PW_dataset % k_grid_xyz ( kf , :) & - PW_dataset % k_grid_xyz ( k , :) & + FFT_grid % sym_G_grid_xyz ( g1 , g2 , g3 , :) q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = in_med_scr % screening ( q_vec , omega ) q_bin = Q_func ( q_mag , 0.0_dp , & bins % q_width , & bins % n_q ) do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , & dm_model % med_FF ( f )) end do f_sq_val = f_sq ( g1 , g2 , g3 ) do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), & dm_model % vE * expt % vE_direction ( t , :), & omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) b_rate ( q_bin , E_bin , m , :, t ) = & b_rate ( q_bin , E_bin , m , :, t ) + & F_med_sq (:) * & g_func_val * & f_sq_val * & scr ** ( - 2 ) end if end do end if end do end do end do end if end do end if ! multiply overall constants do m = 1 , dm_model % n_mX b_rate (:, :, m , :, :) = ( PW_dataset % spin_degen / 2.0_dp ) * & ( 2 * pi ) * ( dm_model % rhoX / target_mat % rho_T ) * ( 2 * target_mat % pc_vol ) ** ( - 2 ) * & PW_dataset % k_weight ( k ) * PW_dataset % k_weight ( kf ) * & red_mass ( dm_model % mX ( m ), m_elec ) ** ( - 2 ) * ( dm_model % mX ( m )) ** ( - 1 ) * & ( 1.0_dp * FFT_grid % n ) ** ( - 2 ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & b_rate (:, :, m , :, :) end do ! add new contributions binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_vc.f90.html"},{"title":"exdm_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_vc Source Code exdm_scatter_vc.f90 Source Code module exdm_scatter_vc !! Compute the valence  \\rightarrow  conduction DM-electron scattering rate. use mpi use prec use io_input use control_input use binned_scatter_rate_type use dm_model_type use expt_type use material_type use PW_dataset_type use in_med_scr_type use FFT_util use MPI_util use numerics_scatter_vc use calc_exdm_scatter_vc implicit none contains subroutine exdm_scatter_vc_set_n_init ( io_files , n_init ) !! Sets the number of initial states to record the rate for. !! Specific to the valence  \\rightarrow  conduction DM-electron !! scattering rate calculation. implicit none type ( io_files_t ) :: io_files integer :: n_init type ( numerics_scatter_vc_t ) :: numerics type ( PW_dataset_t ) :: PW_dataset call PW_dataset % load ( io_files % PW_data_filename , verbose = . FALSE .) call numerics % load ( io_files % nml_input_filename , & PW_dataset % n_val , PW_dataset % n_cond , verbose = . FALSE .) call numerics % create_val_id_list ( PW_dataset % n_val ) n_init = size ( numerics % val_id_list ) end subroutine subroutine run_exdm_scatter_vc ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose ) !! Compute the valence  \\rightarrow  conduction DM-electron scattering rate. implicit none integer :: n_init integer :: n_proc integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init ( n_init ) type ( control_t ) :: main_control type ( io_files_t ) :: io_files type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose type ( PW_dataset_t ) :: PW_dataset type ( FFT_grid_t ) :: fft_grid type ( parallel_manager_t ) :: ik_manager type ( numerics_scatter_vc_t ) :: numerics integer , allocatable :: job_id_to_ik (:, :) integer :: i , j , f integer :: job_id integer :: val_id , cond_id , init_id integer :: k , kf integer :: n_FFT_grid ( 3 ) complex ( dp ), allocatable :: wfc_ik (:, :, :) complex ( dp ), allocatable :: wfc_iks (:, :, :, :) complex ( dp ), allocatable :: wfc_fkf (:, :, :) complex ( dp ), allocatable :: wfc_fkfs (:, :, :, :) if ( verbose ) then print * , 'Starting v -> c scattering rate calculation...' print * end if call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call numerics % load ( io_files % nml_input_filename , & PW_dataset % n_val , PW_dataset % n_cond , verbose = verbose ) ! doubled to avoid wrapping problems do i = 1 , 3 n_FFT_grid ( i ) = 2 * (& maxval ( PW_dataset % G_grid_red (:, i )) - minval ( PW_dataset % G_grid_red (:, i ))& ) + 1 end do call FFT_grid % init ( n_FFT_grid , PW_dataset % k_red_to_xyz , 'b' , verbose = verbose ) call FFT_grid % print ( verbose = verbose ) ! create job table, parallelizing over {i, k} call ik_manager % init ( PW_dataset % n_k * numerics % n_val_max , verbose = verbose ) allocate ( job_id_to_ik ( ik_manager % n_jobs , 4 )) job_id_to_ik = 0 call numerics % create_val_id_list ( PW_dataset % n_val ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ik_manager % create_job_to_2d_ID_table (& numerics % val_id_list , & numerics % k_id_list , & job_id_to_ik , verbose = verbose ) ! time calculation if ( ( proc_id == root_process ) . and . ( main_control % timer ) ) then call time_exdm_scatter_vc_calc ( FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & numerics , ik_manager % n_jobs_per_proc , & PW_dataset % n_val , PW_dataset % n_val + 1 , 1 , 1 , verbose = verbose ) end if ! allocate wave functions if ( PW_dataset % include_spin ) then allocate ( wfc_iks ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkfs ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) else allocate ( wfc_ik ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) end if ! do calculation if ( verbose ) then print * , 'Calculating transition rates...' print * end if do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then ! count states down from highest valence band val_id = job_id_to_ik ( job_id , 1 ) init_id = job_id_to_ik ( job_id , 3 ) k = job_id_to_ik ( job_id , 2 ) if ( PW_dataset % include_spin ) then ! load initial wave function call PW_dataset % load_wfc_ik_expanded_spin ( val_id , k , FFT_grid , wfc_iks ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f do kf = 1 , PW_dataset % n_k ! load final wave function call PW_dataset % load_wfc_ik_expanded_spin ( cond_id , kf , FFT_grid , wfc_fkfs ) ! compute rate call exdm_scatter_vc_calc ( binned_rate_init ( init_id ), & FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_iks , wfc_fkfs , & val_id , cond_id , k , kf , verbose = . FALSE .) end do end do else ! load initial wave function call PW_dataset % load_wfc_ik_expanded_no_spin ( val_id , k , FFT_grid , wfc_ik ) do f = 1 , numerics % n_cond_max cond_id = PW_dataset % n_val + f do kf = 1 , PW_dataset % n_k ! load final wave function call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) ! compute rate call exdm_scatter_vc_calc ( binned_rate_init ( init_id ), & FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , verbose = . FALSE .) end do end do end if end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if if ( proc_id == root_process ) then call PW_dataset % save ( io_files % out_filename , verbose = verbose ) call fft_grid % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) end if end subroutine subroutine time_exdm_scatter_vc_calc ( FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & numerics , n_jobs_per_proc , val_id , cond_id , k , kf , verbose ) !! Clocks the valence  \\rightarrow  conduction DM-electron scattering rate calculation !! by running a smaller version of the program. use timing use mpi implicit none type ( FFT_grid_t ) :: FFT_grid type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr type ( numerics_scatter_vc_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id , cond_id , k , kf logical , optional :: verbose complex ( dp ), allocatable :: wfc_ik (:, :, :) complex ( dp ), allocatable :: wfc_iks (:, :, :, :) complex ( dp ), allocatable :: wfc_fkf (:, :, :) complex ( dp ), allocatable :: wfc_fkfs (:, :, :, :) type ( binned_scatter_rate_t ) :: b_rate if ( verbose ) then print * , 'Timing v -> c calculation...' print * end if if ( PW_dataset % include_spin ) then allocate ( wfc_iks ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkfs ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) call PW_dataset % load_wfc_ik_expanded_spin ( val_id , k , FFT_grid , wfc_iks ) else allocate ( wfc_ik ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) allocate ( wfc_fkf ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 ))) call PW_dataset % load_wfc_ik_expanded_no_spin ( val_id , k , FFT_grid , wfc_ik ) end if call b_rate % init ( bins , dm_model , expt ) time ( 3 ) = MPI_Wtime () if ( PW_dataset % include_spin ) then call PW_dataset % load_wfc_ik_expanded_spin ( cond_id , kf , FFT_grid , wfc_fkfs ) call exdm_scatter_vc_calc ( b_rate , & FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_iks , wfc_fkfs , & val_id , cond_id , k , kf , verbose = . FALSE .) else call PW_dataset % load_wfc_ik_expanded_no_spin ( cond_id , kf , FFT_grid , wfc_fkf ) call exdm_scatter_vc_calc ( b_rate , & FFT_grid , PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & wfc_ik , wfc_fkf , & val_id , cond_id , k , kf , verbose = . FALSE .) end if time ( 4 ) = MPI_Wtime () if ( verbose ) then call print_section_seperator () print * , '    -------------' print * , '    Timing (TEST)' print * , '    -------------' print * print * , '        (TEST) Run time: ' print * , '            ' , trim ( pretty_time_format ( time ( 4 ) - time ( 3 ))) print * print * , '        Expected run time for whole calculation : ' print * , '            ' , trim ( pretty_time_format (& n_jobs_per_proc * PW_dataset % n_k * numerics % n_cond_max * ( time ( 4 ) - time ( 3 ))& )) print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_vc.f90.html"},{"title":"numerics_scatter_vc.f90 – EXCEED-DM","text":"Contents Modules numerics_scatter_vc Source Code numerics_scatter_vc.f90 Source Code module numerics_scatter_vc !! Numerics parameters specific to the valence  \\rightarrow  conduction DM-electron scattering rate calculation. use info_messages implicit none type numerics_scatter_vc_t !! Numerics parameters specific to the valence  \\rightarrow  conduction DM-electron scattering rate calculation. integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands integer , allocatable :: val_id_list (:) !! Dim : [n_val_max] !! !! List of valence ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_k] !! !! List of k's to compute for. contains procedure :: print => numerics_scatter_vc_print procedure :: load => numerics_scatter_vc_load_nml procedure :: save => numerics_scatter_vc_save procedure :: create_val_id_list => vc_create_val_id_list procedure :: create_k_id_list => vc_create_k_id_list end type contains subroutine vc_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the valence  \\rightarrow  conduction DM-electron rate calculations. implicit none class ( numerics_scatter_vc_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine vc_create_val_id_list ( self , n_val ) !! Specify the indicies for each valence band that should be included. !! Specific to the valence  \\rightarrow  conduction DM-electron scattering rate calculation. implicit none class ( numerics_scatter_vc_t ) :: self integer :: n_val integer :: j allocate ( self % val_id_list ( self % n_val_max )) do j = 1 , self % n_val_max self % val_id_list ( j ) = n_val - j + 1 end do end subroutine subroutine numerics_scatter_vc_save ( self , filename , verbose ) !! Saves `numerics_scatter_vc`. use hdf5 use h5lt implicit none class ( numerics_scatter_vc_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving numerics - scatter-vc parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_scatter_vc' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vc/n_val_max' , & size ( dims1 ), dims1 , & self % n_val_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vc/n_cond_max' , & size ( dims1 ), dims1 , & self % n_cond_max , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_vc_load_nml ( self , filename , n_val , n_cond , verbose ) !! Loads `numerics_scatter_vc` parameters from a namelist. implicit none class ( numerics_scatter_vc_t ) :: self character ( len =* ) :: filename integer :: n_val , n_cond logical , optional :: verbose logical :: file_exists integer :: error integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_cond_max = 0 !! Maximum number of conduction bands NAMELIST / numerics_s_vc / n_val_max , & n_cond_max if ( verbose ) then print * , 'Loading numerics parameters for scatter-vc calculation...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_s_vc , iostat = error ) close ( 100 ) if ( n_val_max == 0 ) then self % n_val_max = n_val else self % n_val_max = min ( n_val , n_val_max ) end if if ( n_cond_max == 0 ) then self % n_cond_max = n_cond else self % n_cond_max = min ( n_cond , n_cond_max ) end if call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-scatter-vc parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_vc_print ( self , verbose ) !! Prints `numerics_scatter_vc` components. implicit none class ( numerics_scatter_vc_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------------' print * , '    Numerics - Scatter - vc' print * , '    -----------------------' print * print * , '        Maximum number of valence bands    : ' , trim ( adjustl ( int_to_str ( self % n_val_max ))) print * , '        Maximum number of conduction bands : ' , trim ( adjustl ( int_to_str ( self % n_cond_max ))) print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/numerics_scatter_vc.f90.html"},{"title":"calc_exdm_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules calc_exdm_scatter_vf Source Code calc_exdm_scatter_vf.f90 Source Code module calc_exdm_scatter_vf !! Compute  i  contributions to the valence  \\rightarrow  free DM-electron scattering rate. use prec use constants use units use math_mod use binned_scatter_rate_type use bins_scatter_type use expt_type use material_type use dm_model_type use PW_dataset_type use in_med_scr_type use physics_scatter_functions use transition_form_factor use numerics_scatter_vf implicit none contains subroutine exdm_scatter_vf_calc ( binned_rate ,& PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & numerics , & wfc_FT_ik , val_id , k , verbose ) !! Computes the valence to free scattering rate by first computing  \\frac{dR}{d \\omega}  !! for a list of  \\omega  values, then interpolates and integrates to get the binned rate !! in `bins`. implicit none type ( binned_scatter_rate_t ) :: binned_rate type ( PW_dataset_t ) :: PW_dataset type ( material_t ) :: target_mat type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr type ( numerics_scatter_vf_t ) :: numerics complex ( dp ) :: wfc_FT_ik (:) integer :: val_id , k logical , optional :: verbose real ( dp ) :: dRdw ( bins % n_q , numerics % n_omega , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) real ( dp ) :: b_rate ( bins % n_q , bins % n_E , dm_model % n_mX , dm_model % n_med_FF , expt % n_time ) real ( dp ) :: kf_theta , kf_phi , kf_mag real ( dp ) :: k_f ( 3 ), k_i ( 3 ) real ( dp ) :: q_min , q_max , q_mag real ( dp ) :: q_vec ( 3 ) integer :: q_bin real ( dp ) :: omega , Eik , Ef real ( dp ) :: v_m , g_func_val real ( dp ) :: F_med_sq ( dm_model % n_med_FF ) real ( dp ) :: f_sq real ( dp ) :: scr real ( dp ) :: fermi_val , fermi_factor real ( dp ) :: omega_kin_max integer :: m , w , a , t , q , g , f b_rate = 0.0_dp dRdw = 1.0e-100_dp do m = 1 , dm_model % n_mX omega_kin_max = 0.5_dp * dm_model % mX ( m ) * dm_model % vX_max ** 2 ! make sure that the kinematically allowed energy deposition is above the lower ! threshold energy if ( omega_kin_max > numerics % omega_list ( 1 ) ) then ! log_omega_bounds(1) = log10(numerics%omega_list(1)) ! log_omega_bounds(2) = min(log10(omega_kin_max), log_omegas(2)) ! compute dRdw for all w at the endpoints, then interpolate and integrate between to get ! binned rate do w = 1 , numerics % n_omega omega = numerics % omega_list ( w ) q_min = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp - sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) q_max = dm_model % mX ( m ) * dm_model % vX_max * ( 1.0_dp + sqrt ( abs ( 1.0_dp - ( omega / omega_kin_max )))) Eik = PW_dataset % energy_bands ( k , val_id ) - maxval ( PW_dataset % energy_bands (:, : PW_dataset % n_val )) Ef = omega + Eik if ( ( Ef >= PW_dataset % Ef_max ) . and . ( omega > expt % E_threshold ) ) then kf_mag = sqrt ( 2 * m_elec * Ef ) fermi_val = 2.0_dp * pi * numerics % Zeff ( val_id , k ) * ( alpha_EM * m_elec / kf_mag ) fermi_factor = fermi_val * ( 1.0_dp - exp ( - fermi_val )) ** ( - 1 ) do a = 1 , size ( numerics % kf_angular_mesh , 1 ) kf_theta = numerics % kf_angular_mesh ( a , 1 ) kf_phi = numerics % kf_angular_mesh ( a , 2 ) k_f ( 1 ) = kf_mag * sin ( kf_theta ) * cos ( kf_phi ) k_f ( 2 ) = kf_mag * sin ( kf_theta ) * sin ( kf_phi ) k_f ( 3 ) = kf_mag * cos ( kf_theta ) do g = 1 , PW_dataset % n_G f_sq = wfc_FT_ik ( g ) * conjg ( wfc_FT_ik ( g )) k_i = PW_dataset % k_grid_xyz ( k , :) + PW_dataset % G_grid_xyz ( g , :) q_vec = k_f - k_i q_mag = norm2 ( q_vec ) if ( ( q_mag > q_min ) . and . ( q_mag < q_max ) ) then scr = in_med_scr % screening ( q_vec , omega ) q_bin = Q_func ( q_mag , 0.0_dp , bins % q_width , bins % n_q ) do f = 1 , dm_model % n_med_FF F_med_sq ( f ) = F_med_sq_func ( q_mag , dm_model % med_FF ( f )) end do do t = 1 , expt % n_time v_m = v_minus ( q_vec , dm_model % mX ( m ), dm_model % vE * expt % vE_direction ( t , :), omega ) if ( v_m < dm_model % vEsc ) then g_func_val = g_func ( q_mag , v_m , dm_model ) dRdw ( q_bin , w , m , :, t ) = & dRdw ( q_bin , w , m , :, t ) + & f_sq * & fermi_factor * & g_func_val * F_med_sq * & 2.0_dp * m_elec * kf_mag * & scr ** ( - 2 ) end if end do end if end do end do end if end do ! overall constants dRdw (:, :, m , :, :) = ( 2 * pi ) * PW_dataset % k_weight ( k ) * & ( dm_model % rhoX / target_mat % rho_T ) * ( 2 * target_mat % pc_vol ) ** ( - 1 ) * & (( 4 * pi ) / ( numerics % n_kf_theta * numerics % n_kf_phi * 1.0_dp )) * & red_mass ( m_elec , dm_model % mX ( m )) ** ( - 2 ) * ( dm_model % mX ( m )) ** ( - 1 ) * & ( 2 * pi ) ** ( - 3 ) * & expt % m_T * expt % exposure * & eV_to_inv_cm ** 2 * & dRdw (:, :, m , :, :) do q = 1 , bins % n_q do t = 1 , expt % n_time do f = 1 , dm_model % n_med_FF call vf_interpolate_dRdw_to_binned_rate ( numerics % omega_list , & dRdw ( q , :, m , f , t ), & b_rate ( q , :, m , f , t ), & bins % E_width , target_mat % band_gap ) end do end do end do end if end do binned_rate % binned_rate = binned_rate % binned_rate + b_rate end subroutine subroutine vf_interpolate_dRdw_to_binned_rate ( omega_list , dRdw , b_rate , E_bin_width , band_gap ) !! Given a list of  \\omega_i  values, and  \\frac{dR}{d \\omega}  at those values, go through adjacent pairs, !!  [\\omega_{i}, \\omega_{i + 1}]  and  [ \\frac{dR}{d \\omega}(\\omega_{i}), \\frac{dR}{d\\omega}(\\omega_{i + 1})  ] , !! find the power law fit parameter,  \\beta , such that !!  \\frac{dR}{d \\omega}(\\omega_{i + 1}) = \\frac{dR}{d \\omega}(\\omega_i) \\left( \\frac{\\omega_{i + 1}}{\\omega_i} \\right)&#94;\\beta . !! Then integrate this function over each bin,  e ,  \\Delta R_e = \\int_{(e - 1)\\Delta E}&#94;{e \\Delta E} \\frac{dR}{d\\omega} !! d\\omega  for each  i . Note that  \\frac{dR}{d\\omega}  is assumed to be zero for  \\omega \\notin \\omega_i . !! !! Specific to valence  \\rightarrow  free DM-electron scattering rate calculation. implicit none real ( dp ) :: omega_list (:) real ( dp ) :: dRdw (:) real ( dp ) :: b_rate (:) real ( dp ) :: E_bin_width real ( dp ) :: omega_bounds ( 2 ) real ( dp ) :: dRdw_pair ( 2 ) real ( dp ) :: fit_params integer :: w , e real ( dp ) :: E1 , E2 real ( dp ) :: E_bin_L , E_bin_R real ( dp ) :: band_gap if ( size ( b_rate ) > 1 ) then do e = 1 , size ( b_rate ) - 1 E_bin_L = band_gap + ( e - 1 ) * E_bin_width E_bin_R = band_gap + e * E_bin_width b_rate ( e ) = b_rate ( e ) + integrate_log_interpolate (& omega_list ,& dRdw , E_bin_L , E_bin_R ) end do end if ! last bin integrates over the rest of the list b_rate ( size ( b_rate )) = b_rate ( size ( b_rate )) + integrate_log_interpolate (& omega_list , dRdw ,& band_gap + ( size ( b_rate ) - 1 ) * E_bin_width ,& omega_list ( size ( omega_list ))) end subroutine end module","tags":"","loc":"sourcefile/calc_exdm_scatter_vf.f90.html"},{"title":"exdm_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules exdm_scatter_vf Source Code exdm_scatter_vf.f90 Source Code module exdm_scatter_vf !! Compute the valence  \\rightarrow  free DM-electron scattering rate. use mpi use prec use info_messages use io_input use control_input use binned_scatter_rate_type use dm_model_type use expt_type use material_type use PW_dataset_type use in_med_scr_type use FFT_util use MPI_util use numerics_scatter_vf use calc_exdm_scatter_vf implicit none contains subroutine exdm_scatter_vf_set_n_init ( io_files , n_init ) !! Sets the number of initial states to record the rate for. !! Specific to the valence  \\rightarrow  free DM-electron !! scattering rate calculation. implicit none type ( io_files_t ) :: io_files integer :: n_init type ( numerics_scatter_vf_t ) :: numerics type ( PW_dataset_t ) :: PW_dataset call PW_dataset % load ( io_files % PW_data_filename , verbose = . FALSE .) call numerics % load ( io_files % nml_input_filename , & PW_dataset , verbose = . FALSE .) call numerics % create_val_id_list ( PW_dataset % n_val ) n_init = size ( numerics % val_id_list ) end subroutine subroutine run_exdm_scatter_vf ( n_init , n_proc , proc_id , root_process , & binned_rate_init , main_control , io_files , target_mat , dm_model , & bins , expt , in_med_scr , verbose ) !! Compute the valence  \\rightarrow  free DM-electron scattering rate. implicit none integer :: n_init integer :: n_proc integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init ( n_init ) type ( control_t ) :: main_control type ( io_files_t ) :: io_files type ( material_t ) :: target_mat type ( dm_model_t ) :: dm_model type ( bins_scatter_t ) :: bins type ( expt_t ) :: expt type ( in_med_scr_t ) :: in_med_scr logical , optional :: verbose type ( PW_dataset_t ) :: PW_dataset type ( parallel_manager_t ) :: ik_manager type ( numerics_scatter_vf_t ) :: numerics integer , allocatable :: job_id_to_ik (:, :) integer :: t , f , i , k , j integer :: job_id integer :: val_id , fin_id integer :: init_id complex ( dp ), allocatable :: wfc_FT_ik (:) real ( dp ) :: log_omega_min , log_omega_max if ( verbose ) then print * , 'Starting v -> f scattering rate calculation...' print * end if call PW_dataset % load ( io_files % PW_data_filename , verbose = verbose ) call PW_dataset % do_scissor_correction ( target_mat % band_gap , verbose = verbose ) call numerics % load ( io_files % nml_input_filename , PW_dataset , verbose = verbose ) ! create job table, parallelizing over {i, k} call ik_manager % init ( PW_dataset % n_k * numerics % n_val_max , verbose = verbose ) allocate ( job_id_to_ik ( ik_manager % n_jobs , 4 )) job_id_to_ik = 0 call numerics % create_val_id_list ( PW_dataset % n_val ) call numerics % create_k_id_list ( PW_dataset % n_k ) call ik_manager % create_job_to_2d_ID_table (& numerics % val_id_list , & numerics % k_id_list , & job_id_to_ik , verbose = verbose ) allocate ( wfc_FT_ik ( PW_dataset % n_G )) log_omega_min = log10 ( PW_dataset % Ef_max ) log_omega_max = log10 ( 0.5_dp * dm_model % vX_max ** 2 * maxval ( dm_model % mX )) if ( log_omega_max > log_omega_min ) then !     ! time calculation !     if ( ( proc_id == root_process ) .and. ( timer ) ) then !         call time_exdm_scatter_vf_calc(DFT_input_filename, 1, log_omega_table, & !            angular_mesh, verbose = verbose) !     end if numerics % omega_list = 1 0.0_dp ** uniform_list ( numerics % n_omega , log_omega_min , log_omega_max ) if ( verbose ) then print * , 'Calculating transition rates...' print * end if do j = 1 , ik_manager % n_jobs_per_proc job_id = ik_manager % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then ! count states down from highest valence band val_id = job_id_to_ik ( job_id , 1 ) k = job_id_to_ik ( job_id , 2 ) init_id = job_id_to_ik ( job_id , 3 ) ! load initial wave function call PW_dataset % load_wfc_FT_ik_no_spin ( val_id , k , wfc_FT_ik ) ! compute rate call exdm_scatter_vf_calc ( binned_rate_init ( init_id ), & PW_dataset , target_mat , & bins , dm_model , expt , in_med_scr , & numerics , & wfc_FT_ik , val_id , k , verbose = . FALSE .) end if end do if ( verbose ) then print * , 'Done calculating transition rates!' print * end if else call print_warning_message (& 'No mass in mX is large enough to warrant the v -> f calculation' // & ' with the specified Ef_max. Skipping v -> f calculation.' , & verbose = verbose ) end if if ( proc_id == root_process ) then call PW_dataset % save ( io_files % out_filename , verbose = verbose ) call numerics % save ( io_files % out_filename , verbose = verbose ) end if end subroutine ! subroutine time_exdm_scatter_vf_calc(DFT_input_filename, tran_id, log_omega_table, & !         angular_mesh, verbose) !     !! Times the v -> f scattering rate calculation !     use timing !     use mpi !     implicit none !     real(dp) :: log_omega_table(n_fin, 2) !     real(dp) :: log_omegas(2) !     real(dp) :: angular_mesh(n_kf_theta*n_kf_phi, 2) !     character(len=*) :: DFT_input_filename !     integer :: tran_id !     logical, optional :: verbose !     real(dp) :: b_rate(n_q_bins + 1, n_E_bins + 1, n_mX, n_FDM, n_time) !     complex(dp), allocatable :: wfc_FT_i(:, :) !     integer :: val_id, fin_id !     if ( verbose ) then !         print*, 'Timing v -> f calculation...' !         print* !     end if !     allocate(wfc_FT_i(n_k, n_in_G)) !     val_id = tran_to_init_fin_id(tran_id, 1) !     fin_id = tran_to_init_fin_id(tran_id, 2) !     call get_in_wfc_FT(DFT_input_filename, val_id, wfc_FT_i) !     log_omegas = log_omega_table(fin_id, :) !     time(3) = MPI_Wtime() !     call dme_scatter_vf_calc(b_rate,& !         wfc_FT_i, val_id, log_omegas, 1, angular_mesh, verbose = verbose) !     time(4) = MPI_Wtime() !     if ( verbose ) then !         print*, '----------------------------------------' !         print*, '    -------------' !         print*, '    Timing (TEST)' !         print*, '    -------------' !         print* !         print*, '        (TEST) Run time : ' !         print*, '            ', trim(pretty_time_format(time(4) - time(3))) !         print* !         print*, '        Expected run time for whole calculation :' !         print*, '            ', trim(pretty_time_format(& !             n_tran_per_proc*n_k*(time(4) - time(3))& !             )) !         print* !         print*, '----------------------------------------' !         print* !     end if ! end subroutine end module","tags":"","loc":"sourcefile/exdm_scatter_vf.f90.html"},{"title":"numerics_scatter_vf.f90 – EXCEED-DM","text":"Contents Modules numerics_scatter_vf Source Code numerics_scatter_vf.f90 Source Code module numerics_scatter_vf !! Numerics parameters specific to the valence  \\rightarrow  free DM-electron scattering rate calculation. use prec use info_messages implicit none type numerics_scatter_vf_t !! Numerics parameters specific to the valence  \\rightarrow  free DM-electron scattering rate calculation. integer :: n_val_max = 0 !! Maximum number of valence bands character ( len = 64 ) :: Zeff_type = 'one' !! Specify what Zeff to use !! !! - 'one' - all Zeff = 1 !! !! - 'Eb' - use the binding energy of the valence states real ( dp ), allocatable :: Zeff (:, :) !! Dim : [ n_val, n_k ] !! !!  Z_\\text{eff}  parameter in the Fermi form factor. integer , allocatable :: val_id_list (:) !! Dim : [n_val_max] !! !! List of valence ID's to compute for. integer , allocatable :: k_id_list (:) !! Dim : [n_k] !! !! List of k's to compute for. integer :: n_kf_theta = 1 !! Number of  \\theta  points in the integration of  \\mathbf{k}_f  integer :: n_kf_phi = 1 !! Number of  \\phi  points in the integration of  \\mathbf{k}_f  real ( dp ), allocatable :: kf_angular_mesh (:, :) !! Dim : [ n_kf_theta*n_kf_phi, 2 ] !! !! Grid of  \\theta, \\phi  points for the integration over  \\mathbf{k}_f  !! !! Units : None integer :: n_omega !! Number of  \\omega  points to compute for. The valence -> free scattering !! rate calculation is done by computing `n_omega` values of  \\frac{dR}{d \\omega}  between !! !!  \\omega_\\text{min} = E_{f, \\text{max}}  !!  \\omega_\\text{max} = \\frac{1}{2} m_\\chi v_\\text{max}&#94;2  !! !! and then interpolated to the user defined grid. real ( dp ), allocatable :: omega_list (:) !! List of  \\omega  points to compute for. The valence -> free scattering !! rate calculation is done by computing `n_omega` values of  \\frac{dR}{d \\omega}  between !! !!  \\omega_\\text{min} = E_{f, \\text{max}}  !!  \\omega_\\text{max} = \\frac{1}{2} m_\\chi v_\\text{max}&#94;2  !! !! and then interpolated to the user defined grid. contains procedure :: print => numerics_scatter_vf_print procedure :: load => numerics_scatter_vf_load_nml procedure :: save => numerics_scatter_vf_save procedure :: create_val_id_list => vf_create_val_id_list procedure :: create_k_id_list => vf_create_k_id_list end type contains subroutine vf_create_k_id_list ( self , n_k ) !! Specify the indicies for each  \\mathbf{k}  point that should be included. !! Specific to the valence  \\rightarrow  free DM-electron scattering rate calculations. implicit none class ( numerics_scatter_vf_t ) :: self integer :: n_k integer :: k allocate ( self % k_id_list ( n_k )) do k = 1 , n_k self % k_id_list ( k ) = k end do end subroutine subroutine vf_create_val_id_list ( self , n_val ) !! Specify the indicies for each valence band that should be included. !! Specific to the valence  \\rightarrow  free DM-electron scattering rate calculation. implicit none class ( numerics_scatter_vf_t ) :: self integer :: n_val integer :: j allocate ( self % val_id_list ( self % n_val_max )) do j = 1 , self % n_val_max self % val_id_list ( j ) = n_val - j + 1 end do end subroutine subroutine numerics_scatter_vf_save ( self , filename , verbose ) !! Saves `numerics_scatter_vf`. use hdf5 use h5lt implicit none class ( numerics_scatter_vf_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving numerics - scatter-vf parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'numerics_scatter_vf' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vf/n_val_max' , & size ( dims1 ), dims1 , & self % n_val_max , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vf/n_kf_theta' , & size ( dims1 ), dims1 , & self % n_kf_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vf/n_kf_phi' , & size ( dims1 ), dims1 , & self % n_kf_phi , & error ) call h5ltmake_dataset_int_f ( file_id , & 'numerics_scatter_vf/n_omega' , & size ( dims1 ), dims1 , & self % n_omega , & error ) dims1 = [ size ( self % omega_list )] call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_vf/omega_list' , & size ( dims1 ), dims1 , & self % omega_list , & error ) dims2 = [ size ( self % Zeff , 1 ), size ( self % Zeff , 2 ) ] call h5ltmake_dataset_double_f ( file_id , & 'numerics_scatter_vf/Zeff' , & size ( dims2 ), dims2 , & self % Zeff , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_vf_load_nml ( self , filename , PW_dataset , verbose ) !! Loads `numerics_scatter_vf` parameters from a namelist. use PW_dataset_type use math_mod implicit none class ( numerics_scatter_vf_t ) :: self character ( len =* ) :: filename type ( PW_dataset_t ) :: PW_dataset integer :: n_val , n_cond logical , optional :: verbose logical :: file_exists integer :: error integer :: n_val_max = 0 !! Maximum number of valence bands integer :: n_kf_theta = 1 !! Number of  \\theta  points in the integration of  \\mathbf{k}_f  integer :: n_kf_phi = 1 !! Number of  \\phi  points in the integration of  \\mathbf{k}_f  integer :: n_omega = 1 character ( len = 64 ) :: Zeff_type = 'one' real ( dp ) :: n_Eb ( PW_dataset % n_val ) integer :: i , k NAMELIST / numerics_s_vf / n_val_max , & n_kf_theta , & n_kf_phi , & Zeff_type , & n_Eb , & n_omega if ( verbose ) then print * , 'Loading numerics parameters for scatter-vc calculation...' print * end if allocate ( self % Zeff ( PW_dataset % n_val , PW_dataset % n_k )) self % Zeff = 1.0_dp n_Eb = 1.0_dp inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = numerics_s_vf , iostat = error ) close ( 100 ) if ( n_val_max == 0 ) then self % n_val_max = PW_dataset % n_val else self % n_val_max = min ( PW_dataset % n_val , n_val_max ) end if self % n_kf_theta = n_kf_theta self % n_kf_phi = n_kf_phi self % n_omega = n_omega allocate ( self % omega_list ( self % n_omega )) allocate ( self % kf_angular_mesh ( self % n_kf_theta * self % n_kf_phi , 2 )) self % kf_angular_mesh = generate_uniform_points_on_sphere (& self % n_kf_theta , self % n_kf_phi ) self % Zeff_type = trim ( Zeff_type ) if ( trim ( self % Zeff_type ) == 'Eb' ) then do i = 1 , PW_dataset % n_val do k = 1 , PW_dataset % n_k self % Zeff ( i , k ) = n_Eb ( i ) * sqrt (& ( maxval ( PW_dataset % energy_bands (:, : PW_dataset % n_val )) & - PW_dataset % energy_bands ( k , i ) )& / 1 3.6_dp ) self % Zeff ( i , k ) = max ( self % Zeff ( i , k ), 1.0_dp ) end do end do end if call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for numerics-scatter-vc parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine numerics_scatter_vf_print ( self , verbose ) !! Prints `numerics_scatter_vf` components. implicit none class ( numerics_scatter_vf_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------------' print * , '    Numerics - scatter - vf' print * , '    -----------------------' print * print * , '        Maximum number of valence bands    : ' , trim ( adjustl ( int_to_str ( self % n_val_max ))) print * print * , '        Number of kf theta points : ' , trim ( adjustl ( int_to_str ( self % n_kf_theta ))) print * , '        Number of kf phi points   : ' , trim ( adjustl ( int_to_str ( self % n_kf_phi ))) print * , '        Number of omega points    : ' , trim ( adjustl ( int_to_str ( self % n_omega ))) print * print * , '        Zeff type : ' , trim ( self % Zeff_type ) print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/numerics_scatter_vf.f90.html"},{"title":"binned_scatter_rate_type.f90 – EXCEED-DM","text":"Contents Modules binned_scatter_rate_type Source Code binned_scatter_rate_type.f90 Source Code module binned_scatter_rate_type !! Defines the `binned_scatter_rate` data type. use prec use dm_model_type use expt_type use bins_scatter_type implicit none type binned_scatter_rate_t !! Binned scattering rate for each DM mass, mediator form factor, and time of day. Binning is !! in momentum deposition,  q   and energy deposition,  \\omega  (referred to as `E` in the code). real ( dp ), allocatable :: binned_rate (:, :, :, :, :) !! Dim : [ bins%n_q, bins%n_E, dm_model%n_mX, dm_model%n_med_FF, expt%n_time ] !! !! Binned scattering rate per cross section,  \\Delta R_{q, E}(m_\\chi, t, \\beta) . !! !! Units :  \\text{cm}&#94;{-2}  contains procedure :: init => binned_scatter_rate_init procedure :: compute_rate => binned_scatter_rate_compute_rate ! procedure :: save => binned_scatter_rate_save end type contains function binned_scatter_rate_compute_rate ( self ) result ( rate ) !! Sums `binned_rate%binned_rate` over the  q, E  bins to get the total rate. implicit none class ( binned_scatter_rate_t ) :: self integer :: q , E real ( dp ) :: rate (& size ( self % binned_rate , 3 ),& size ( self % binned_rate , 4 ),& size ( self % binned_rate , 5 )) rate = 0.0_dp do E = 1 , size ( self % binned_rate , 2 ) do q = 1 , size ( self % binned_rate , 1 ) rate = rate + self % binned_rate ( q , E , :, :, :) end do end do end function subroutine binned_scatter_rate_init ( self , bins , dm_model , expt ) !! Creates a `binned_rate` object and sets `binned_rate%binned_rate` = 0. implicit none class ( binned_scatter_rate_t ) :: self type ( bins_scatter_t ) :: bins type ( dm_model_t ) :: dm_model type ( expt_t ) :: expt allocate ( self % binned_rate ( bins % n_q , bins % n_E , & dm_model % n_mX , dm_model % n_med_FF , expt % n_time )) self % binned_rate = 0.0_dp end subroutine end module","tags":"","loc":"sourcefile/binned_scatter_rate_type.f90.html"},{"title":"bins_dielectric_type.f90 – EXCEED-DM","text":"Contents Modules bins_dielectric_type Source Code bins_dielectric_type.f90 Source Code module bins_dielectric_type !! Defines the `bins_dielectric` type. use prec implicit none type bins_dielectric_t !! Collection of parameters which specify how the dielectric function !! is binned in  q, \\theta_q, \\phi_q, \\omega . integer :: n_q = 1 !! Number of bins for  q . integer :: n_q_theta = 1 !! Number of bins for the  \\theta  coordinate of  \\mathbf{q}  integer :: n_q_phi = 1 !! Number of bins for the  \\phi  coordinate of  \\mathbf{q}  integer :: n_E = 1 !! Number of bins in omega space real ( dp ) :: q_width = 1.0e3_dp !! Width of the q bins !! !! Units : eV real ( dp ) :: E_width = 0.1_dp !! Width of the omega bins. !! !! Units : eV contains procedure :: print => print_bins_dielectric procedure :: load => load_bins_dielectric_nml procedure :: save => save_bins_dielectric end type contains subroutine print_bins_dielectric ( self , verbose ) !! Print `bins_dielectric` components. use info_messages implicit none class ( bins_dielectric_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------' print * , '    Bins - Dielectric' print * , '    -----------------' print * print * , '        Number of q bins : ' , trim ( adjustl ( int_to_str ( self % n_q ))) print * , '        q bin width      : ' , self % q_width / 1.0e3_dp , 'keV' print * print * , '        Number of q theta bins : ' , trim ( adjustl ( int_to_str ( self % n_q_theta ))) print * , '        Number of q phi bins   : ' , trim ( adjustl ( int_to_str ( self % n_q_phi ))) print * print * , '        Number of E bins : ' , trim ( adjustl ( int_to_str ( self % n_E ))) print * , '        E bin width      : ' , self % E_width , 'eV' print * call print_section_seperator () print * end if end subroutine subroutine load_bins_dielectric_nml ( self , filename , verbose ) !! Loads `bins_dielectric` parameters from a namelist. use info_messages implicit none class ( bins_dielectric_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error integer :: n_q = 1 integer :: n_q_theta = 1 integer :: n_q_phi = 1 integer :: n_E = 1 real ( dp ) :: q_width = 1.0e3_dp real ( dp ) :: E_width = 0.1_dp NAMELIST / bins_dielectric / n_q , & n_q_theta , & n_q_phi , & n_E , & q_width , & E_width if ( verbose ) then print * , 'Loading dielectric binning parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = bins_dielectric , iostat = error ) close ( 100 ) self % n_q = n_q self % n_q_theta = n_q_theta self % n_q_phi = n_q_phi self % n_E = n_E self % q_width = q_width self % E_width = E_width call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for dielectric binning parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine save_bins_dielectric ( self , filename , verbose ) !! Saves `bins_dielectric`. use hdf5 use h5lt use info_messages implicit none class ( bins_dielectric_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving dielectric binning parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'bins_dielectric' , group_id , error ) ! write data call h5ltmake_dataset_double_f ( file_id , & 'bins_dielectric/q_width' , & size ( dims1 ), dims1 , & self % q_width , & error ) call h5ltmake_dataset_double_f ( file_id , & 'bins_dielectric/E_width' , & size ( dims1 ), dims1 , & self % E_width , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_dielectric/n_q' , & size ( dims1 ), dims1 , & self % n_q , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_dielectric/n_q_theta' , & size ( dims1 ), dims1 , & self % n_q_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_dielectric/n_q_phi' , & size ( dims1 ), dims1 , & self % n_q_phi , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_dielectric/n_E' , & size ( dims1 ), dims1 , & self % n_E , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/bins_dielectric_type.f90.html"},{"title":"bins_scatter_type.f90 – EXCEED-DM","text":"Contents Modules bins_scatter_type Source Code bins_scatter_type.f90 Source Code module bins_scatter_type !! Defines the `bins_scatter` type. use prec implicit none type bins_scatter_t !! Collection of parameters which specify how the DM-electron scattering rate !! is binned in  q, \\omega . integer :: n_q = 1 !! Number of bins in momentum space integer :: n_E = 1 !! Number of bins in omega space real ( dp ) :: q_width = 1.0e3_dp !! Width of the q bins !! !! Units : eV real ( dp ) :: E_width = 0.1_dp !! Width of the omega bins. !! !! To get the event rate per ionization threshold,  Q , set this to !! set this to the  \\epsilon  parameter. !! !! Units : eV contains procedure :: print => print_bins procedure :: load => load_bins_nml procedure :: save => save_bins end type contains subroutine print_bins ( self , verbose ) !! Print `bins_scatter` components. use info_messages implicit none class ( bins_scatter_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    --------------' print * , '    Bins - Scatter' print * , '    --------------' print * print * , '        Number of q bins : ' , trim ( adjustl ( int_to_str ( self % n_q ))) print * , '        q bin width      : ' , self % q_width / 1.0e3_dp , 'keV' print * print * , '        Number of E bins : ' , trim ( adjustl ( int_to_str ( self % n_E ))) print * , '        E bin width      : ' , self % E_width , 'eV' print * call print_section_seperator () print * end if end subroutine subroutine load_bins_nml ( self , filename , verbose ) !! Loads `bins_scatter` parameters from a namelist. use info_messages implicit none class ( bins_scatter_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error integer :: n_q = 1 integer :: n_E = 1 real ( dp ) :: q_width = 1.0e3_dp real ( dp ) :: E_width = 0.1_dp NAMELIST / bins_scatter / n_q , & n_E , & q_width , & E_width if ( verbose ) then print * , 'Loading binning parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = bins_scatter , iostat = error ) close ( 100 ) self % n_q = n_q self % n_E = n_E self % q_width = q_width self % E_width = E_width call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for binning parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine save_bins ( self , filename , verbose ) !! Saves `bins_scatter`. use hdf5 use h5lt use info_messages implicit none class ( bins_scatter_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving binning parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'bins_scatter' , group_id , error ) ! write data call h5ltmake_dataset_double_f ( file_id , & 'bins_scatter/q_width' , & size ( dims1 ), dims1 , & self % q_width , & error ) call h5ltmake_dataset_double_f ( file_id , & 'bins_scatter/E_width' , & size ( dims1 ), dims1 , & self % E_width , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_scatter/n_q' , & size ( dims1 ), dims1 , & self % n_q , & error ) call h5ltmake_dataset_int_f ( file_id , & 'bins_scatter/n_E' , & size ( dims1 ), dims1 , & self % n_E , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/bins_scatter_type.f90.html"},{"title":"core_electron_type.f90 – EXCEED-DM","text":"Contents Modules core_electron_type Source Code core_electron_type.f90 Source Code module core_electron_type !! Defines the `core_electron` type. use hdf5 use h5lt use prec use constants use units use math_mod use info_messages implicit none type core_electron_t !! Information about the core electrons for each atom in the unit cell. !! Contains the configuration information, e.g. number of atoms, number of core !! states for each atom, but also the RHF wave function coefficients to get the !! atomic wave functions,  \\psi&#94;\\text{atom}_{\\kappa, n, l, m} . integer :: n_atom !! Number of atoms in the primitive cell. integer :: n_state !! Number of core states. real ( dp ), allocatable :: eq_pos_red (:, :) !! Dim : [n_atom, 3] !! !! Equilibrium positions in reduced coordinates !! !! Units : None real ( dp ), allocatable :: energy (:) !! Dim : [n_state] !! !! Energy of each core state. !! !! Units : eV integer , allocatable :: Z (:) !! Dim : [n_atom] !! !! Proton number of each atom in the primitive cell integer , allocatable :: config (:, :) !! Dim : [n_state, 5] !! !! Electron configuration, each element is !!      config(i, 1) - atom id !!      config(i, 2) - n !!      config(i, 3) - l !!      config(i, 4) - m !!      config(i, 5) - n_s (number of spin states) integer , allocatable :: STO_nj (:) !! Dim : [n_state] !! !! Number of STO expansion parameters for each state real ( dp ), allocatable :: STO_nl (:, :) !! Dim : [ n_state, STO_nj(n_state) ] !! !! STO n_lj parameters !! !! Units : None real ( dp ), allocatable :: STO_Zl (:, :) !! Dim : [ n_state, STO_nj(n_state) ] !! !! STO Z_lj parameters !! !! Units : None real ( dp ), allocatable :: STO_norm_l (:, :) !! Dim : [ n_state, STO_nj(n_state) ] !! !! STO N_lj parameters !! !! Units : None real ( dp ), allocatable :: STO_Cnl (:, :) !! Dim : [ n_state, STO_nj(n_state) ] !! !! STO C_nlj parameters !! !! Units : None ! generated !real(dp), allocatable :: eq_pos_xyz(:, :) !    !! Dim : [n_atom, 3] !    !! !    !! Equilibrium positions in xyz coordinates. !    !! !    !! Units : eV&#94;(-1) integer :: STO_max_nj !! Maximum value of nj across all states. character ( len = 512 ) :: config_filename !! Core electron configuration filename character ( len = 512 ) :: sto_filename !! STO wave function coefficient filename contains procedure :: load => load_core_electron procedure :: save => save_core_electron procedure :: print => print_core_electron procedure :: bloch_wf_on_grid => core_bloch_wf_on_grid procedure :: atomic_sto_wf procedure :: atomic_sto_wf_radial procedure :: atomic_sto_wf_FT procedure :: atomic_sto_wf_FT_radial end type contains function atomic_sto_wf_FT_radial ( self , id , k_mag ) result ( chi ) !! Radial part of `atomic_sto_wf`. !! !! Units :  \\text{eV}&#94;{-3/2}  implicit none class ( core_electron_t ) :: self integer :: id !! references a specific element in self%config integer :: atom , n , l , m integer :: j integer :: n_lj , nj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: k_mag complex ( dp ) :: chi chi = cmplx ( 0.0_dp , 0.0_dp , dp ) l = self % config ( id , 3 ) do j = 1 , self % STO_nj ( id ) n_lj = int ( self % STO_nl ( id , j )) Z_lj = self % STO_Zl ( id , j ) N0_lj = self % STO_norm_l ( id , j ) C_lnj = self % STO_Cnl ( id , j ) chi = chi + C_lnj * sto_wf_FT_radial ( n_lj , l , N0_lj , Z_lj , k_mag ) end do end function function atomic_sto_wf_FT ( self , id , k ) result ( wf_FT ) !! Fourier transform of the atomic wave function which is a sum of STO's. !! !! Units :  \\text{eV}&#94;{-3/2}  implicit none class ( core_electron_t ) :: self integer :: id !! references a specific element in self%config() integer :: l , m real ( dp ) :: k ( 3 ), k_hat ( 3 ) real ( dp ) :: k_mag complex ( dp ) :: wf_FT k_mag = norm2 ( k ) ! avoid |k| = 0 problems if ( k_mag > 1e-8_dp ) then k_hat = k / k_mag else k_hat = [ 0 , 0 , 1 ] end if l = self % config ( id , 3 ) m = self % config ( id , 4 ) wf_FT = self % atomic_sto_wf_FT_radial ( id , k_mag ) * & sph_harmonic ( l , m , get_theta ( k_hat ), get_phi ( k_hat )) end function function sto_wf_radial ( n , N0 , Z , r ) result ( wf ) !! Individual Slater Type Orbital (STO) !! !! Units : eV&#94;(3/2) integer :: n real ( dp ) :: N0 , Z , r real ( dp ) :: wf wf = a0 ** ( - 1.5_dp ) * N0 * ( r / a0 ) ** ( n - 1 ) * exp ( - Z * r / a0 ) end function function sto_wf_FT_radial ( n , l , norm , Z , k_mag ) result ( wf_FT ) !! Radial part of the Fourier transform of a Slater type orbital (STO) wave function. !! !! \\begin{align*} !!      \\widetilde{\\psi}_\\text{STO}( \\mathbf{k} ) & = \\int d&#94;3x \\psi_\\text{STO} e&#94;{-i ( \\mathbf{k} \\cdot \\mathbf{r} ) } \\\\ !!           & = \\widetilde{\\psi}_\\text{STO, radial}( k ) Y&#94;l_m(\\hat{\\mathbf{k}}) !! \\end{align*} !! !! Reference : [https://en.wikipedia.org/wiki/Slater-type_orbital](https://en.wikipedia.org/wiki/Slater-type_orbital) !! !! Units :  \\text{eV}&#94;{-3/2}  implicit none integer :: n , l real ( dp ) :: norm , Z , k_mag complex ( dp ) :: wf_FT integer :: s real ( dp ) :: omega_s , xi wf_FT = cmplx ( 0.0_dp , 0.0_dp , dp ) xi = Z / a0 do s = 0 , floor (( n - l ) / 2.0_dp ) omega_s = ( - 4 * xi ** 2 ) ** ( - s ) * factorial ( n - s ) * & ( factorial ( s ) * factorial ( n - l - 2 * s )) ** ( - 1 ) wf_FT = wf_FT + omega_s * ( k_mag ** 2 + xi ** 2 ) ** ( s - n - 1 ) end do wf_FT = a0 ** ( - 0.5 ) * a0 ** ( - n ) * norm * ( 4 * pi ) * factorial ( n - l ) * & ( 2 * xi ) ** n * ( ii * k_mag / xi ) ** l * wf_FT end function function atomic_sto_wf_radial ( self , id , r ) result ( wf ) !! Radial part of `atomic_sto_wf`. !! !! Units :  \\text{eV}&#94;{3/2}  class ( core_electron_t ) :: self integer :: id real ( dp ) :: r integer :: l , j integer :: n_lj real ( dp ) :: Z_lj , N0_lj , C_lnj real ( dp ) :: wf wf = 0.0_dp ! l = self%config(id, 3) do j = 1 , self % STO_nj ( id ) n_lj = int ( self % STO_nl ( id , j )) Z_lj = self % STO_Zl ( id , j ) N0_lj = self % STO_norm_l ( id , j ) C_lnj = self % STO_Cnl ( id , j ) wf = wf + C_lnj * sto_wf_radial ( n_lj , N0_lj , Z_lj , r ) end do end function function atomic_sto_wf ( self , id , x ) result ( wf ) !! Atomic wave function, summed over individual STO's. !! !! Units :  \\text{eV}&#94;{3/2}  implicit none class ( core_electron_t ) :: self integer :: id real ( dp ) :: x ( 3 ) real ( dp ) :: x_hat ( 3 ) real ( dp ) :: x_mag complex ( dp ) :: wf integer :: l , m x_mag = norm2 ( x ) ! avoid |x| = 0 problems if ( x_mag > 1e-8_dp ) then x_hat = x / x_mag else x_hat = [ 0 , 0 , 1 ] end if l = self % config ( id , 3 ) m = self % config ( id , 4 ) wf = self % atomic_sto_wf_radial ( id , x_mag )& * sph_harmonic ( l , m , get_theta ( x_hat ), get_phi ( x_hat )) end function subroutine core_bloch_wf_on_grid ( self , n_grid , wf , id , pc_vol , & red_to_xyz , shift , k_vec_in , r_cut_in , verbose ) !! Compute the core electron wave functions on a grid inside the primitive cell, summed !! over neighboring unit cells. !! !!  \\text{ID} \\rightarrow \\{ \\kappa, n, l, m \\}  !! \\begin{align} !! u&#94;\\text{core}_{\\text{ID}, \\mathbf{k}}(\\mathbf{x}) = \\sqrt{\\Omega} \\sum_{r} !! e&#94;{-i \\mathbf{k} \\left( \\mathbf{x} - \\mathbf{r} - \\mathbf{x}_\\kappa \\right) } !! \\psi&#94;\\text{atom}( \\mathbf{x} - \\mathbf{r} - \\mathbf{x}_\\kappa ) !! \\nonumber \\end{align} !! !! `wf`  \\rightarrow u&#94;\\text{core}_{\\text{ID}, \\mathbf{k}}  !! !! By default, will compute the above assuming  \\mathbf{k} = 0  and sum over only the nearest !! neighbor unit cells. !! !! Units : None implicit none class ( core_electron_t ) :: self integer :: n_grid ( 3 ) complex ( dp ) :: wf ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) integer :: id real ( dp ) :: pc_vol real ( dp ) :: red_to_xyz ( 3 , 3 ) logical , optional :: shift real ( dp ), optional :: k_vec_in ( 3 ) integer , optional :: r_cut_in logical , optional :: verbose real ( dp ) :: k_vec ( 3 ) integer :: r_cut integer :: n1 , n2 , n3 integer :: r1 , r2 , r3 real ( dp ) :: x_red ( 3 ) real ( dp ) :: r_red ( 3 ) real ( dp ) :: x_vec ( 3 ) real ( dp ) :: x_shift_red ( 3 ) real ( dp ) :: x_shift ( 3 ) complex ( dp ) :: phase_fac real ( dp ) :: y_vec ( 3 ) !! y = x + r - x_i integer :: r , r_count , n_r real ( dp ), allocatable :: r_red_list (:, :) real ( dp ), allocatable :: r_vec_list (:, :) complex ( dp ) :: wf_sum if ( shift ) then x_shift_red = self % eq_pos_red ( self % config ( id , 1 ), :) else x_shift_red = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if x_shift = matmul ( red_to_xyz , x_shift_red ) if ( present ( k_vec_in ) ) then k_vec = k_vec_in else k_vec = [ 0.0_dp , 0.0_dp , 0.0_dp ] end if if ( present ( r_cut_in ) ) then r_cut = r_cut_in else r_cut = 1 end if n_r = ( 2 * r_cut + 1 ) ** 3 allocate ( r_red_list ( 3 , n_r )) allocate ( r_vec_list ( 3 , n_r )) r_count = 0 do r1 = - r_cut , r_cut do r2 = - r_cut , r_cut do r3 = - r_cut , r_cut r_count = r_count + 1 r_red_list (:, r_count ) = [ 1.0_dp * r1 , 1.0_dp * r2 , 1.0_dp * r3 ] r_vec_list (:, r_count ) = matmul ( red_to_xyz , r_red_list (:, r_count )) end do end do end do if ( present ( k_vec_in ) ) then do n3 = 1 , n_grid ( 3 ) do n2 = 1 , n_grid ( 2 ) do n1 = 1 , n_grid ( 1 ) x_red = [& ( n1 - 1.0_dp ) / n_grid ( 1 ),& ( n2 - 1.0_dp ) / n_grid ( 2 ),& ( n3 - 1.0_dp ) / n_grid ( 3 )& ] x_vec = matmul ( red_to_xyz , x_red ) wf_sum = cmplx ( 0.0_dp , 0.0_dp , dp ) do r = 1 , n_r y_vec = x_vec - x_shift + r_vec_list (:, r ) phase_fac = exp ( - ii * dot_product ( k_vec , y_vec )) wf_sum = wf_sum + phase_fac * self % atomic_sto_wf ( id , y_vec ) end do wf ( n1 , n2 , n3 ) = wf_sum end do end do end do else do n3 = 1 , n_grid ( 3 ) do n2 = 1 , n_grid ( 2 ) do n1 = 1 , n_grid ( 1 ) x_red = [& ( n1 - 1.0_dp ) / n_grid ( 1 ),& ( n2 - 1.0_dp ) / n_grid ( 2 ),& ( n3 - 1.0_dp ) / n_grid ( 3 )& ] x_vec = matmul ( red_to_xyz , x_red ) wf_sum = cmplx ( 0.0_dp , 0.0_dp , dp ) do r = 1 , n_r y_vec = x_vec - x_shift + r_vec_list (:, r ) wf_sum = wf_sum + self % atomic_sto_wf ( id , y_vec ) end do wf ( n1 , n2 , n3 ) = wf_sum end do end do end do end if wf = sqrt ( pc_vol ) * wf end subroutine subroutine save_core_electron ( self , filename , verbose ) !! Saves `core_electron`. implicit none class ( core_electron_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving core electron parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'core_electron' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'core_electron/n_atom' , & size ( dims1 ), dims1 , & self % n_atom , & error ) call h5ltmake_dataset_int_f ( file_id , & 'core_electron/n_state' , & size ( dims1 ), dims1 , & self % n_state , & error ) dims2 = [ self % n_atom , 3 ] call h5ltmake_dataset_double_f ( file_id , & 'core_electron/eq_pos_red' , & size ( dims2 ), dims2 , & self % eq_pos_red , & error ) dims1 = [ self % n_state ] call h5ltmake_dataset_double_f ( file_id , & 'core_electron/energy' , & size ( dims1 ), dims1 , & self % energy , & error ) dims1 = [ self % n_atom ] call h5ltmake_dataset_int_f ( file_id , & 'core_electron/Z' , & size ( dims1 ), dims1 , & self % Z , & error ) dims2 = [ self % n_state , 5 ] call h5ltmake_dataset_int_f ( file_id , & 'core_electron/config' , & size ( dims2 ), dims2 , & self % config , & error ) ! STO parameters call h5gcreate_f ( file_id , 'core_electron/STO' , group_id , error ) dims1 = [ self % n_state ] call h5ltmake_dataset_int_f ( file_id , & 'core_electron/STO/n_j' , & size ( dims1 ), dims1 , & self % STO_nj , & error ) dims1 = [ 1 ] call h5ltmake_dataset_int_f ( file_id , & 'core_electron/STO/max_n_j' , & size ( dims1 ), dims1 , & self % STO_max_nj , & error ) dims2 = [ self % n_state , self % STO_max_nj ] call h5ltmake_dataset_double_f ( file_id , & 'core_electron/STO/n_lj' , & size ( dims2 ), dims2 , & self % STO_nl , & error ) call h5ltmake_dataset_double_f ( file_id , & 'core_electron/STO/Z_lj' , & size ( dims2 ), dims2 , & self % STO_Zl , & error ) call h5ltmake_dataset_double_f ( file_id , & 'core_electron/STO/N0_lj' , & size ( dims2 ), dims2 , & self % STO_norm_l , & error ) call h5ltmake_dataset_double_f ( file_id , & 'core_electron/STO/C_nlj' , & size ( dims2 ), dims2 , & self % STO_Cnl , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine print_core_electron ( self , verbose ) !! Prints `core_electron` components. implicit none class ( core_electron_t ) :: self logical , optional :: verbose integer :: n if ( verbose ) then call print_section_seperator () print * , '    --------------' print * , '    Core Electrons' print * , '    --------------' print * print * , '        Core electron configuration filename : ' , trim ( self % config_filename ) print * , '        STO data filename                    : ' , trim ( self % STO_filename ) print * print * , '        Number of atoms       : ' , trim ( adjustl ( int_to_str ( self % n_atom ))) print * , '        Proton numbers        : ' , self % Z print * , '        Number of core states : ' , trim ( adjustl ( int_to_str ( self % n_state ))) print * print * , '        Equilibrium positions (reduced) : ' do n = 1 , self % n_atom print * , '            atom # : ' , n , ', ' , self % eq_pos_red ( n , :) end do print * print * , '        Configuration and STO parameters : ' print * do n = 1 , self % n_state print * , '            atom # : ' , trim ( adjustl ( int_to_str ( self % config ( n , 1 )))) print * , '            n      : ' , trim ( adjustl ( int_to_str ( self % config ( n , 2 )))) print * , '            l      : ' , trim ( adjustl ( int_to_str ( self % config ( n , 3 )))) print * , '            m      : ' , trim ( adjustl ( int_to_str ( self % config ( n , 4 )))) print * , '            n_s    : ' , trim ( adjustl ( int_to_str ( self % config ( n , 5 )))) print * print * , '            energy : ' , self % energy ( n ), 'eV' print * print * , '            Number of coefficients : ' , trim ( adjustl ( int_to_str ( self % STO_nj ( n )))) print * print * , '            n_lj : ' , self % STO_nl ( n , :) print * , '            Z_lj : ' , self % STO_Zl ( n , :) print * , '            N0_lj : ' , self % STO_norm_l ( n , :) print * , '            C_lnj : ' , self % STO_Cnl ( n , :) print * end do call print_section_seperator () print * end if end subroutine subroutine load_core_electron ( self , core_elec_config_filename , STO_filename , verbose ) !! Loads `core_electron` parameters from a namelist. implicit none class ( core_electron_t ) :: self character ( len =* ) :: core_elec_config_filename character ( len =* ) :: STO_filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: core_file_exists , STO_file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims1 ( 1 ) integer ( HSIZE_T ) :: dims2 ( 2 ) real ( dp ), allocatable :: buf (:) character ( len = 64 ) :: dset_name integer :: nj , n integer :: error if ( verbose ) then print * , 'Loading core electron configuration...' print * end if inquire ( file = core_elec_config_filename , exist = core_file_exists ) if ( core_file_exists ) then self % config_filename = trim ( core_elec_config_filename ) call h5open_f ( error ) call h5fopen_f ( core_elec_config_filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_int_f ( file_id , 'n_atom' , self % n_atom , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_state' , self % n_state , dims , error ) dims2 = [ self % n_atom , 3 ] allocate ( self % eq_pos_red ( self % n_atom , 3 )) call h5ltread_dataset_double_f ( file_id , 'eq_pos_red' , self % eq_pos_red , dims2 , error ) dims1 = [ self % n_state ] allocate ( self % energy ( self % n_state )) call h5ltread_dataset_double_f ( file_id , 'energy' , self % energy , dims1 , error ) dims1 = [ self % n_atom ] allocate ( self % Z ( self % n_atom )) call h5ltread_dataset_int_f ( file_id , 'Z' , self % Z , dims1 , error ) dims2 = [ self % n_state , 5 ] allocate ( self % config ( self % n_state , 5 )) call h5ltread_dataset_int_f ( file_id , 'config' , self % config , dims2 , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Core electron configuration file' // & trim ( core_elec_config_filename ) // 'does NOT exist.' , & verbose = verbose ) stop end if if ( verbose ) then print * , 'Loading STO coefficients...' print * end if inquire ( file = STO_filename , exist = STO_file_exists ) if ( STO_file_exists ) then self % STO_filename = trim ( STO_filename ) call h5open_f ( error ) call h5fopen_f ( STO_filename , H5F_ACC_RDONLY_F , file_id , error ) allocate ( self % STO_nj ( self % n_state )) !! get the relevant data for each core state do n = 1 , self % n_state dset_name = get_sto_dataset_str ( self % Z ( self % config ( n , 1 )),& self % config ( n , 2 ),& self % config ( n , 3 )) call h5ltread_dataset_int_f ( file_id ,& trim ( dset_name ) // '/nj' ,& self % STO_nj ( n ),& dims , error ) end do self % STO_max_nj = maxval ( self % STO_nj ) allocate ( self % STO_nl ( self % n_state , self % STO_max_nj )) allocate ( self % STO_Zl ( self % n_state , self % STO_max_nj )) allocate ( self % STO_norm_l ( self % n_state , self % STO_max_nj )) allocate ( self % STO_Cnl ( self % n_state , self % STO_max_nj )) self % STO_nl = 0.0_dp self % STO_Zl = 0.0_dp self % STO_norm_l = 0.0_dp self % STO_Cnl = 0.0_dp do n = 1 , self % n_state nj = self % STO_nj ( n ) dset_name = get_sto_dataset_str ( self % Z ( self % config ( n , 1 )),& self % config ( n , 2 ),& self % config ( n , 3 )) dims1 = [ nj ] allocate ( buf ( nj )) call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/n_lj' , buf , dims1 , error ) self % STO_nl ( n , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/Z_lj' , buf , dims1 , error ) self % STO_Zl ( n , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/N_lj' , buf , dims1 , error ) self % STO_norm_l ( n , : nj ) = buf call h5ltread_dataset_double_f ( file_id ,& trim ( dset_name ) // '/C_lnj' , buf , dims1 , error ) self % STO_Cnl ( n , : nj ) = buf deallocate ( buf ) end do call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'STO wave function coefficient file' // & trim ( STO_filename ) // ' does NOT exist.' , verbose = verbose ) stop end if call self % print ( verbose = verbose ) end subroutine function get_sto_dataset_str ( Z , n , l ) result ( dset_name ) !! Returns the (string) name of the dataset where the RHF STO coefficients are for atom with !! proton number,  Z , and quantum numbers,  n, l  inside the RHF data file. implicit none integer :: Z , n , l character ( len = 64 ) :: dset_name dset_name = 'Z_' // trim ( adjustl ( int_to_str ( Z )))& // '/n_' // trim ( adjustl ( int_to_str ( n )))& // '/l_' // trim ( adjustl ( int_to_str ( l ))) end function end module","tags":"","loc":"sourcefile/core_electron_type.f90.html"},{"title":"dm_model_type.f90 – EXCEED-DM","text":"Contents Modules dm_model_type Source Code dm_model_type.f90 Source Code module dm_model_type !! Defines the `dm_model` type. use hdf5 use h5lt use info_messages use prec use constants use units use math_mod implicit none type dm_model_t !! Parameters defining the dark matter (DM) model, i.e. the DM particle and mediator. integer :: n_mX = 1 !! Number of masses real ( dp ), allocatable :: mX (:) !! Dim : [ n_mX ] !! !! List of masses !! !! Units : eV integer :: n_med_FF = 1 !! Number of mediator form factors real ( dp ), allocatable :: med_FF (:) !! Dim : [ n_med_FF ] !! !! List of mediator form factors coefficients,  \\beta  !! !! \\begin{align} !!      \\mathcal{F}_\\text{med} = \\left( \\frac{ \\alpha m_e }{ q } \\right)&#94;\\beta \\nonumber !! \\end{align} !! !! Examples: !! <ul> !!     <li>Light mediator :  \\beta = 2  </li> !!     <li>Heavy mediator :  \\beta = 0  </li> !! </ul> !! !! Units : None real ( dp ) :: rhoX_GeV_per_cm3 = 0.4_dp !! Dark matter density !! !! Units : GeV/cm&#94;3 real ( dp ) :: rhoX !! Dark matter density !! !! Units : eV&#94;4 real ( dp ) :: v0_km_per_sec = 23 0.0_dp !! DM velocity distribution parameter,  v_0  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : km/s real ( dp ) :: vE_km_per_sec = 24 0.0_dp !! DM velocity distribution parameter,  |\\mathbf{v}_e|  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : km/s real ( dp ) :: vEsc_km_per_sec = 60 0.0_dp !! DM velocity distribution parameter,  v_\\text{esc}  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : km/s real ( dp ) :: v0 !! DM velocity distribution parameter,  v_0  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : None real ( dp ) :: vE !! DM velocity distribution parameter,  |\\mathbf{v}_e|  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : None real ( dp ) :: vEsc !! DM velocity distribution parameter,  v_\\text{esc}  !! !! \\begin{align} !!      f_\\chi(\\mathbf{v}) = \\frac{1}{N_0} !!          e&#94;{-( \\mathbf{v} + \\mathbf{v}_e)&#94;2/v_0&#94;2} !!          \\Theta( v_\\text{esc} - |\\mathbf{v} + \\mathbf{v}_e|) \\nonumber !! \\end{align} !! !! Units : None real ( dp ) :: g_func_N0 !! Parameter of !! \\begin{align*} !!  g( \\mathbf{q}, \\omega ) & = 2 \\pi \\int d&#94;3\\mathbf{v} f_\\chi(\\mathbf{v}) \\delta(\\omega - \\omega_\\mathbf{q} ) \\\\ !!  & = \\frac{2 \\pi&#94;2 v_0&#94;2}{N_0 q} \\left( e&#94;{-v_-&#94;2/v_0&#94;2} - e&#94;{-v_\\text{esc}&#94;2/v_0&#94;2} \\right) \\\\ !!  \\omega_\\mathbf{q} & = \\mathbf{q} \\cdot \\mathbf{v} - \\frac{q&#94;2}{2 m_\\chi} !! \\end{align*} !! !! `g_func_N0`  = N_0 = \\pi v_0&#94;3 !! \\left( \\sqrt{\\pi} \\text{erf}(v_\\text{esc}/v_0) - 2\\frac{v_\\text{esc}}{v_0} !! e&#94;{-(v_\\text{esc}/v_0)&#94;2} \\right)  !! !! Units : None real ( dp ) :: g_func_c1 !! Parameter of !! \\begin{align*} !!  g( \\mathbf{q}, \\omega ) & = 2 \\pi \\int d&#94;3\\mathbf{v} f_\\chi(\\mathbf{v}) \\delta(\\omega - \\omega_\\mathbf{q} ) \\\\ !!  & = \\frac{2 \\pi&#94;2 v_0&#94;2}{N_0 q} \\left( e&#94;{-v_-&#94;2/v_0&#94;2} - e&#94;{-v_\\text{esc}&#94;2/v_0&#94;2} \\right) \\\\ !!  \\omega_\\mathbf{q} & = \\mathbf{q} \\cdot \\mathbf{v} - \\frac{q&#94;2}{2 m_\\chi} !! \\end{align*} !! !! `g_func_c1`  = \\frac{2 \\pi&#94;2 v_0&#94;2}{N_0}   !! !! Units : None real ( dp ) :: g_func_c2 !! Parameter of !! \\begin{align*} !!  g( \\mathbf{q}, \\omega ) & = 2 \\pi \\int d&#94;3\\mathbf{v} f_\\chi(\\mathbf{v}) \\delta(\\omega - \\omega_\\mathbf{q} ) \\\\ !!  & = \\frac{2 \\pi&#94;2 v_0&#94;2}{N_0 q} \\left( e&#94;{-v_-&#94;2/v_0&#94;2} - e&#94;{-v_\\text{esc}&#94;2/v_0&#94;2} \\right) \\\\ !!  \\omega_\\mathbf{q} & = \\mathbf{q} \\cdot \\mathbf{v} - \\frac{q&#94;2}{2 m_\\chi} !! \\end{align*} !! !! `g_func_c2`  = e&#94;{-v_\\text{esc}&#94;2/v_0&#94;2}  !! !! Units : None real ( dp ) :: vX_max !! Maximum speed of the incoming dark matter !! !! `vX_max` = `vE` + `vEsc` !! !! Units : None integer :: tff_id ( 2 ) = [ 1 , 1 ] !! Transition form factor ID. Specifies which matrix element to compute, which !! will depend on the scattering potential of the DM model character ( len = 64 ) :: particle_type = 'fermion' !! Dark matter particle type contains procedure :: load => load_dm_model_nml procedure :: save => save_dm_model procedure :: print => print_dm_model end type contains subroutine print_dm_model ( self , verbose ) !! Prints `dm_model` components. implicit none class ( dm_model_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------' print * , '    Dark Matter Model' print * , '    -----------------' print * print * , '        Particle type : ' , trim ( self % particle_type ) print * print * , '        Density     : ' , self % rhoX_GeV_per_cm3 , 'GeV/cm&#94;3' print * , '        Masses (eV) : ' , self % mX print * print * , '        Mediator Form Factors (-d log F_DM / d log q) : ' , self % med_FF print * , '        Transition Form Factor ID                     : ' , self % tff_id print * print * , '        Velocity Distribution Parameters : ' print * , '            v0   = ' , self % v0_km_per_sec , 'km/sec' print * , '            vE   = ' , self % vE_km_per_sec , 'km/sec' print * , '            vEsc = ' , self % vEsc_km_per_sec , 'km/sec' print * call print_section_seperator () print * end if end subroutine subroutine load_dm_model_nml ( self , filename , verbose ) !! Loads `dm_model` parameters from a namelist. implicit none class ( dm_model_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error ! namelist integer :: n_mX = 1 real ( dp ) :: log_mX_min = 9.0_dp real ( dp ) :: log_mX_max = 9.0_dp integer :: n_extra_mX = 0 !! Optional !! !! User can specify extra mass points to add in addition to !! the log-uniform ones chosen integer :: n_med_FF = 1 real ( dp ) :: med_FF_min = 0.0_dp real ( dp ) :: med_FF_max = 0.0_dp real ( dp ) :: rhoX_GeV_per_cm3 = 0.4_dp real ( dp ) :: v0_km_per_sec = 23 0.0_dp real ( dp ) :: vE_km_per_sec = 24 0.0_dp real ( dp ) :: vEsc_km_per_sec = 60 0.0_dp integer :: tff_id ( 2 ) = [ 1 , 1 ] character ( len = 64 ) :: particle_type = 'fermion' real ( dp ), allocatable :: mX_2 (:) NAMELIST / dm_model / n_mX , & log_mX_min , & log_mX_max , & n_extra_mX , & n_med_FF , & med_FF_min , & med_FF_max , & rhoX_GeV_per_cm3 , & v0_km_per_sec , & vE_km_per_sec , & vEsc_km_per_sec , & tff_id , & particle_type NAMELIST / extra_mX / mX_2 if ( verbose ) then print * , 'Loading the dark matter model...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = dm_model , iostat = error ) rewind ( 100 ) self % n_med_FF = n_med_FF allocate ( self % med_FF ( n_med_FF )) self % med_FF = uniform_list ( n_med_FF , med_FF_min , med_FF_max ) self % rhoX_GeV_per_cm3 = rhoX_GeV_per_cm3 self % rhoX = inv_cm_to_eV ** 3 * 1.0e9_dp * rhoX_GeV_per_cm3 self % v0_km_per_sec = v0_km_per_sec self % vE_km_per_sec = vE_km_per_sec self % vEsc_km_per_sec = vEsc_km_per_sec self % tff_id = tff_id self % v0 = km_per_sec_to_none * v0_km_per_sec self % vE = km_per_sec_to_none * vE_km_per_sec self % vEsc = km_per_sec_to_none * vEsc_km_per_sec self % vX_max = self % vE + self % vEsc self % g_func_N0 = ( pi * self % v0 ** 3 ) * & ( sqrt ( pi ) * erf ( self % vEsc / self % v0 ) - 2 * ( self % vEsc / self % v0 ) * exp ( - ( self % vEsc / self % v0 ) ** 2 )) self % g_func_c1 = ( 2 * pi ** 2 * self % v0 ** 2 / self % g_func_N0 ) self % g_func_c2 = exp ( - ( self % vEsc / self % v0 ) ** 2 ) self % particle_type = particle_type if ( n_extra_mX /= 0 ) then allocate ( mX_2 ( n_extra_mX )) mX_2 = 1.0e9_dp read ( 100 , nml = extra_mX , iostat = error ) rewind ( 100 ) end if close ( 100 ) self % n_mX = n_mX + n_extra_mX allocate ( self % mX ( self % n_mX )) self % mX (: n_mX ) = 1 0.0_dp ** uniform_list ( n_mX , log_mX_min , log_mX_max ) if ( n_extra_mX /= 0 ) then self % mX ( n_mX + 1 :) = mX_2 end if call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for dark matter model : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine save_dm_model ( self , filename , verbose ) !! Saves `dm_model`. implicit none class ( dm_model_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving dark matter model...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'dm_model' , group_id , error ) ! ! write data call h5ltmake_dataset_string_f ( file_id , 'dm_model/particle_type' , & trim ( self % particle_type ), error ) call h5ltmake_dataset_int_f ( file_id , 'dm_model/n_mX' , size ( dims1 ), dims1 ,& self % n_mX , error ) call h5ltmake_dataset_int_f ( file_id , 'dm_model/n_med_FF' , size ( dims1 ), dims1 ,& self % n_med_FF , error ) call h5ltmake_dataset_double_f ( file_id , 'dm_model/rhoX' , size ( dims1 ), dims1 ,& self % rhoX_GeV_per_cm3 , error ) dims1 = [ self % n_mX ] call h5ltmake_dataset_double_f ( file_id , 'dm_model/mX' , size ( dims1 ), dims1 ,& self % mX , error ) dims1 = [ self % n_med_FF ] call h5ltmake_dataset_double_f ( file_id , 'dm_model/med_FF' , size ( dims1 ), dims1 ,& self % med_FF , error ) call h5ltmake_dataset_double_f ( file_id , 'dm_model/v0' , size ( dims1 ), dims1 ,& self % v0_km_per_sec , error ) call h5ltmake_dataset_double_f ( file_id , 'dm_model/vEsc' , size ( dims1 ), dims1 ,& self % vEsc_km_per_sec , error ) call h5ltmake_dataset_double_f ( file_id , 'dm_model/vE' , size ( dims1 ), dims1 ,& self % vE_km_per_sec , error ) dims1 = [ 2 ] call h5ltmake_dataset_int_f ( file_id , 'dm_model/tff_id' , size ( dims1 ), dims1 ,& self % tff_id , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' ) stop end if end subroutine end module","tags":"","loc":"sourcefile/dm_model_type.f90.html"},{"title":"expt_type.f90 – EXCEED-DM","text":"Contents Modules expt_type Source Code expt_type.f90 Source Code module expt_type !! Defines `expt` type. use prec use constants implicit none type expt_t !! Experimental parameters, e.g. threshold energy, exposure, detector orientation. real ( dp ) :: E_threshold = 0.0_dp !! Energy threshold. Only events which deposit energy omega >= E_threshold will be considered. !! !! Units : eV real ( dp ) :: m_T_kg = 1.0_dp !! Mass of the target !! !! Units : kg real ( dp ) :: m_T !! Mass of the target !! !! Units : eV real ( dp ) :: exposure_yr = 1.0_dp !! Total exposure of the experiment !! !! Units : year real ( dp ) :: exposure !! Total exposure of the experiment !! !! Units : eV&#94;(-1) integer :: n_time = 1 !! Number of time of days to compute for real ( dp ), allocatable :: times (:) !! Dim : [ n_time ] !! !! Times of the day. !! !! Units : days real ( dp ), allocatable :: vE_direction (:, :) !! Dim : [ n_time, 3 ] !! !! Unit vector of the Earth velocity in the galactic frame, assuming the DM wind !! is incoming on the Earth in the direction  (0, 0, -1) . !! !! See Fig. 1 of https://arxiv.org/abs/1909.09170 for an illustration. !! !! The standard setup assumes that the z-axis of the target is aligned anti-parallel !! to the DM wind at  t = 0  (defined to be  \\hat{\\mathbf{z}}  ), the Earth then !! rotates about a vector which is  \\theta_E = 42\\deg  off  \\hat{\\mathbf{z}} . !! !! Units : None real ( dp ) :: theta_E = 4 2.0_dp * ( pi / 18 0.0_dp ) !! Angle between the Earth's rotation axis and the DM wind. !! !! Units : None contains procedure :: load => load_expt_nml procedure :: print => print_expt procedure :: save => save_expt end type contains subroutine load_expt_nml ( self , filename , verbose ) !! Loads `expt` parameters from a namelist. use info_messages use units use math_mod implicit none class ( expt_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error integer :: t ! namelist real ( dp ) :: E_threshold = 0.0_dp !! Energy threshold. Only events which deposit energy omega >= E_threshold will be considered. !! !! Units : eV real ( dp ) :: m_T_kg = 1.0_dp !! Mass of the target !! !! Units : kg real ( dp ) :: exposure_yr = 1.0_dp !! Total exposure of the experiment !! !! Units : year integer :: n_time = 1 !! Number of time of days to compute for real ( dp ) :: theta_E = 4 2.0_dp * ( pi / 18 0.0_dp ) NAMELIST / experiment / E_threshold , & m_T_kg , & exposure_yr , & n_time , & theta_E if ( verbose ) then print * , 'Loading the experimental parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = experiment , iostat = error ) rewind ( 100 ) self % E_threshold = E_threshold self % m_T_kg = m_T_kg self % m_T = kg_to_eV * m_T_kg self % exposure_yr = exposure_yr self % exposure = yr_to_inv_eV * exposure_yr self % n_time = n_time allocate ( self % times ( n_time )) allocate ( self % vE_direction ( n_time , 3 )) self % times = uniform_list ( n_time , 0.0_dp , 1.0_dp ) self % theta_E = theta_E do t = 1 , n_time self % vE_direction ( t , 1 ) = sin ( theta_E ) * sin ( 2.0_dp * pi * self % times ( t )) self % vE_direction ( t , 2 ) = cos ( theta_E ) * sin ( theta_E ) * ( cos ( 2.0_dp * pi * self % times ( t )) - 1.0_dp ) self % vE_direction ( t , 3 ) = (( sin ( theta_E ) ** 2 ) * cos ( 2.0_dp * pi * self % times ( t )) & + cos ( theta_E ) ** 2 ) end do call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for experimental parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine print_expt ( self , verbose ) !! Prints `expt` components. use info_messages class ( expt_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -----------------------' print * , '    Experimental Parameters' print * , '    -----------------------' print * print * , '        Energy threshold : ' , self % E_threshold , 'eV' print * print * , '        Mass             : ' , self % m_T_kg , 'kg' print * , '        Exposure Time    : ' , self % exposure_yr , 'year' print * print * , '        Times of the day : ' , trim ( adjustl ( int_to_str ( self % n_time ))) print * call print_section_seperator () print * end if end subroutine subroutine save_expt ( self , filename , verbose ) !! Saves `expt`. use hdf5 use h5lt use info_messages implicit none class ( expt_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving experimental parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'experiment' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'experiment/n_time' , size ( dims1 ), dims1 ,& self % n_time , error ) call h5ltmake_dataset_double_f ( file_id , 'experiment/E_threshold' , size ( dims1 ), dims1 ,& self % E_threshold , error ) dims1 = [ self % n_time ] call h5ltmake_dataset_double_f ( file_id , 'experiment/times' , size ( dims1 ), dims1 ,& self % times , error ) dims2 = [ self % n_time , 3 ] call h5ltmake_dataset_double_f ( file_id , 'experiment/vE_direction' , size ( dims2 ), dims2 ,& self % vE_direction , error ) call h5ltmake_dataset_double_f ( file_id , 'experiment/m_T' , size ( dims1 ), dims1 ,& self % m_T_kg , error ) call h5ltmake_dataset_double_f ( file_id , 'experiment/exposure' , size ( dims1 ), dims1 ,& self % exposure_yr , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' ) stop end if end subroutine end module","tags":"","loc":"sourcefile/expt_type.f90.html"},{"title":"in_med_scr_type.f90 – EXCEED-DM","text":"Contents Modules in_med_scr_type Source Code in_med_scr_type.f90 Source Code module in_med_scr_type !! Defines the `in_med_scr` type. use prec use constants implicit none type in_med_scr_t !! Collection of parameters defining how the DM-electron scattering rate !! should be screened. character ( len = 64 ) :: type = '' !! Type of screening to use !! !! Options: 'analytic', 'numeric' !! !! Will default to including no screening logical :: include_screen = . TRUE . !! Whether or not to include screening effects at all. real ( dp ) :: e0 !! Static dielectric parameter for analytic screening !! !!  \\epsilon(0)  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : None real ( dp ) :: q_tf !! Thomas Fermi momentum for analytic screening !! !!  q_\\text{TF}  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : eV real ( dp ) :: omega_p !! Plasma frequency for analytic screening !! !!  \\omega_p  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : eV real ( dp ) :: alpha !!  \\alpha  shape parameter for analytic screening !! !!  \\alpha  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : None integer :: n_E !! Number of  \\omega  bins. !! !! Numeric screening only. integer :: n_q !! Number of  q  bins. !! !! Numeric screening only. integer :: n_q_theta !! Number of  \\theta_q  bins. !! !! Numeric screening only. integer :: n_q_phi !! Number of  \\phi_q  bins !! !! Numeric screening only. real ( dp ) :: E_width !! Width of the  \\omega  bins. !! !! Numeric screening only. !! !! Units : eV real ( dp ) :: q_width !! Width of the  q  bins. !! !! Numeric screening only. !! !! Units : eV complex ( dp ), allocatable :: numeric_screen_mat (:, :, :, :) !! Dim : [ n_E, n_q, n_q_theta, n_q_phi ] !! !! Numerically computed screening matrix, binned in [  \\omega, q, \\theta_q, \\phi_q  ] !! !! Only used when `type = numeric`. !! !! Units : None complex ( dp ), allocatable :: numeric_anisotropic_screen_mat (:, :, :, :, :, :) !* Dim : [ n_E, n_q, n_q_theta, n_q_phi, 3, 3 ] ! ! Numerically computed anisotropic screening matrix, binned in [  \\omega, q, \\theta_q, \\phi_q  ]. This will be used ! if the input dielectric file is a 3  \\times  3 matrix in each bin. ! ! Only used when `type = numeric`. ! ! Units : None logical :: anisotropic_screen = . FALSE . !!Flag to check whether the loaded dielectric is a matrix or scalar quantity. If matrix -> True, if scalar -> False. contains procedure :: screening procedure :: analytic_screening procedure :: numeric_screening procedure :: load_in_med_scr_nml procedure :: load => load_in_med_scr procedure :: save => save_in_med_scr procedure :: print => print_in_med_scr procedure :: load_computed_dielectric end type contains subroutine save_in_med_scr ( self , filename , verbose ) !! Saves `in_med_scr`. use hdf5 use h5lt use info_messages implicit none class ( in_med_scr_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving in medium screening parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'screening' , group_id , error ) ! write data if ( self % include_screen ) then call h5ltmake_dataset_string_f ( file_id , & 'screening/type' , & self % type , & error ) if ( trim ( self % type ) == 'analytic' ) then call h5ltmake_dataset_double_f ( file_id , & 'screening/e0' , & size ( dims1 ), dims1 , & self % e0 , & error ) call h5ltmake_dataset_double_f ( file_id , & 'screening/q_tf' , & size ( dims1 ), dims1 , & self % q_tf , & error ) call h5ltmake_dataset_double_f ( file_id , & 'screening/omega_p' , & size ( dims1 ), dims1 , & self % omega_p , & error ) call h5ltmake_dataset_double_f ( file_id , & 'screening/alpha' , & size ( dims1 ), dims1 , & self % alpha , & error ) end if if ( trim ( self % type ) == 'numeric' ) then call h5ltmake_dataset_double_f ( file_id , & 'screening/q_width' , & size ( dims1 ), dims1 , & self % q_width , & error ) call h5ltmake_dataset_double_f ( file_id , & 'screening/E_width' , & size ( dims1 ), dims1 , & self % E_width , & error ) call h5ltmake_dataset_int_f ( file_id , & 'screening/n_E' , & size ( dims1 ), dims1 , & self % n_E , & error ) call h5ltmake_dataset_int_f ( file_id , & 'screening/n_q' , & size ( dims1 ), dims1 , & self % n_q , & error ) call h5ltmake_dataset_int_f ( file_id , & 'screening/n_q_theta' , & size ( dims1 ), dims1 , & self % n_q_theta , & error ) call h5ltmake_dataset_int_f ( file_id , & 'screening/n_q_phi' , & size ( dims1 ), dims1 , & self % n_q_phi , & error ) end if end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine print_in_med_scr ( self , verbose ) !! Prints `in_med_scr` components. use info_messages implicit none class ( in_med_scr_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    -------------------' print * , '    In-Medium Screening' print * , '    -------------------' print * print * , '        Screening type : ' , trim ( self % type ) print * print * , '        Include screening?         : ' , self % include_screen print * print * , '        Analytic screening parameters : ' print * , '            e0      : ' , self % e0 print * , '            q_tf    : ' , self % q_tf / 1.0e3_dp , 'keV' print * , '            omega_p : ' , self % omega_p , 'eV' print * , '            alpha   : ' , self % alpha print * call print_section_seperator () print * end if end subroutine subroutine load_in_med_scr_nml ( self , filename , verbose ) !! Loads `in_med_scr` parameters from a namelist. use info_messages implicit none class ( in_med_scr_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error character ( len = 64 ) :: type = '' !! Type of screening to use !! !! Options: 'analytic', 'numeric' !! !! Will default to including no screening logical :: include_screen = . FALSE . !! Whether or not to include screening effects at all. real ( dp ) :: e0 = 1.0_dp !! Static dielectric parameter for analytic screening !! !!  \\epsilon(0)  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : None real ( dp ) :: q_tf = 1.0e3_dp !! Thomas Fermi momentum for analytic screening !! !!  q_\\text{TF}  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : eV real ( dp ) :: omega_p = 1 0.0_dp !! Plasma frequency for analytic screening !! !!  \\omega_p  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : eV real ( dp ) :: alpha = 1.563_dp !!  \\alpha  shape parameter for analytic screening !! !!  \\alpha  in Eq 6 from [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) !! !! Units : None NAMELIST / in_med_scr / include_screen , & type , & e0 , & q_tf , & omega_p , & alpha if ( verbose ) then print * , 'Loading in medium screening parameters from the namelist file...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = in_med_scr , iostat = error ) close ( 100 ) self % include_screen = include_screen self % type = type self % e0 = e0 self % q_tf = q_tf self % omega_p = omega_p self % alpha = alpha call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for dielectric binning parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine load_computed_dielectric ( self , filename , verbose ) !! Load the pre-computed dielectric. use hdf5 use h5lt use info_messages implicit none class ( in_med_scr_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims4 ( 4 ) integer ( HSIZE_T ) :: dims6 ( 6 ) integer :: wfc_data_rank integer :: error real ( dp ), allocatable :: dielectric_buff (:, :, :, :) real ( dp ), allocatable :: anisotropic_dielectric_buff (:, :, :, :, :, :) if ( verbose ) then print * , 'Loading the dielectric from file...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) ! load binning parameters call h5ltread_dataset_int_f ( file_id , 'bins_dielectric/n_E' ,& self % n_E , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'bins_dielectric/n_q' ,& self % n_q , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'bins_dielectric/n_q_theta' ,& self % n_q_theta , dims1 , error ) call h5ltread_dataset_int_f ( file_id , 'bins_dielectric/n_q_phi' ,& self % n_q_phi , dims1 , error ) call h5ltread_dataset_double_f ( file_id , 'bins_dielectric/E_width' ,& self % E_width , dims1 , error ) call h5ltread_dataset_double_f ( file_id , 'bins_dielectric/q_width' ,& self % q_width , dims1 , error ) ! get the dimension of the dielectric dataset call h5ltget_dataset_ndims_f ( file_id , 'dielectric/dielectric_r' , wfc_data_rank , error ) if ( wfc_data_rank == 4 ) then dims4 = [ self % n_E , self % n_q , self % n_q_theta , self % n_q_phi ] allocate ( dielectric_buff ( self % n_E , self % n_q , self % n_q_theta , self % n_q_phi )) allocate ( self % numeric_screen_mat ( self % n_E , self % n_q , self % n_q_theta , self % n_q_phi )) self % numeric_screen_mat = ( 0.0_dp , 0.0_dp ) call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_r' ,& dielectric_buff , dims4 , error ) self % numeric_screen_mat = self % numeric_screen_mat + dielectric_buff call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_c' ,& dielectric_buff , dims4 , error ) self % numeric_screen_mat = self % numeric_screen_mat + ii * dielectric_buff else self % anisotropic_screen = . TRUE . ! load the anisotropic dielectric dims6 = [ self % n_E , self % n_q , self % n_q_theta , self % n_q_phi , 3 , 3 ] allocate ( anisotropic_dielectric_buff ( self % n_E , self % n_q , self % n_q_theta , self % n_q_phi , 3 , 3 )) allocate ( self % numeric_anisotropic_screen_mat ( self % n_E , self % n_q , self % n_q_theta , self % n_q_phi , 3 , 3 )) self % numeric_anisotropic_screen_mat = ( 0.0_dp , 0.0_dp ) call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_r' ,& anisotropic_dielectric_buff , dims6 , error ) self % numeric_anisotropic_screen_mat = self % numeric_anisotropic_screen_mat + anisotropic_dielectric_buff call h5ltread_dataset_double_f ( file_id , 'dielectric/dielectric_c' ,& anisotropic_dielectric_buff , dims6 , error ) self % numeric_anisotropic_screen_mat = self % numeric_anisotropic_screen_mat + ii * anisotropic_dielectric_buff end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Input file for dielectric : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if if ( verbose ) then print * , 'Done loading the dielectric from file!' print * end if end subroutine subroutine load_in_med_scr ( self , proc_id , root_process , n_proc , & io_files , main_control , target_mat , verbose ) !! Loads the in medium screening parameters. If the user specifies !! that the screening should be computed numerically then `exdm_dielectric` will !! be run. use mpi use hdf5 use h5lt use io_input use control_input use material_type use exdm_dielectric implicit none class ( in_med_scr_t ) :: self integer :: proc_id , root_process , n_proc type ( io_files_t ) :: io_files type ( control_t ) :: main_control type ( material_t ) :: target_mat logical , optional :: verbose logical :: file_exists integer ( HID_T ) :: file_id integer :: error integer :: err integer :: n_E , n_q , n_q_theta , n_q_phi real ( dp ) :: E_width , q_width logical :: anis_bool = . FALSE . complex ( dp ), allocatable :: screen_mat (:, :, :, :) complex ( dp ), allocatable :: anis_screen_mat (:, :, :, :, :, :) call self % load_in_med_scr_nml ( io_files % nml_input_filename , verbose = verbose ) inquire ( file = io_files % dielectric_filename , exist = file_exists ) ! If the user wants to use the numerically computed screening factor AND include_screen = .TRUE. ! AND the file doesn't already exist, compute dielectric. if ( ( trim ( self % type ) == 'numeric' ) . and . ( self % include_screen ) ) then if ( . not . file_exists ) then if ( verbose ) then print * , 'Dielectric file does NOT exist. Computing from scratch...' print * end if if ( proc_id == root_process ) then ! create the file call h5open_f ( error ) call h5fcreate_f ( io_files % dielectric_filename , H5F_ACC_TRUNC_F , file_id , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) end if ! compute the dielectric call run_exdm_dielectric ( proc_id , root_process , n_proc , io_files , & main_control , target_mat , verbose = verbose ) end if ! load the dielectric, bcast relevant screen_mat data to all processors if ( proc_id == root_process ) then call self % load_computed_dielectric ( io_files % dielectric_filename , verbose = verbose ) n_E = self % n_E n_q = self % n_q n_q_theta = self % n_q_theta n_q_phi = self % n_q_phi E_width = self % E_width q_width = self % q_width anis_bool = self % anisotropic_screen end if call MPI_Bcast ( n_E , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( n_q , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( n_q_theta , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( n_q_phi , 1 , MPI_INTEGER , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( E_width , 1 , MPI_DOUBLE , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( q_width , 1 , MPI_DOUBLE , root_process ,& MPI_COMM_WORLD , err ) call MPI_Bcast ( anis_bool , 1 , MPI_LOGICAL , root_process ,& MPI_COMM_WORLD , err ) if ( proc_id /= root_process ) then self % n_E = n_E self % n_q = n_q self % n_q_theta = n_q_theta self % n_q_phi = n_q_phi self % E_width = E_width self % q_width = q_width self % anisotropic_screen = anis_bool if ( self % anisotropic_screen ) then allocate ( self % numeric_anisotropic_screen_mat (& self % n_E ,& self % n_q ,& self % n_q_theta ,& self % n_q_phi ,& 3 , 3 )) else ! allocate screen_mat allocate ( self % numeric_screen_mat ( self % n_E , & self % n_q , self % n_q_theta , self % n_q_phi )) end if end if if ( self % anisotropic_screen ) then allocate ( anis_screen_mat ( n_E , n_q , n_q_theta , n_q_phi , 3 , 3 )) else allocate ( screen_mat ( n_E , n_q , n_q_theta , n_q_phi )) end if if ( proc_id == root_process ) then if ( self % anisotropic_screen ) then anis_screen_mat = self % numeric_anisotropic_screen_mat else screen_mat = self % numeric_screen_mat end if end if if ( self % anisotropic_screen ) then call MPI_Bcast ( anis_screen_mat , size ( anis_screen_mat ), MPI_DOUBLE_COMPLEX , & root_process , MPI_COMM_WORLD , err ) else call MPI_Bcast ( screen_mat , size ( screen_mat ), MPI_DOUBLE_COMPLEX , & root_process , MPI_COMM_WORLD , err ) end if if ( proc_id /= root_process ) then if ( self % anisotropic_screen ) then self % numeric_anisotropic_screen_mat = anis_screen_mat else self % numeric_screen_mat = screen_mat end if end if end if end subroutine function numeric_screening ( self , q_vec , omega ) result ( scr ) !! Absolute value of the numerically computed dielectric. use math_mod implicit none class ( in_med_scr_t ) :: self real ( dp ) :: q_vec ( 3 ) real ( dp ) :: omega real ( dp ) :: q_mag real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_theta , q_phi integer :: w_bin , q_bin , q_theta_bin , q_phi_bin real ( dp ) :: scr q_mag = norm2 ( q_vec ) scr = 1.0_dp if ( q_mag >= 1.0e-8_dp ) then q_hat = q_vec / q_mag q_theta = get_theta ( q_hat ) q_phi = get_phi ( q_hat ) w_bin = 1 + floor ( omega / self % E_width ) q_bin = 1 + floor ( q_mag / self % q_width ) q_theta_bin = Q_func ( q_theta , 0.0_dp ,& pi / max ( 1.0_dp , 1.0_dp * self % n_q_theta ), self % n_q_theta ) q_phi_bin = Q_func ( q_phi , 0.0_dp ,& 2.0_dp * pi / max ( 1.0_dp , 1.0_dp * self % n_q_phi ), self % n_q_phi ) if ( ( w_bin <= self % n_E ) . and . & ( q_bin <= self % n_q ) . and . & ( q_theta_bin <= self % n_q_theta ) . and . & ( q_phi_bin <= self % n_q_phi ) ) then if ( self % anisotropic_screen ) then scr = abs (& dot_product ( q_hat ,& matmul ( self % numeric_anisotropic_screen_mat (& w_bin ,& q_bin ,& q_theta_bin ,& q_phi_bin , :, :), q_hat & )& )& ) else scr = abs ( self % numeric_screen_mat ( w_bin , & q_bin , q_theta_bin , q_phi_bin ) ) end if end if end if end function function analytic_screening ( self , q_vec , omega ) result ( scr ) !! Analytic form of the dielectric function. !! !! Eq 6 in [https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892](https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892) implicit none class ( in_med_scr_t ) :: self real ( dp ) :: q_vec ( 3 ) real ( dp ) :: omega real ( dp ) :: q_mag real ( dp ) :: scr q_mag = norm2 ( q_vec ) scr = 1.0_dp + ( ( self % e0 - 1.0_dp ) ** ( - 1 ) + & self % alpha * ( q_mag / self % q_tf ) ** 2 + & q_mag ** 4 / ( 4 * m_elec ** 2 * self % omega_p ** 2 ) - & ( omega / self % omega_p ) ** 2 ) ** ( - 1 ) end function function screening ( self , q_vec , omega ) result ( scr ) !! Screening factor in scattering rate calculations. !! !!  R \\sim 1/text{scr}&#94;2  implicit none class ( in_med_scr_t ) :: self real ( dp ) :: q_vec ( 3 ) real ( dp ) :: omega real ( dp ) :: q_mag real ( dp ) :: q_hat ( 3 ) real ( dp ) :: q_theta , q_phi integer :: w_bin_num , q_bin_num , q_theta_bin_num , q_phi_bin_num real ( dp ) :: scr scr = 1.0_dp if ( self % include_screen ) then if ( trim ( self % type ) == 'analytic' ) then scr = self % analytic_screening ( q_vec , omega ) end if if ( trim ( self % type ) == 'numeric' ) then scr = self % numeric_screening ( q_vec , omega ) end if end if end function end module","tags":"","loc":"sourcefile/in_med_scr_type.f90.html"},{"title":"material_type.f90 – EXCEED-DM","text":"Contents Modules material_type Source Code material_type.f90 Source Code module material_type !! Defines the `material` type. use hdf5 use h5lt use info_messages use prec use units implicit none type material_t !! Target material properties. character ( len = 64 ) :: name = '' !! Material name real ( dp ) :: pc_vol_A !! Volume of the unit cell !! !! pc_vol_A = det(a_vecs) !! !! Units : Ang&#94;3 real ( dp ) :: pc_vol !! Volume of the primitive cell !! !! Units : eV&#94;(-3) real ( dp ) :: rho_T_g_per_cm3 !! Target density !! !! Units : g/cm&#94;3 real ( dp ) :: rho_T !! Target density !! !! Units : eV&#94;4 real ( dp ) :: band_gap = 0.0_dp !! Band gap of the target !! !! Units : eV contains procedure :: load => load_material_nml procedure :: print => print_material procedure :: save => save_material end type contains subroutine print_material ( self , verbose ) !! Prints `material` components. implicit none class ( material_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    --------' print * , '    Material' print * , '    --------' print * print * , '        Name      : ' , trim ( self % name ) print * , '        Band gap  : ' , self % band_gap , 'eV' print * , '        Density   : ' , self % rho_T_g_per_cm3 , 'g/cm&#94;3' print * , '        PC volume : ' , self % pc_vol_A , 'Ang&#94;3' print * call print_section_seperator () print * end if end subroutine subroutine load_material_nml ( self , filename , verbose ) !! Loads `material` parameters from a namelist. implicit none class ( material_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error character ( len = 64 ) :: name = '' real ( dp ) :: pc_vol_A !! Volume of the unit cell !! !! pc_vol_A = det(a_vecs) !! !! Units : Ang&#94;3 real ( dp ) :: rho_T_g_per_cm3 !! Target density !! !! Units : g/cm&#94;3 real ( dp ) :: band_gap = 0.0_dp !! Band gap of the target !! !! Units : eV NAMELIST / material / pc_vol_A , & band_gap , & rho_T_g_per_cm3 , & name if ( verbose ) then print * , 'Loading material parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = material , iostat = error ) close ( 100 ) if ( error /= 0 ) then call print_error_message (& 'Problem reading material namelist.' , & verbose = verbose ) stop end if self % name = name self % pc_vol_A = pc_vol_A self % band_gap = band_gap self % rho_T_g_per_cm3 = rho_T_g_per_cm3 self % rho_T = g_to_eV * inv_cm_to_eV ** 3 * rho_T_g_per_cm3 self % pc_vol = Ang_to_inv_eV ** 3 * pc_vol_A call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for material parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine save_material ( self , filename , verbose ) !! Saves `material`. implicit none class ( material_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer :: error if ( verbose ) then print * , 'Saving material parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'material' , group_id , error ) ! write data call h5ltmake_dataset_string_f ( file_id , & 'material/name' , & self % name , & error ) call h5ltmake_dataset_double_f ( file_id , & 'material/band_gap' , & size ( dims1 ), dims1 , & self % band_gap , & error ) call h5ltmake_dataset_double_f ( file_id , & 'material/density' , & size ( dims1 ), dims1 , & self % rho_T_g_per_cm3 , & error ) call h5ltmake_dataset_double_f ( file_id , & 'material/pc_vol' , & size ( dims1 ), dims1 , & self % pc_vol_A , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/material_type.f90.html"},{"title":"PW_dataset_type.f90 – EXCEED-DM","text":"Contents Modules PW_dataset_type Source Code PW_dataset_type.f90 Source Code module PW_dataset_type !! Defines the `PW_dataset` type. use h5lt use hdf5 use prec use constants use units use info_messages implicit none type PW_dataset_t !! Stores the metadata of the Bloch wave function coefficients in the Fourier basis, !! \\widetilde{u}_{i, \\mathbf{k}, \\mathbf{G}} , e.g. number of  \\mathbf{k}  points,  N_\\mathbf{k}  !! , number of bands, etc and has routines which load the coefficients from an external data file when needed. !! !! \\begin{align} !! \\psi_{i, \\mathbf{k}}(\\mathbf{x}) = \\frac{1}{\\sqrt{V}} !! \\sum_\\mathbf{G} \\widetilde{u}_{i, \\mathbf{k}, \\mathbf{G}} e&#94;{i (\\mathbf{k} + \\mathbf{G}) \\cdot \\mathbf{x}} !! \\nonumber !! \\end{align}. integer :: n_k !! Number of k points integer :: n_val !! Number of valence bands integer :: n_cond !! Number of conduction bands integer :: n_G !! Number of G points integer , allocatable :: G_grid_red (:, :) !! Dim : [n_G, 3] !! !! G vectors in reduced coordinates. !! !! Note : This G grid is k-independent and assumes that the  \\widetilde{u} 's, !! for each  \\mathbf{k} , are defined on the same grid. !! !! Units : None real ( dp ) :: a_vecs_A ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : Ang real ( dp ) :: b_vecs_A ( 3 , 3 ) !! Reciprocal lattice vector !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : Ang&#94;(-1) real ( dp ), allocatable :: k_weight (:) !! Dim : [n_k] !! !! Weights of each k point in the k_red grid, must sum to 2 !! !! Units : None real ( dp ), allocatable :: k_grid_red (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in reduced coordinates !! !! Units : None real ( dp ), allocatable :: energy_bands_raw (:, :) !! Dim : [n_k, n_bands] !! !! Electron energy eigenvalues taken straight from the input file, no scissor !! correction performed. !! !! Units : eV real ( dp ) :: Ef_max = 6 0.0_dp !! Maximum electron energy computed for. !! !! Units : eV ! generated from input integer :: n_bands !! Total number of bands !! !! n_bands = n_cond + n_val real ( dp ) :: q_cut !! Plane wave expansion cutoff !! !!  \\text{max} (| \\mathbf{k} + \\mathbf{G} |)  !! !! Units : eV real ( dp ) :: E_cut !! Energy cooresponding to q_cut !! !! E_cut = q_cut**2/(2*m_elec) !! !! Units : eV real ( dp ) :: a_vecs ( 3 , 3 ) !! Primitive lattice vectors !! !! (i, :) is the ith primitive lattice vector !! !! Units : eV&#94;(-1) real ( dp ) :: red_to_xyz ( 3 , 3 ) !! Matrix converting reduced cooredinate positions to physical xyz cooredinates !! in eV&#94;(-1) via !! !!      x_xyz = matmul(red_to_xyz, x_red) !! !! red_to_xyz = transpose(a_vecs) !! !! Units : eV&#94;(-1) real ( dp ) :: b_vecs ( 3 , 3 ) !! Reciprocal lattice vectors !! !! (i, :) is the ith reciprocal lattice vector !! !! Units : eV real ( dp ) :: k_red_to_xyz ( 3 , 3 ) !! Matrix converting reduced coordinate momentum to physical xyz coordinates !! in eV via !! !!      k_xyz = matmul(k_red_to_xyz, k_red) !! !! k_red_to_xyz = transpose(b_vecs) !! !! Units : eV real ( dp ), allocatable :: energy_bands (:, :) !! Dim : [n_k, n_bands] !! !! Scissor corrected electron energy eigenvalues !! !! Units : eV real ( dp ), allocatable :: G_grid_xyz (:, :) !! Dim : [`n_G`, 3] !! !! G vectors in physical xyz coordinates !! !! Units : eV real ( dp ), allocatable :: k_grid_xyz (:, :) !! Dim : [n_k, 3] !! !! List of k vectors in xyz coordinates !! !! Units : eV logical :: include_spin = . FALSE . !! Flag declaring whether the wave functions are spin dependent or not real ( dp ) :: spin_degen = 2.0_dp !! Spin degeneracy factor. !! !! SI wave functions - 2 !! SD wave functions - 1 character ( len = 512 ) :: filename !! Filename of data real ( dp ) :: q_max_1BZ !* All transitions with  q \\leq  `q_max_1BZ` are restricted to stay within the 1BZ. ! ! Units :  \\text{eV}  contains procedure :: load => load_PW_dataset_hdf5 procedure :: save => save_PW_dataset procedure :: print => print_PW_dataset procedure :: load_wfc_FT_ik_no_spin procedure :: load_wfc_ik_expanded_no_spin procedure :: load_wfc_FT_ik_spin procedure :: load_wfc_ik_expanded_spin procedure :: compute_PW_cutoff procedure :: do_scissor_correction end type contains subroutine load_wfc_ik_expanded_no_spin ( self , i , k , FFT_grid , wfc_ik ) !! Loads the spin independent wave function coefficients,  \\widetilde{u}  !! for a given  i, \\mathbf{k} , expands (zero-pads), then Fourier transforms them to get  u . use FFT_util implicit none class ( PW_dataset_t ) :: self integer :: i , k type ( FFT_grid_t ) :: FFT_grid complex ( dp ) :: wfc_ik ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) complex ( dp ) :: wfc_FT_ik ( self % n_G ) complex ( dp ) :: wfc_FT_ik_expanded ( FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) integer :: idx ( 3 ) integer :: g call self % load_wfc_FT_ik_no_spin ( i , k , wfc_FT_ik ) wfc_FT_ik_expanded = ( 0.0_dp , 0.0_dp ) do g = 1 , self % n_G call G_red_to_FFT_G_grid_index ( FFT_grid % n_grid , self % G_grid_red ( g , :), idx ) wfc_FT_ik_expanded ( idx ( 1 ), idx ( 2 ), idx ( 3 )) = wfc_FT_ik ( g ) end do ! Fourier transform call dfftw_execute_dft ( FFT_grid % plan , wfc_FT_ik_expanded , wfc_ik ) end subroutine subroutine load_wfc_ik_expanded_spin ( self , i , k , FFT_grid , wfc_ik ) !! Loads the spin dependent wave function coefficients,  \\widetilde{u}  !! for a given  i, \\mathbf{k} , expands (zero-pads), then Fourier transforms them to get  u . use FFT_util implicit none class ( PW_dataset_t ) :: self integer :: i , k type ( FFT_grid_t ) :: FFT_grid complex ( dp ) :: wfc_ik ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) complex ( dp ) :: wfc_FT_ik ( self % n_G , 2 ) complex ( dp ) :: wfc_FT_ik_expanded ( 2 , FFT_grid % n_grid ( 1 ), FFT_grid % n_grid ( 2 ), FFT_grid % n_grid ( 3 )) integer :: idx ( 3 ) integer :: g , s call self % load_wfc_FT_ik_spin ( i , k , wfc_FT_ik ) wfc_FT_ik_expanded = ( 0.0_dp , 0.0_dp ) do g = 1 , self % n_G call G_red_to_FFT_G_grid_index ( FFT_grid % n_grid , self % G_grid_red ( g , :), idx ) wfc_FT_ik_expanded (:, idx ( 1 ), idx ( 2 ), idx ( 3 )) = wfc_FT_ik ( g , :) end do ! Fourier transform do s = 1 , 2 call dfftw_execute_dft ( FFT_grid % plan , wfc_FT_ik_expanded ( s , :, :, :), wfc_ik ( s , :, :, :)) end do end subroutine subroutine load_wfc_FT_ik_no_spin ( self , i , k , wfc_FT_ik ) !! Loads the spin independent Bloch coefficients,  \\widetilde{u}_{ i, \\mathbf{k}, \\mathbf{G}}  !! for a given  i, \\mathbf{k} . implicit none class ( PW_dataset_t ) :: self integer :: i , k complex ( dp ) :: wfc_FT_ik (:) !! Dim : [n_G] real ( dp ) :: wfc_FT_ik_r ( self % n_G ) !! real part of the bloch wave functions in fourier space real ( dp ) :: wfc_FT_ik_c ( self % n_G ) !! complex part of the bloch wave functions in fourier space integer ( HSIZE_T ) :: dims ( 1 ) integer ( HID_T ) :: file_id !! HDF5 file ID number for DFT input file integer :: error character ( len = 64 ) :: dataset_path_r character ( len = 64 ) :: dataset_path_c dataset_path_r = 'wfc_FT_r' // & '/i_' // trim ( adjustl ( int_to_str ( i ))) // & '/k_' // trim ( adjustl ( int_to_str ( k ))) dataset_path_c = 'wfc_FT_c' // & '/i_' // trim ( adjustl ( int_to_str ( i ))) // & '/k_' // trim ( adjustl ( int_to_str ( k ))) dims = [ self % n_G ] call h5open_f ( error ) call h5fopen_f ( self % filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_r , wfc_FT_ik_r , dims , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_c , wfc_FT_ik_c , dims , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) wfc_FT_ik = wfc_FT_ik_r + ii * wfc_FT_ik_c end subroutine subroutine load_wfc_FT_ik_spin ( self , i , k , wfc_FT_ik ) !! Loads the spin dependent Bloch coefficients,  \\widetilde{u}_{ i, \\mathbf{k}, \\mathbf{G}, s}  !! for a given  i, \\mathbf{k} . implicit none class ( PW_dataset_t ) :: self integer :: i , k complex ( dp ) :: wfc_FT_ik (:, :) !! Dim : [n_G, 2] real ( dp ) :: wfc_FT_ik_r ( self % n_G , 2 ) !! real part of the bloch wave functions in fourier space real ( dp ) :: wfc_FT_ik_c ( self % n_G , 2 ) !! complex part of the bloch wave functions in fourier space integer ( HSIZE_T ) :: dims ( 2 ) integer ( HID_T ) :: file_id !! HDF5 file ID number for DFT input file integer :: error character ( len = 64 ) :: dataset_path_r character ( len = 64 ) :: dataset_path_c dataset_path_r = 'wfc_FT_r' // & '/i_' // trim ( adjustl ( int_to_str ( i ))) // & '/k_' // trim ( adjustl ( int_to_str ( k ))) dataset_path_c = 'wfc_FT_c' // & '/i_' // trim ( adjustl ( int_to_str ( i ))) // & '/k_' // trim ( adjustl ( int_to_str ( k ))) dims = [ self % n_G , 2 ] call h5open_f ( error ) call h5fopen_f ( self % filename , H5F_ACC_RDONLY_F , file_id , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_r , wfc_FT_ik_r , dims , error ) call h5ltread_dataset_double_f ( file_id , dataset_path_c , wfc_FT_ik_c , dims , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) wfc_FT_ik = wfc_FT_ik_r + ii * wfc_FT_ik_c end subroutine subroutine load_PW_dataset_hdf5 ( self , filename , verbose ) !! Loads `PW_dataset` parameters from an hdf5 file. use math_mod implicit none class ( PW_dataset_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id logical :: file_exists integer ( HSIZE_T ) :: dims ( 1 ) = [ 0 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error integer :: g , k integer :: wfc_data_rank if ( verbose ) then print * , 'Loading PW dataset input file...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , error ) self % filename = filename ! read the data call h5ltread_dataset_int_f ( file_id , 'n_k' , self % n_k , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_val' , self % n_val , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_cond' , self % n_cond , dims , error ) self % n_bands = self % n_val + self % n_cond call h5ltread_dataset_double_f ( file_id , 'Ef_max' , self % Ef_max , dims , error ) call h5ltread_dataset_int_f ( file_id , 'n_G' , self % n_G , dims , error ) allocate ( self % G_grid_red ( self % n_G , 3 )) dims2 = [ self % n_G , 3 ] call h5ltread_dataset_int_f ( file_id , 'G_grid_red' , self % G_grid_red , dims2 , error ) dims2 = [ 3 , 3 ] call h5ltread_dataset_double_f ( file_id , 'a_vecs_A' , self % a_vecs_A , dims2 , error ) self % a_vecs = Ang_to_inv_eV * self % a_vecs_A self % red_to_xyz = transpose ( self % a_vecs ) call h5ltread_dataset_double_f ( file_id , 'b_vecs_A' , self % b_vecs_A , dims2 , error ) self % b_vecs = inv_Ang_to_eV * self % b_vecs_A self % k_red_to_xyz = transpose ( self % b_vecs ) self % q_max_1BZ = get_q_max_1BZ ( self % k_red_to_xyz , verbose = verbose ) ! convert reduced coordinates to xyz allocate ( self % G_grid_xyz ( self % n_G , 3 )) do g = 1 , self % n_G self % G_grid_xyz ( g , :) = matmul ( self % k_red_to_xyz , self % G_grid_red ( g , :)) end do allocate ( self % k_weight ( self % n_k )) dims = [ self % n_k ] call h5ltread_dataset_double_f ( file_id , 'k_weight' , self % k_weight , dims , error ) allocate ( self % k_grid_red ( self % n_k , 3 )) dims2 = [ self % n_k , 3 ] call h5ltread_dataset_double_f ( file_id , 'k_grid_red' , self % k_grid_red , dims2 , error ) allocate ( self % k_grid_xyz ( self % n_k , 3 )) do k = 1 , self % n_k self % k_grid_xyz ( k , :) = matmul ( self % k_red_to_xyz , self % k_grid_red ( k , :)) end do allocate ( self % energy_bands_raw ( self % n_k , self % n_bands )) allocate ( self % energy_bands ( self % n_k , self % n_bands )) dims2 = [ self % n_k , self % n_bands ] call h5ltread_dataset_double_f ( file_id , 'energy_bands' , self % energy_bands_raw , dims2 , error ) call h5ltget_dataset_ndims_f ( file_id , 'wfc_FT_c/i_1/k_1' , wfc_data_rank , error ) if ( wfc_data_rank == 2 ) then self % include_spin = . TRUE . self % spin_degen = 1.0_dp end if call h5fclose_f ( file_id , error ) call h5close_f ( error ) ! call check_DFT_parameters(verbose) call self % compute_PW_cutoff () call self % print ( filename , verbose = verbose ) else call print_error_message ( 'Input file for PW dataset : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine save_PW_dataset ( self , filename , verbose ) !! Saves `PW_dataset`. implicit none class ( PW_dataset_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id , group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) = [ 3 , 3 ] integer :: error if ( verbose ) then print * , 'Saving PW dataset parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'PW_dataset' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'PW_dataset/n_val' , & size ( dims1 ), dims1 ,& self % n_val , & error ) call h5ltmake_dataset_int_f ( file_id , & 'PW_dataset/n_cond' , & size ( dims1 ), dims1 ,& self % n_cond , & error ) call h5ltmake_dataset_int_f ( file_id , & 'PW_dataset/n_bands' , & size ( dims1 ), dims1 ,& self % n_bands , & error ) call h5ltmake_dataset_int_f ( file_id , & 'PW_dataset/n_k' , & size ( dims1 ), dims1 ,& self % n_k , & error ) call h5ltmake_dataset_int_f ( file_id , & 'PW_dataset/n_G' , & size ( dims1 ), dims1 ,& self % n_G , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/q_max_1BZ' , & size ( dims1 ), dims1 ,& self % q_max_1BZ , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/E_cut' , & size ( dims1 ), dims1 ,& self % E_cut , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/Ef_max' , & size ( dims1 ), dims1 ,& self % Ef_max , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/q_cut' , & size ( dims1 ), dims1 ,& self % q_cut , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/spin_degen' , & size ( dims1 ), dims1 ,& self % spin_degen , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/k_red_to_xyz' , & size ( dims2 ), dims2 ,& self % k_red_to_xyz , & error ) call h5ltmake_dataset_double_f ( file_id , & 'PW_dataset/red_to_xyz' , & size ( dims2 ), dims2 ,& self % red_to_xyz , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine ! subroutine check_DFT_parameters(verbose) !     !! Check the values of of the input file to make sure they make sense !     implicit none !     logical, optional :: verbose !     real(dp), parameter :: pi = 4.0_dp*datan(1.0_dp) !     real(dp) :: i_3_2pi(3, 3) !     real(dp) :: eps_val !     if ( verbose ) then !         print*, 'Running preliminary checks on DFT data...' !         print* !     end if !     i_3_2pi = 0.0_dp !     i_3_2pi(1, 1) = 2*pi !     i_3_2pi(2, 2) = 2*pi !     i_3_2pi(3, 3) = 2*pi !     ! a_i . b_j = 2*pi delta_ij !     eps_val = abs(sum(matmul(transpose(k_red_to_xyz), red_to_xyz) - i_3_2pi)/3.0_dp) !     if ( eps_val > 1e-3_dp ) then !         print*, '!! ERROR !!' !         print* !         print*, '   Basis vectors are not orthonormalized correctly. a_i . b_j != 2 pi delta_ij' !         print* !         print*, '!!!!!!!!!!!' !         print* !         stop !     end if !     ! sum_k k_weight(k) = 2 !     eps_val = sum(k_weight) - 2.0_dp !     if ( eps_val > 1e-3_dp ) then !         print*, '!! ERROR !!' !         print* !         print*, '   Sum of k weights != 2' !         print* !         print*, '!!!!!!!!!!!' !         print* !         stop !     end if ! end subroutine subroutine print_PW_dataset ( self , filename , verbose ) !! Prints `PW_dataset` components. implicit none class ( PW_dataset_t ) :: self character ( len =* ) :: filename logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ----------' print * , '    PW dataset' print * , '    ----------' print * print * , '        Filename : ' , trim ( filename ) print * print * , '        Primitive lattice vectors (Ang) : ' print * , '            a1 = ' , self % a_vecs_A ( 1 , :) print * , '            a2 = ' , self % a_vecs_A ( 2 , :) print * , '            a3 = ' , self % a_vecs_A ( 3 , :) print * print * , '        Reciprocal lattice vectors Ang&#94;(-1) : ' print * , '            b1 = ' , self % b_vecs_A ( 1 , :) print * , '            b2 = ' , self % b_vecs_A ( 2 , :) print * , '            b3 = ' , self % b_vecs_A ( 3 , :) print * print * , '        Number of valence bands     = ' , trim ( adjustl ( int_to_str ( self % n_val ))) print * , '        Number of conduction bands  = ' , trim ( adjustl ( int_to_str ( self % n_cond ))) print * print * , '        Number of k points          = ' , trim ( adjustl ( int_to_str ( self % n_k ))) print * , '        Number of G points          = ' , trim ( adjustl ( int_to_str ( self % n_G ))) print * print * , '        E_cut  = ' , self % E_cut , 'eV' print * , '        q_cut  = ' , self % q_cut / 1.0e3_dp , 'keV' print * print * , '        Ef_max = ' , self % Ef_max , 'eV' print * print * , '        Include spin?               = ' , self % include_spin print * call print_section_seperator () print * end if end subroutine subroutine compute_PW_cutoff ( self ) !! Computes plane wave expansion parameters,  q_\\text{cut}  and  E_\\text{cut} . implicit none class ( PW_dataset_t ) :: self integer :: k , g real ( dp ) :: q_xyz ( 3 ) real ( dp ) :: q_mag self % q_cut = 0.0_dp self % E_cut = 0.0_dp do k = 1 , self % n_k do g = 1 , self % n_G q_xyz = self % k_grid_xyz ( k , :) + self % G_grid_xyz ( g , :) q_mag = norm2 ( q_xyz ) if ( q_mag >= self % q_cut ) then self % q_cut = q_mag end if end do end do self % E_cut = self % q_cut ** 2 / ( 2.0_dp * m_elec ) end subroutine subroutine do_scissor_correction ( self , band_gap , verbose ) !! Performs a scissor correction to the band structure. This shifts the valence and conduction !! bands independently such that  \\text{min} E_{\\text{cond}, \\mathbf{k}} - \\text{max} E_{\\text{val}, \\mathbf{k}} =  !!` band_gap`. !! !! Additionally, shifts all of the bands by a constant value such that the valence band maximum,  \\text{max} !! E_{\\text{val}, \\mathbf{k}} , is equal to 0. implicit none class ( PW_dataset_t ) :: self real ( dp ) :: band_gap logical , optional :: verbose real ( dp ) :: scissor_correct ! scissor correct band structure scissor_correct = band_gap - & ( minval ( self % energy_bands_raw (:, self % n_val + 1 :)) - & maxval ( self % energy_bands_raw (:, : self % n_val ))) self % energy_bands = 0.0_dp self % energy_bands (:, : self % n_val ) = self % energy_bands_raw (:, : self % n_val ) - scissor_correct / 2.0_dp self % energy_bands (:, self % n_val + 1 :) = self % energy_bands_raw (:, self % n_val + 1 :) + scissor_correct / 2.0_dp ! shift valence band maximum to 0 by shifting the whole band structure self % energy_bands = self % energy_bands - maxval ( self % energy_bands (:, self % n_val )) if ( verbose ) then print * , 'Performed scissor correction.' print * end if end subroutine end module","tags":"","loc":"sourcefile/pw_dataset_type.f90.html"},{"title":"width_parameters_type.f90 – EXCEED-DM","text":"Contents Modules width_parameters_type Source Code width_parameters_type.f90 Source Code module width_parameters_type !! Defines the `width_parameters` type. use prec implicit none type width_parameters_t !! Electron lifetime/widths to use in calculations which require the electronic Green's !! functions (e.g. absorption calculations). width's are parameterized as !! !! \\begin{align*} !!      \\delta(\\omega) = \\text{min}\\left( \\delta_\\text{max}, a + b \\omega \\right) !! \\end{align*} !! !! and we require that  |\\omega - \\omega_{ii'}| < \\sigma \\delta(\\omega) . integer :: n = 1 !! Total number of width parameters. !! !! `n` = `n_a` x `n_b` x `n_m` integer :: n_a = 1 !! Number of  a  parameters. integer :: n_b = 1 !! Number of  b  parameters. integer :: n_m = 1 !! Number of  \\delta_\\text{max}  parameters. real ( dp ) :: a_min !! Minimum  a  parameter. !! !! Units : eV real ( dp ) :: a_max !! Minimum  a  parameter. !! !! Units : eV real ( dp ) :: log_b_min !! Log10 of the minimum  b  parameter. real ( dp ) :: log_b_max !! Log10 of the maximum  b  parameter. real ( dp ) :: m_max !! Maximum  \\delta_\\text{max}  parameter. !! !! Units : eV real ( dp ) :: m_min !! Minimum  \\delta_\\text{max}  parameter. !! !! Units : eV real ( dp ) :: sigma = 1 D10 !!  \\sigma  parameter, energy difference must be within  \\sigma \\delta  to be !! added to the rate. real ( dp ), allocatable :: info (:, :) !! Dim : [`n`, 3] !! !! Width parameters [a, b, delta_max]. contains procedure :: load => load_width_parameters_nml procedure :: save => save_width_parameters procedure :: print => print_width_parameters procedure :: get_width end type contains subroutine save_width_parameters ( self , filename , verbose ) !! Saves `width_parameters`. use hdf5 use h5lt use info_messages implicit none class ( width_parameters_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 2 ) integer :: error if ( verbose ) then print * , 'Saving width parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'widths' , group_id , error ) ! ! write data call h5ltmake_dataset_int_f ( file_id , 'widths/n_a' ,& size ( dims1 ), dims1 ,& self % n_a , error ) call h5ltmake_dataset_int_f ( file_id , 'widths/n_b' ,& size ( dims1 ), dims1 ,& self % n_b , error ) call h5ltmake_dataset_int_f ( file_id , 'widths/n_m' ,& size ( dims1 ), dims1 ,& self % n_m , error ) call h5ltmake_dataset_int_f ( file_id , 'widths/n' ,& size ( dims1 ), dims1 ,& self % n , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/a_min' ,& size ( dims1 ), dims1 ,& self % a_min , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/a_max' ,& size ( dims1 ), dims1 ,& self % a_max , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/log_b_min' ,& size ( dims1 ), dims1 ,& self % log_b_min , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/log_b_max' ,& size ( dims1 ), dims1 ,& self % log_b_max , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/m_min' ,& size ( dims1 ), dims1 ,& self % m_min , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/m_max' ,& size ( dims1 ), dims1 ,& self % m_max , error ) call h5ltmake_dataset_double_f ( file_id , 'widths/sigma' ,& size ( dims1 ), dims1 ,& self % sigma , error ) dims2 = [ self % n , 3 ] call h5ltmake_dataset_double_f ( file_id , 'widths/info' ,& size ( dims2 ), dims2 ,& self % info , error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message ( 'Output file : ' // trim ( filename ) // ' does NOT exist.' ) stop end if end subroutine subroutine print_width_parameters ( self , verbose ) !! Prints `width_parameters` components. use info_messages implicit none class ( width_parameters_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    ----------------' print * , '    Width Parameters' print * , '    ----------------' print * print * , '        Number of `a` parameters         : ' , trim ( adjustl ( int_to_str ( self % n_a ))) print * , '        Number of `b` parameters         : ' , trim ( adjustl ( int_to_str ( self % n_b ))) print * , '        Number of delta max parameters   : ' , trim ( adjustl ( int_to_str ( self % n_m ))) print * , '        Total number of width parameters : ' , trim ( adjustl ( int_to_str ( self % n ))) print * print * , '        Minimum `a` parameter : ' , self % a_min , 'eV' print * , '        Maximum `a` parameter : ' , self % a_max , 'eV' print * print * , '        Minimum `b` parameter : ' , 1 0.0_dp ** self % log_b_min print * , '        Maximum `b` parameter : ' , 1 0.0_dp ** self % log_b_max print * print * , '        Minimum delta max parameter : ' , self % m_min , 'eV' print * , '        Maximum delta max parameter : ' , self % m_max , 'eV' print * print * , '        sigma : ' , self % sigma print * call print_section_seperator () print * end if end subroutine function get_width ( self , id , omega ) result ( width ) !! Returns  \\delta(\\omega)  for a given id. implicit none class ( width_parameters_t ) :: self integer :: id real ( dp ) :: omega real ( dp ) :: width width = min ( self % info ( id , 3 ), self % info ( id , 1 ) + self % info ( id , 2 ) * omega ) end function subroutine load_width_parameters_nml ( self , filename , verbose ) !! Loads `width_parameters` parameters from a namelist. use info_messages use math_mod implicit none class ( width_parameters_t ) :: self character ( len =* ) :: filename logical , optional :: verbose logical :: file_exists integer :: error integer :: n_a = 1 !! Number of  a  parameters. integer :: n_b = 1 !! Number of  b  parameters. integer :: n_m = 1 !! Number of  \\delta_\\text{max}  parameters. real ( dp ) :: a_min !! Minimum  a  parameter. !! !! Units : eV real ( dp ) :: a_max !! Minimum  a  parameter. !! !! Units : eV real ( dp ) :: log_b_min !! Log10 of the minimum  b  parameter. real ( dp ) :: log_b_max !! Log10 of the maximum  b  parameter. real ( dp ) :: m_max !! Maximum  \\delta_\\text{max}  parameter. !! !! Units : eV real ( dp ) :: m_min !! Minimum  \\delta_\\text{max}  parameter. !! !! Units : eV real ( dp ) :: sigma = 1 D10 !!  \\sigma  parameter, energy difference must be within  \\sigma \\delta  to be !! added to the rate. NAMELIST / widths / n_a , & n_b , & n_m , & a_min , & a_max , & log_b_min , & log_b_max , & m_max , & m_min , & sigma integer :: a , b , m , id real ( dp ), allocatable :: a_list (:) real ( dp ), allocatable :: log_b_list (:) real ( dp ), allocatable :: m_list (:) if ( verbose ) then print * , 'Loading the width parameters...' print * end if inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then open ( 100 , file = trim ( filename ), iostat = error ) read ( 100 , nml = widths , iostat = error ) close ( 100 ) self % n_a = n_a self % n_b = n_b self % n_m = n_m self % a_min = a_min self % a_max = a_max self % log_b_min = log_b_min self % log_b_max = log_b_max self % m_max = m_max self % m_min = m_min self % sigma = sigma self % n = self % n_a * self % n_b * self % n_m allocate ( self % info ( self % n , 3 )) allocate ( a_list ( self % n_a )) allocate ( log_b_list ( self % n_b )) allocate ( m_list ( self % n_m )) a_list = uniform_list ( self % n_a , self % a_min , self % a_max ) log_b_list = uniform_list ( self % n_b , self % log_b_min , self % log_b_max ) m_list = uniform_list ( self % n_m , self % m_min , self % m_max ) id = 0 do a = 1 , self % n_a do b = 1 , self % n_b do m = 1 , self % n_m id = id + 1 self % info ( id , 1 ) = a_list ( a ) self % info ( id , 2 ) = 1 0.0_dp ** log_b_list ( b ) self % info ( id , 3 ) = m_list ( m ) end do end do end do call self % print ( verbose = verbose ) else call print_error_message (& 'Input file for width parameters : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine end module","tags":"","loc":"sourcefile/width_parameters_type.f90.html"},{"title":"FFT_util.f90 – EXCEED-DM","text":"Contents Modules FFT_util Source Code FFT_util.f90 Source Code module FFT_util !! Utilities for computing FFT's. use fftw3 use prec use info_messages implicit none type FFT_grid_t !! Collection of parameters defining the grid the FFT is performed on, !! and how the FFT should be performed. integer :: N !! Number of points in the FFT integer :: n_grid ( 3 ) !! Number of points in the FFT in each dimension real ( dp ) :: q_max !! Maximum q for which the FFT is consistent for. See `find_q_max` !! !! Units :  eV  integer :: plan ( 8 ) !! The FFTW3 plan integer , allocatable :: sym_G_grid_red (:, :, :, :) !! Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] !! !! Shifted, symmetric list of G points in FFT grid in reduced coordinates !! !! Units : None real ( dp ), allocatable :: sym_G_grid_xyz (:, :, :, :) !! Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] !! !! Shifted, symmetric list of G points in FFT grid in xyz coordinates !! !! Units : eV contains procedure :: init => FFT_grid_init procedure :: save => FFT_grid_save procedure :: print => FFT_grid_print procedure :: set_sym_G_grid => FFT_grid_set_sym_G_grid end type contains subroutine FFT_grid_print ( self , verbose ) !! Prints `FFT_grid` components. implicit none class ( FFT_grid_t ) :: self logical , optional :: verbose if ( verbose ) then call print_section_seperator () print * , '    --------' print * , '    FFT Grid' print * , '    --------' print * print * , '        Number of points : ' , self % n print * , '        Dimensions       : ' print * , '        ' , self % n_grid print * print * , '        q_max = ' , self % q_max / 1.0e3_dp , 'keV' print * call print_section_seperator () print * end if end subroutine subroutine FFT_grid_save ( self , filename , verbose ) !! Saves `FFT_grid`. use hdf5 use h5lt implicit none class ( FFT_grid_t ) :: self character ( len =* ) :: filename logical , optional :: verbose integer ( HID_T ) :: file_id integer ( HID_T ) :: group_id logical :: file_exists integer ( HSIZE_T ) :: dims1 ( 1 ) = [ 1 ] integer ( HSIZE_T ) :: dims2 ( 1 ) = [ 3 ] integer :: error if ( verbose ) then print * , 'Saving FFT grid parameters...' print * end if ! make sure the file exists inquire ( file = trim ( filename ), exist = file_exists ) if ( file_exists ) then call h5open_f ( error ) call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) call h5gcreate_f ( file_id , 'FFT' , group_id , error ) ! write data call h5ltmake_dataset_int_f ( file_id , & 'FFT/N' , & size ( dims1 ), dims1 , & self % N , & error ) call h5ltmake_dataset_int_f ( file_id , & 'FFT/n_grid' , & size ( dims2 ), dims2 , & self % n_grid , & error ) call h5ltmake_dataset_double_f ( file_id , & 'FFT/q_max' , & size ( dims1 ), dims1 , & self % q_max , & error ) call h5fclose_f ( file_id , error ) call h5close_f ( error ) else call print_error_message (& 'Output file : ' // trim ( filename ) // ' does NOT exist.' , & verbose = verbose ) stop end if end subroutine subroutine FFT_grid_init ( self , n_grid , k_red_to_xyz , fb_char , verbose ) !! Initialize an `FFT_grid` instance. !! !! 1) Find  q&#94;\\text{FFT}_\\text{max}  !! 2) Initialize the FFT plan. (Default: FFTW3 'patient' planning) !! 3) Set the symmetric FFT grids. use math_mod implicit none class ( FFT_grid_t ) :: self integer :: n_grid ( 3 ) real ( dp ) :: k_red_to_xyz ( 3 , 3 ) character ( len = 1 ) :: fb_char !! 'f' for forward rule, 'b' for backwards logical , optional :: verbose self % n_grid = n_grid self % n = self % n_grid ( 1 ) * self % n_grid ( 2 ) * self % n_grid ( 3 ) self % q_max = get_max_r_inside_parallelepiped ( self % n_grid , k_red_to_xyz , verbose = verbose ) if ( verbose ) then print * , 'Finding optimal FFT plan...' print * end if if ( fb_char == 'b' ) then call set_fft_plan_backward_3d ( self % n_grid , self % plan ) else call set_fft_plan_forward_3d ( self % n_grid , self % plan ) end if if ( verbose ) then print * , 'Setting symmetric FFT G grid...' print * end if call self % set_sym_G_grid ( k_red_to_xyz , verbose = verbose ) end subroutine subroutine FFT_grid_set_sym_G_grid ( self , k_red_to_xyz , verbose ) !! Symmetric FFT grid. !! !! Standard convention for FFTs is to compute for frequencies 0 -> N-1. !! This subroutine creates a map which takes the larger half of the positive !! frequencies and maps then back to negative values, for a symmetric G grid. implicit none class ( FFT_grid_t ) :: self real ( dp ) :: k_red_to_xyz ( 3 , 3 ) logical , optional :: verbose integer :: g1 , g2 , g3 integer :: G_red ( 3 ) allocate ( self % sym_G_grid_red ( self % n_grid ( 1 ), self % n_grid ( 2 ), self % n_grid ( 3 ), 3 )) allocate ( self % sym_G_grid_xyz ( self % n_grid ( 1 ), self % n_grid ( 2 ), self % n_grid ( 3 ), 3 )) do g3 = 1 , self % n_grid ( 3 ) do g2 = 1 , self % n_grid ( 2 ) do g1 = 1 , self % n_grid ( 1 ) G_red = [ g1 - 1 , g2 - 1 , g3 - 1 ] if ( g1 > self % n_grid ( 1 ) / 2 ) then G_red ( 1 ) = g1 - self % n_grid ( 1 ) - 1 end if if ( g2 > self % n_grid ( 2 ) / 2 ) then G_red ( 2 ) = g2 - self % n_grid ( 2 ) - 1 end if if ( g3 > self % n_grid ( 3 ) / 2 ) then G_red ( 3 ) = g3 - self % n_grid ( 3 ) - 1 end if self % sym_G_grid_red ( g1 , g2 , g3 , :) = G_red self % sym_G_grid_xyz ( g1 , g2 , g3 , :) = matmul ( k_red_to_xyz , G_red ) end do end do end do end subroutine subroutine set_fft_plan_forward_3d ( n_grid , fft_plan ) !! Sets the FFTW3 FFT plan with a 'forwards' convention. See !![https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029](https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029). implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_FORWARD , FFTW_PATIENT ) end subroutine subroutine set_fft_plan_backward_3d ( n_grid , fft_plan ) !! Sets the FFTW3 FFT plan with a 'backwards' convention. See !![https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029](https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029). implicit none integer :: fft_plan ( 8 ) integer :: n_grid ( 3 ) complex ( dp ) :: test_mat_in ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) complex ( dp ) :: test_mat_out ( n_grid ( 1 ), n_grid ( 2 ), n_grid ( 3 )) test_mat_in = ( 0.0_dp , 0.0_dp ) test_mat_out = ( 0.0_dp , 0.0_dp ) call dfftw_plan_dft_3d ( fft_plan , n_grid ( 3 ), n_grid ( 2 ), n_grid ( 1 ),& test_mat_in , test_mat_out , FFTW_BACKWARD , FFTW_PATIENT ) end subroutine subroutine G_red_to_FFT_G_grid_index ( n_grid , G_red , idx ) !! Given a G_red vector returns the index of that vector in the FFT !! grid. implicit none integer :: idx ( 3 ) integer :: G_red ( 3 ) integer :: n_grid ( 3 ) integer :: i idx = G_red + [ 1 , 1 , 1 ] ! put negative values at the back of the array in FFTW3 convention do i = 1 , 3 if ( G_red ( i ) < 0 ) then idx ( i ) = G_red ( i ) + n_grid ( i ) + 1 end if end do end subroutine end module","tags":"","loc":"sourcefile/fft_util.f90.html"},{"title":"MPI_util.f90 – EXCEED-DM","text":"Contents Modules MPI_util Source Code MPI_util.f90 Source Code module MPI_util !! Utilities and wrapper functions for MPI routines. Generally, whenever data has to be communicated !! from one processor to another the `MPI_Send` and `MPI_Recv` calls are inside subroutines !! in this module. use mpi use prec use info_messages implicit none type parallel_manager_t !! Manages indexing the jobs that each processor needs to do and !! communicates the results to the main/root processor. integer :: n_jobs !! Total number of jobs integer :: n_jobs_per_proc !! Number of transitions per processor integer , allocatable :: job_table (:, :) !! Dim : [ n_proc, n_jobs_per_proc ] !! !! `job_table(i, :)` gives the list of job ID's that processor !! i needs to compute for. contains procedure :: init => parallel_manager_init procedure :: create_job_to_2d_ID_table procedure :: comm_abs_tran_form procedure :: comm_self_energies procedure :: comm_abs_rate end type contains subroutine comm_reduce_dielectric ( proc_id , root_process , & dielectric , verbose ) !! Communicate the dielectric pieces computed at each processor to the total dielectric !! on the main processor using MPI_Reduce. integer :: proc_id , root_process complex ( dp ) :: dielectric (:, :, :, :) complex ( dp ) :: sum_dielectric (& size ( dielectric , 1 ), size ( dielectric , 2 ), size ( dielectric , 3 ),& size ( dielectric , 4 )) logical , optional :: verbose integer :: n_proc integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: i if ( verbose ) then print * , 'Reducing dielectric data...' print * end if if ( verbose ) then print * , 'Calling MPI_Reduce...' print * end if call MPI_Reduce ( dielectric , & sum_dielectric , & size ( dielectric ), & MPI_DOUBLE_COMPLEX , & MPI_SUM , & root_process , & MPI_COMM_WORLD , & err ) if ( verbose ) then print * , 'Done calling MPI_Reduce!' print * end if ! set dielectric to summed value dielectric = sum_dielectric if ( verbose ) then print * , 'Done reducing dielectric!' print * end if end subroutine subroutine comm_abs_rate ( self , proc_id , root_process , & abs_rate , verbose ) !! Communicate the absorption rate contribution from each processor to the main processor. class ( parallel_manager_t ) :: self integer :: proc_id , root_process real ( dp ) :: abs_rate (:, :, :) logical , optional :: verbose integer :: n_proc real ( dp ), allocatable :: abs_rate_buff (:, :, :) !! Dim : [ dm_model%n_mX, widths%n, expt%n_time ] !! !! Absorption rate, assuming the mediator-electron coupling,  g = 1 . !! !! Buffer variable, copy of `abs_rate` !! !! Units : None integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err integer :: i if ( verbose ) then print * , 'Communicating absorption rates...' print * end if call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) if ( proc_id /= root_process ) then call MPI_SEND ( abs_rate , & size ( abs_rate ), MPI_DOUBLE , root_process , & tag , MPI_COMM_WORLD , err ) end if if ( proc_id == root_process ) then allocate ( abs_rate_buff (& size ( abs_rate , 1 ), size ( abs_rate , 2 ), size ( abs_rate , 3 ))) do i = 1 , n_proc abs_rate_buff = 0.0_dp if ( i - 1 /= root_process ) then call MPI_RECV ( abs_rate_buff , & size ( abs_rate_buff ), MPI_DOUBLE , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) abs_rate = abs_rate + abs_rate_buff end if end do end if if ( verbose ) then print * , 'Done communicating absorption rate data!' print * end if end subroutine subroutine comm_self_energies ( self , proc_id , root_process , & pi_v2_v2_job , pi_1_1_mat_job , pi_vi_vj_job , & pi_v2_v2 , pi_1_1_mat , pi_vi_vj , verbose ) !! Communicate the self energies computed at each processor to the main processor. implicit none class ( parallel_manager_t ) :: self integer :: proc_id , root_process complex ( dp ) :: pi_v2_v2_job (:, :, :) !! Dim : [n_omega, n_widths, n_tran_per_proc] !! !! self energy with two v&#94;2 insertions !! !! Units : eV&#94;2 complex ( dp ) :: pi_1_1_mat_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! self energy, without q_vec's !! !! Units : eV&#94;2 complex ( dp ) :: pi_vi_vj_job (:, :, :, :, :) !! Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] !! !! Units : eV&#94;2 complex ( dp ) :: pi_v2_v2 (:, :) complex ( dp ) :: pi_vi_vj (:, :, :, :) complex ( dp ) :: pi_1_1_mat (:, :, :, :) logical , optional :: verbose integer :: n_proc integer :: i , j integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) if ( verbose ) then print * , 'Communicating self energies...' print * end if if ( proc_id /= root_process ) then call MPI_SEND ( pi_v2_v2_job , & size ( pi_v2_v2_job ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( pi_1_1_mat_job , & size ( pi_1_1_mat_job ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) call MPI_SEND ( pi_vi_vj_job , & size ( pi_vi_vj_job ), MPI_DOUBLE_COMPLEX , root_process , tag , MPI_COMM_WORLD , err ) end if if ( proc_id == root_process ) then ! add main processors contribution pi_v2_v2 = pi_v2_v2 + sum ( pi_v2_v2_job , 3 ) pi_1_1_mat = pi_1_1_mat + sum ( pi_1_1_mat_job , 5 ) pi_vi_vj = pi_vi_vj + sum ( pi_vi_vj_job , 5 ) do i = 1 , n_proc if ( ( i - 1 ) /= root_process ) then call MPI_RECV ( pi_v2_v2_job , & size ( pi_v2_v2_job ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( pi_1_1_mat_job , & size ( pi_1_1_mat_job ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( pi_vi_vj_job , & size ( pi_vi_vj_job ), MPI_DOUBLE_COMPLEX , i - 1 , MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! add other processors contributions pi_v2_v2 = pi_v2_v2 + sum ( pi_v2_v2_job , 3 ) pi_1_1_mat = pi_1_1_mat + sum ( pi_1_1_mat_job , 5 ) pi_vi_vj = pi_vi_vj + sum ( pi_vi_vj_job , 5 ) end if end do end if ! all processors now know all self energies call MPI_Bcast ( pi_v2_v2 , size ( pi_v2_v2 ), & MPI_DOUBLE_COMPLEX , root_process , MPI_COMM_WORLD , err ) call MPI_Bcast ( pi_1_1_mat , size ( pi_1_1_mat ), & MPI_DOUBLE_COMPLEX , root_process , MPI_COMM_WORLD , err ) call MPI_Bcast ( pi_vi_vj , size ( pi_vi_vj ), & MPI_DOUBLE_COMPLEX , root_process , MPI_COMM_WORLD , err ) if ( verbose ) then print * , 'Done communicating self energies!' print * end if end subroutine subroutine comm_abs_tran_form ( self , proc_id , root_process , job_id_to_ik , & tran_form_1_no_spin_job , tran_form_1_spin_job , & tran_form_v_no_spin_job , tran_form_v_spin_job , & tran_form_v2_no_spin_job , tran_form_v2_spin_job , & tran_form_1_no_spin , tran_form_1_spin , & tran_form_v_no_spin , tran_form_v_spin , & tran_form_v2_no_spin , tran_form_v2_spin , numerics , verbose ) !! Communicate the transition form factors computed at each processor to the main processor. use numerics_abs class ( parallel_manager_t ) :: self integer :: proc_id , root_process integer :: job_id_to_ik (:, :) type ( numerics_abs_t ) :: numerics ! buffer variables complex ( dp ), allocatable :: tran_form_1_no_spin_job_buff (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_1_spin_job_buff (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_no_spin_job_buff (:, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_v_spin_job_buff (:, :, :, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_no_spin_job_buff (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ), allocatable :: tran_form_v2_spin_job_buff (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_1_no_spin_job (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ) :: tran_form_1_spin_job (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v_no_spin_job (:, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ) :: tran_form_v_spin_job (:, :, :, :, :) !! Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v2_no_spin_job (:, :) !! Dim : [n_jobs_per_proc, n_cond_max] !! !! Units : None complex ( dp ) :: tran_form_v2_spin_job (:, :, :, :) !! Dim : [n_jobs_per_proc, n_cond_max, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_1_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_1_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v_no_spin (:, :, :, :) !! Dim : [3, n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_v_spin (:, :, :, :, :, :) !! Dim : [3, n_init, n_fin, n_k, 2, 2] !! !! Units : None complex ( dp ) :: tran_form_v2_no_spin (:, :, :) !! Dim : [n_init, n_fin, n_k] !! !! Units : None complex ( dp ) :: tran_form_v2_spin (:, :, :, :, :) !! Dim : [n_init, n_fin, n_k, 2, 2] !! !! Units : None logical , optional :: verbose integer :: n_proc integer :: init_id , k , job_id , j , i integer :: status ( MPI_STATUS_SIZE ) integer :: tag = 0 integer :: err call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) if ( verbose ) then print * , 'Communicating transition form factors for absorption calculation...' print * end if if ( proc_id == root_process ) then allocate ( tran_form_1_no_spin_job_buff ( self % n_jobs_per_proc , numerics % n_cond_max )) tran_form_1_no_spin_job_buff = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_1_spin_job_buff ( self % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_1_spin_job_buff = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_no_spin_job_buff ( 3 , self % n_jobs_per_proc , numerics % n_cond_max )) tran_form_v_no_spin_job_buff = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v_spin_job_buff ( 3 , self % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_v_spin_job_buff = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_no_spin_job_buff ( self % n_jobs_per_proc , numerics % n_cond_max )) tran_form_v2_no_spin_job_buff = ( 0.0_dp , 0.0_dp ) allocate ( tran_form_v2_spin_job_buff ( self % n_jobs_per_proc , numerics % n_cond_max , 2 , 2 )) tran_form_v2_spin_job_buff = ( 0.0_dp , 0.0_dp ) end if if ( proc_id /= root_process ) then call MPI_SEND ( tran_form_1_no_spin_job , & size ( tran_form_1_no_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_1_spin_job , & size ( tran_form_1_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_v_no_spin_job , & size ( tran_form_v_no_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_v_spin_job , & size ( tran_form_v_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_v2_no_spin_job , & size ( tran_form_v2_no_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) call MPI_SEND ( tran_form_v2_spin_job , & size ( tran_form_v2_spin_job ), MPI_DOUBLE_COMPLEX , root_process , & tag , MPI_COMM_WORLD , err ) end if ! receive data at main processor and put in total if ( proc_id == root_process ) then ! add main processors contribution do j = 1 , self % n_jobs_per_proc job_id = self % job_table ( proc_id + 1 , j ) if ( job_id /= 0 ) then init_id = job_id_to_ik ( job_id , 3 ) k = job_id_to_ik ( job_id , 4 ) tran_form_1_no_spin ( init_id , :, k ) = tran_form_1_no_spin_job ( j , :) tran_form_1_spin ( init_id , :, k , :, :) = tran_form_1_spin_job ( j , :, :, :) tran_form_v_no_spin (:, init_id , :, k ) = tran_form_v_no_spin_job (:, j , :) tran_form_v_spin (:, init_id , :, k , :, :) = tran_form_v_spin_job (:, j , :, :, :) tran_form_v2_no_spin ( init_id , :, k ) = tran_form_v2_no_spin_job ( j , :) tran_form_v2_spin ( init_id , :, k , :, :) = tran_form_v2_spin_job ( j , :, :, :) end if end do ! receive other contributions to buffer do i = 1 , n_proc if ( i - 1 /= root_process ) then call MPI_RECV ( tran_form_1_no_spin_job_buff , & size ( tran_form_1_no_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_1_spin_job_buff , & size ( tran_form_1_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_v_no_spin_job_buff , & size ( tran_form_v_no_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_v_spin_job_buff , & size ( tran_form_v_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_v2_no_spin_job_buff , & size ( tran_form_v2_no_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) call MPI_RECV ( tran_form_v2_spin_job_buff , & size ( tran_form_v2_spin_job_buff ), MPI_DOUBLE_COMPLEX , i - 1 , & MPI_ANY_TAG , MPI_COMM_WORLD , status , err ) ! add other processors contributions do j = 1 , self % n_jobs_per_proc job_id = self % job_table ( i , j ) if ( job_id /= 0 ) then init_id = job_id_to_ik ( job_id , 3 ) k = job_id_to_ik ( job_id , 4 ) tran_form_1_no_spin ( init_id , :, k ) = tran_form_1_no_spin_job_buff ( j , :) tran_form_1_spin ( init_id , :, k , :, :) = tran_form_1_spin_job_buff ( j , :, :, :) tran_form_v_no_spin (:, init_id , :, k ) = tran_form_v_no_spin_job_buff (:, j , :) tran_form_v_spin (:, init_id , :, k , :, :) = tran_form_v_spin_job_buff (:, j , :, :, :) tran_form_v2_no_spin ( init_id , :, k ) = tran_form_v2_no_spin_job_buff ( j , :) tran_form_v2_spin ( init_id , :, k , :, :) = tran_form_v2_spin_job_buff ( j , :, :, :) end if end do end if end do end if if ( verbose ) then print * , 'Done communicating transition form factors for absorption calculation!' print * end if end subroutine subroutine comm_reduce_binned_rate_init ( proc_id , root_process , binned_rate_init , verbose ) !! Return and sum all of the binned_rate_init's from the processors using MPI_Reduce. use binned_scatter_rate_type implicit none integer :: proc_id , root_process type ( binned_scatter_rate_t ) :: binned_rate_init (:) real ( dp ), allocatable :: local_binned_rate_init_mat (:, :, :, :, :, :) real ( dp ), allocatable :: sum_binned_rate_init_mat (:, :, :, :, :, :) logical , optional :: verbose integer :: i integer :: err if ( verbose ) then print * , 'Reducing scattering rate data...' print * end if if ( verbose ) then print * , 'Allocating large scattering rate data matrices...' print * end if allocate ( local_binned_rate_init_mat (& size ( binned_rate_init ), & size ( binned_rate_init ( 1 )% binned_rate , 1 ), & size ( binned_rate_init ( 1 )% binned_rate , 2 ), & size ( binned_rate_init ( 1 )% binned_rate , 3 ), & size ( binned_rate_init ( 1 )% binned_rate , 4 ), & size ( binned_rate_init ( 1 )% binned_rate , 5 ) ) ) do i = 1 , size ( binned_rate_init ) local_binned_rate_init_mat ( i , :, :, :, :, :) = binned_rate_init ( i )% binned_rate end do if ( proc_id == root_process ) then allocate ( sum_binned_rate_init_mat (& size ( binned_rate_init ), & size ( binned_rate_init ( 1 )% binned_rate , 1 ), & size ( binned_rate_init ( 1 )% binned_rate , 2 ), & size ( binned_rate_init ( 1 )% binned_rate , 3 ), & size ( binned_rate_init ( 1 )% binned_rate , 4 ), & size ( binned_rate_init ( 1 )% binned_rate , 5 ) ) ) end if if ( verbose ) then print * , 'Done allocating large scattering rate data matrices!' print * end if if ( verbose ) then print * , 'Calling MPI_Reduce...' print * end if call MPI_Reduce ( local_binned_rate_init_mat , & sum_binned_rate_init_mat , & size ( local_binned_rate_init_mat ), & MPI_DOUBLE , & MPI_SUM , & root_process , & MPI_COMM_WORLD , & err ) if ( verbose ) then print * , 'Done calling MPI_Reduce!' print * end if ! set binned_rate_init to the summed value if ( proc_id == root_process ) then do i = 1 , size ( binned_rate_init ) binned_rate_init ( i )% binned_rate = sum_binned_rate_init_mat ( i , :, :, :, :, :) end do end if if ( verbose ) then print * , 'Done reducing scattering rate data!' print * end if end subroutine subroutine create_job_to_2d_ID_table ( self , list1 , list2 , job_id_to_2d_ID_table , & verbose ) !! Given two lists, {list1, list2} create a single list which has !! n[list1]*n[list_2] elements, each of which has 4 elements. The first two elements !! are a pair from {list1, list2}, the second two index the value in the first pair, i.e. !! !! `job_id_to_2d_ID_table(1, 1) = list1(1)` !! !! `job_id_to_2d_ID_table(1, 2) = list2(7)` !! !! `job_id_to_2d_ID_table(1, 3) = 1` !! !! `job_id_to_2d_ID_table(1, 4) = 7` implicit none class ( parallel_manager_t ) :: self integer :: list1 (:) integer :: list2 (:) integer :: job_id_to_2d_ID_table (:, :) !! Dim : [n_jobs, 4] logical , optional :: verbose integer :: id integer :: i1 , i2 id = 0 do i1 = 1 , size ( list1 ) do i2 = 1 , size ( list2 ) id = id + 1 job_id_to_2d_ID_table ( id , 1 ) = list1 ( i1 ) job_id_to_2d_ID_table ( id , 2 ) = list2 ( i2 ) job_id_to_2d_ID_table ( id , 3 ) = i1 job_id_to_2d_ID_table ( id , 4 ) = i2 end do end do end subroutine subroutine parallel_manager_init ( self , n_jobs , verbose ) !! Initializes a `parallel_manager` instance. implicit none class ( parallel_manager_t ) :: self integer :: n_jobs !! Number of initial states logical , optional :: verbose integer :: n_proc !! Number of processors integer :: i , j , job_id , id , f integer :: err call MPI_COMM_SIZE ( MPI_COMM_WORLD , n_proc , err ) self % n_jobs = n_jobs if ( mod ( self % n_jobs , n_proc ) == 0 ) then self % n_jobs_per_proc = self % n_jobs / n_proc else self % n_jobs_per_proc = self % n_jobs / n_proc + 1 end if allocate ( self % job_table ( n_proc , self % n_jobs_per_proc )) job_id = 0 do j = 1 , self % n_jobs_per_proc do i = 1 , n_proc job_id = job_id + 1 if ( job_id > self % n_jobs ) then self % job_table ( i , j ) = 0 else self % job_table ( i , j ) = job_id end if end do end do if ( verbose ) then call print_section_seperator () print * if ( mod ( self % n_jobs , n_proc ) == 0 ) then print * , '    Equal processor load.' print * else if ( self % n_jobs_per_proc == 1 ) then print * , '    Number of processors is greater than the number of jobs.' // & ' Consider lowering the number of processors.' print * print * , '    Number of jobs = ' , self % n_jobs print * else print * , '    Unequal processor load. Some processors will be given null jobs.' print * print * , '    Number of jobs = ' , self % n_jobs print * end if print * , '    Number of jobs per processor = ' , self % n_jobs_per_proc print * call print_section_seperator () print * end if end subroutine end module","tags":"","loc":"sourcefile/mpi_util.f90.html"},{"title":"control_t – EXCEED-DM ","text":"type, public :: control_t Stores all variables associated with the program control. Contents Variables process calc_mode timer quiet overwrite_output Type-Bound Procedures print load save Components Type Visibility Attributes Name Initial character(len=64), public :: process = '' character(len=64), public :: calc_mode = '' logical, public :: timer = .TRUE. Optional If .TRUE. the program will output timing information logical, public :: quiet = .FALSE. Don't print any output logical, public :: overwrite_output = .FALSE. If .TRUE. the output file will be overwritten Type-Bound Procedures procedure, public :: print => print_control public subroutine print_control (self, verbose) Prints control components. Arguments Type Intent Optional Attributes Name class( control_t ) :: self logical, optional :: verbose procedure, public :: load => load_control_nml public subroutine load_control_nml (self, filename, verbose) Loads control parameters from a namelist. Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_control public subroutine save_control (self, filename, verbose) Saves control . Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/control_t.html"},{"title":"io_files_t – EXCEED-DM ","text":"type, public :: io_files_t All input and output filenames. Contents Variables nml_input_filename PW_data_filename run_description out_folder out_filename sto_data_filename core_elec_config_filename dielectric_filename Type-Bound Procedures print load save Components Type Visibility Attributes Name Initial character(len=512), public :: nml_input_filename = '' Namelist input filename character(len=512), public :: PW_data_filename = '' Bloch wave function coefficient file name character(len=64), public :: run_description = '' description of the calculation character(len=512), public :: out_folder = '.' Ouput folder character(len=512), public :: out_filename = '' Output filename Setting this variable overrides the settings of out_folder\nand run_description character(len=512), public :: sto_data_filename = '' Input file specifying the Slater type orbital (sto)\nwave function coefficients for the core electron\nstates character(len=512), public :: core_elec_config_filename = '' File specifying the core electron configuration character(len=512), public :: dielectric_filename = '' File specifying the dielectric function. If the dielectric\nwill be computed this will be where the computed values are\nstored. If this file already exists, the dielectric function\nwill be loaded from this file. Type-Bound Procedures procedure, public :: print => print_io public subroutine print_io (self, verbose) Prints io_files components. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self logical, optional :: verbose procedure, public :: load => load_io_nml public subroutine load_io_nml (self, filename, verbose) Loads io parameters from a namelist. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_io public subroutine save_io (self, filename, verbose) Saves io_files . Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/io_files_t.html"},{"title":"numerics_abs_t – EXCEED-DM ","text":"type, public :: numerics_abs_t Numerics parameters specific to DM absorption calculations. Contents Variables n_val_max n_cond_max val_id_list k_id_list save_tran_form n_v n_v_theta n_v_phi v_angular_mesh v_list v_mesh Type-Bound Procedures print load save create_val_id_list create_k_id_list Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] List of valence ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_k] List of k's to compute for. logical, public :: save_tran_form = .FALSE. If .TRUE. will save the transition form factors to the output file. integer, public :: n_v Number of points in integration over integer, public :: n_v_theta Number of points in integration over integer, public :: n_v_phi Number of points in integration over real(kind=dp), public, allocatable :: v_angular_mesh (:,:) Dim : [ n_v_theta*n_v_phi, 2] List of points in integral over Units : None real(kind=dp), public, allocatable :: v_list (:) Dim : [n_v] List of points in velocity integral Units : None real(kind=dp), public, allocatable :: v_mesh (:,:) Dim : [ n_v n_v_theta n_v_phi, 3] All points in the integration. Units : None Type-Bound Procedures procedure, public :: print => numerics_abs_print public subroutine numerics_abs_print (self, verbose) Prints numerics_abs components. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_abs_load_nml public subroutine numerics_abs_load_nml (self, filename, n_val, n_cond, dm_model, verbose) Loads numerics_abs parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond type( dm_model_t ) :: dm_model logical, optional :: verbose procedure, public :: save => numerics_abs_save public subroutine numerics_abs_save (self, filename, verbose) Saves numerics_abs . Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_val_id_list => abs_create_val_id_list public subroutine abs_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_val procedure, public :: create_k_id_list => abs_create_k_id_list public subroutine abs_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_k","tags":"","loc":"type/numerics_abs_t.html"},{"title":"numerics_dielectric_t – EXCEED-DM ","text":"type, public :: numerics_dielectric_t Numerics parameters specific to the dielectric calculation. Contents Variables n_val_max n_cond_max val_id_list k_id_list n_k_vec q_grid_min n_q_grid n_q_bin Type-Bound Procedures print load save create_val_id_list create_k_id_list define_q_grid compute_n_q_bin Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] List of valence ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_k] List of k's to compute for. integer, public :: n_k_vec (3) Number of vectors in each direction. real(kind=dp), public :: q_grid_min (3) Offset parameter to map coordinates to\nindicies. integer, public :: n_q_grid (3) Number of points in the q grid with integer, public, allocatable :: n_q_bin (:,:,:) Dim : [n_q, n_q_theta, n_q_phi] Number of points in the dielectric grid in each bin. Type-Bound Procedures procedure, public :: print => numerics_dielectric_print public subroutine numerics_dielectric_print (self, verbose) Prints numerics_dielectric components. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_dielectric_load_nml public subroutine numerics_dielectric_load_nml (self, filename, n_val, n_cond, verbose) Loads numerics_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose procedure, public :: save => numerics_dielectric_save public subroutine numerics_dielectric_save (self, filename, verbose) Saves numerics_dielectric . Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_val_id_list => dielectric_create_val_id_list public subroutine dielectric_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_val procedure, public :: create_k_id_list => dielectric_create_k_id_list public subroutine dielectric_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_k procedure, public :: define_q_grid public subroutine define_q_grid (self, q_max, PW_dataset, FFT_grid) Given a uniform grid  in the 1BZ for , \nand a uniform grid of 's, finds the uniform lattice of points which have . Read more… Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self real(kind=dp) :: q_max type(PW_dataset_t) :: PW_dataset type(FFT_grid_t) :: FFT_grid procedure, public :: compute_n_q_bin public subroutine compute_n_q_bin (self, bins, PW_dataset, verbose) Find the number of points from the uniformly spaced grid that are in each\nin a bin. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self type( bins_dielectric_t ) :: bins type(PW_dataset_t) :: PW_dataset logical, optional :: verbose","tags":"","loc":"type/numerics_dielectric_t.html"},{"title":"numerics_scatter_cc_t – EXCEED-DM ","text":"type, public :: numerics_scatter_cc_t Numerics parameters specific to the core conduction DM-electron scattering rate calculation. Contents Variables n_principal_max n_principal_min n_cond_max n_FFT_grid core_id_list k_id_list Type-Bound Procedures print load save create_k_id_list create_core_id_list Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. integer, public :: n_cond_max = 0 Maximum number of conduction bands. integer, public :: n_FFT_grid (3) = [0, 0, 0] Dimension of the FFT grid to compute on. integer, public, allocatable :: core_id_list (:) Dim : [n_init] List of core ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_init] List of k points to compute for. Type-Bound Procedures procedure, public :: print => numerics_scatter_cc_print public subroutine numerics_scatter_cc_print (self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_scatter_cc_load_nml public subroutine numerics_scatter_cc_load_nml (self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose procedure, public :: save => numerics_scatter_cc_save public subroutine numerics_scatter_cc_save (self, filename, verbose) Saves numerics_scatter_cc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_k_id_list => cc_create_k_id_list public subroutine cc_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self integer :: n_k procedure, public :: create_core_id_list => cc_create_core_id_list public subroutine cc_create_core_id_list (self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self type( core_electron_t ) :: core_electron","tags":"","loc":"type/numerics_scatter_cc_t.html"},{"title":"numerics_scatter_cc_ext_t – EXCEED-DM ","text":"type, public :: numerics_scatter_cc_ext_t Numerics parameters specific to the core conduction DM-electron scattering rate calculation. Contents Variables n_principal_max n_principal_min n_cond_max core_id_list k_id_list n_q q_min n_q_theta n_q_phi q_angular_mesh Type-Bound Procedures print load save create_k_id_list create_core_id_list Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. integer, public :: n_cond_max = 0 Maximum number of conduction bands. integer, public, allocatable :: core_id_list (:) Dim : [n_init] List of core ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_init] List of k points to compute for. integer, public :: n_q real(kind=dp), public :: q_min integer, public :: n_q_theta = 1 integer, public :: n_q_phi = 1 real(kind=dp), public, allocatable :: q_angular_mesh (:,:) Dim : [ n_q_theta x n_kf_phi , 2 ] Grid of points for the angular integration over Units : None Type-Bound Procedures procedure, public :: print => numerics_scatter_cc_ext_print public subroutine numerics_scatter_cc_ext_print (self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_scatter_cc_ext_load_nml public subroutine numerics_scatter_cc_ext_load_nml (self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose procedure, public :: save => numerics_scatter_cc_ext_save public subroutine numerics_scatter_cc_ext_save (self, filename, verbose) Saves numerics_scatter_cc_ext . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_k_id_list => cc_ext_create_k_id_list public subroutine cc_ext_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self integer :: n_k procedure, public :: create_core_id_list => cc_ext_create_core_id_list public subroutine cc_ext_create_core_id_list (self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction (extended) DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self type( core_electron_t ) :: core_electron","tags":"","loc":"type/numerics_scatter_cc_ext_t.html"},{"title":"numerics_scatter_cf_t – EXCEED-DM ","text":"type, public :: numerics_scatter_cf_t Numerics parameters specific to the core free DM-electron scattering rate calculation. Contents Variables n_principal_max n_principal_min Zeff_type Zeff n_kf_theta n_kf_phi kf_angular_mesh n_omega omega_list n_ki n_ki_theta n_ki_phi ki_angular_mesh ki_s ki_min core_id_list w_id_list Ef_min Type-Bound Procedures print load save create_core_id_list create_w_id_list Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use 'one' - all Zeff = 1 'Eb' - use the binding energy of the core states real(kind=dp), public, allocatable :: Zeff (:) Dim : [ n_state ] parameter in the Fermi form factor. integer, public :: n_kf_theta = 1 Number of points in the integration of integer, public :: n_kf_phi = 1 Number of points in the integration of real(kind=dp), public, allocatable :: kf_angular_mesh (:,:) Dim : [ n_kf_theta*n_kf_phi, 2 ] Grid of points for the integration over Units : None integer, public :: n_omega Number of points to compute for. The core -> free scattering\nrate calculation is done by computing n_omega values of between and then interpolated to the user defined grid. real(kind=dp), public, allocatable :: omega_list (:) List of points to compute for. The core -> free scattering\nrate calculation is done by computing n_omega values of between and then interpolated to the user defined grid. integer, public :: n_ki = 2 Number of points in integration over integer, public :: n_ki_theta = 1 Number of points in integration over integer, public :: n_ki_phi = 1 Number of points in integration over real(kind=dp), public, allocatable :: ki_angular_mesh (:,:) Dim : [ n_ki_theta*n_ki_phi, 2 ] Grid of points for the integration over Units : None real(kind=dp), public :: ki_s = 100.0_dp Scale parameter for maximum to integrate over. ki_max = ki_s Generally, this parameters should be since is the\ntypical momentum scale of the electronic wave functions. Units : None real(kind=dp), public :: ki_min = 1.0e3_dp Minimum in the integration over Units : eV integer, public, allocatable :: core_id_list (:) Dim : [n_init] List of core ID's to compute for. integer, public, allocatable :: w_id_list (:) Dim : [n_omega] List of omega ID's to compute for. real(kind=dp), public :: Ef_min Smallest final electron energy to compute for. Type-Bound Procedures procedure, public :: print => numerics_scatter_cf_print public subroutine numerics_scatter_cf_print (self, verbose) Prints numerics_scatter_cf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_scatter_cf_load_nml public subroutine numerics_scatter_cf_load_nml (self, filename, core_electron, verbose) Loads numerics_scatter_cf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename type( core_electron_t ) :: core_electron logical, optional :: verbose procedure, public :: save => numerics_scatter_cf_save public subroutine numerics_scatter_cf_save (self, filename, verbose) Save numerics_scatter_cf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_core_id_list => cf_create_core_id_list public subroutine cf_create_core_id_list (self, core_electron) Create the list of core id's to compute for. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self type( core_electron_t ) :: core_electron procedure, public :: create_w_id_list => cf_create_w_id_list public subroutine cf_create_w_id_list (self) Specify the indicies for each point that should be included. \nSpecific to the core free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self","tags":"","loc":"type/numerics_scatter_cf_t.html"},{"title":"numerics_scatter_vc_t – EXCEED-DM ","text":"type, public :: numerics_scatter_vc_t Numerics parameters specific to the valence conduction DM-electron scattering rate calculation. Contents Variables n_val_max n_cond_max val_id_list k_id_list Type-Bound Procedures print load save create_val_id_list create_k_id_list Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] List of valence ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_k] List of k's to compute for. Type-Bound Procedures procedure, public :: print => numerics_scatter_vc_print public subroutine numerics_scatter_vc_print (self, verbose) Prints numerics_scatter_vc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_scatter_vc_load_nml public subroutine numerics_scatter_vc_load_nml (self, filename, n_val, n_cond, verbose) Loads numerics_scatter_vc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose procedure, public :: save => numerics_scatter_vc_save public subroutine numerics_scatter_vc_save (self, filename, verbose) Saves numerics_scatter_vc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_val_id_list => vc_create_val_id_list public subroutine vc_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_val procedure, public :: create_k_id_list => vc_create_k_id_list public subroutine vc_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence conduction DM-electron rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_k","tags":"","loc":"type/numerics_scatter_vc_t.html"},{"title":"numerics_scatter_vf_t – EXCEED-DM ","text":"type, public :: numerics_scatter_vf_t Numerics parameters specific to the valence free DM-electron scattering rate calculation. Contents Variables n_val_max Zeff_type Zeff val_id_list k_id_list n_kf_theta n_kf_phi kf_angular_mesh n_omega omega_list Type-Bound Procedures print load save create_val_id_list create_k_id_list Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use 'one' - all Zeff = 1 'Eb' - use the binding energy of the valence states real(kind=dp), public, allocatable :: Zeff (:,:) Dim : [ n_val, n_k ] parameter in the Fermi form factor. integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] List of valence ID's to compute for. integer, public, allocatable :: k_id_list (:) Dim : [n_k] List of k's to compute for. integer, public :: n_kf_theta = 1 Number of points in the integration of integer, public :: n_kf_phi = 1 Number of points in the integration of real(kind=dp), public, allocatable :: kf_angular_mesh (:,:) Dim : [ n_kf_theta*n_kf_phi, 2 ] Grid of points for the integration over Units : None integer, public :: n_omega Number of points to compute for. The valence -> free scattering\nrate calculation is done by computing n_omega values of between and then interpolated to the user defined grid. real(kind=dp), public, allocatable :: omega_list (:) List of points to compute for. The valence -> free scattering\nrate calculation is done by computing n_omega values of between and then interpolated to the user defined grid. Type-Bound Procedures procedure, public :: print => numerics_scatter_vf_print public subroutine numerics_scatter_vf_print (self, verbose) Prints numerics_scatter_vf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self logical, optional :: verbose procedure, public :: load => numerics_scatter_vf_load_nml public subroutine numerics_scatter_vf_load_nml (self, filename, PW_dataset, verbose) Loads numerics_scatter_vf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename type(PW_dataset_t) :: PW_dataset logical, optional :: verbose procedure, public :: save => numerics_scatter_vf_save public subroutine numerics_scatter_vf_save (self, filename, verbose) Saves numerics_scatter_vf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: create_val_id_list => vf_create_val_id_list public subroutine vf_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_val procedure, public :: create_k_id_list => vf_create_k_id_list public subroutine vf_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence free DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_k","tags":"","loc":"type/numerics_scatter_vf_t.html"},{"title":"binned_scatter_rate_t – EXCEED-DM ","text":"type, public :: binned_scatter_rate_t Binned scattering rate for each DM mass, mediator form factor, and time of day. Binning is\nin momentum deposition, and energy deposition, (referred to as E in the code). Contents Variables binned_rate Type-Bound Procedures init compute_rate Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: binned_rate (:,:,:,:,:) Dim : [ bins%n_q, bins%n_E, dm_model%n_mX, dm_model%n_med_FF, expt%n_time ] Binned scattering rate per cross section, . Units : Type-Bound Procedures procedure, public :: init => binned_scatter_rate_init public subroutine binned_scatter_rate_init (self, bins, dm_model, expt) Creates a binned_rate object and sets binned_rate%binned_rate = 0. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt procedure, public :: compute_rate => binned_scatter_rate_compute_rate public function binned_scatter_rate_compute_rate (self) result(rate) Sums binned_rate%binned_rate over the bins to get the total rate. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self Return Value real(kind=dp)\n  (size(self%binned_rate,3),size(self%binned_rate,4),size(self%binned_rate,5))","tags":"","loc":"type/binned_scatter_rate_t.html"},{"title":"bins_dielectric_t – EXCEED-DM ","text":"type, public :: bins_dielectric_t Collection of parameters which specify how the dielectric function\nis binned in . Contents Variables n_q n_q_theta n_q_phi n_E q_width E_width Type-Bound Procedures print load save Components Type Visibility Attributes Name Initial integer, public :: n_q = 1 Number of bins for . integer, public :: n_q_theta = 1 Number of bins for the coordinate of integer, public :: n_q_phi = 1 Number of bins for the coordinate of integer, public :: n_E = 1 Number of bins in omega space real(kind=dp), public :: q_width = 1.0e3_dp Width of the q bins Units : eV real(kind=dp), public :: E_width = 0.1_dp Width of the omega bins. Units : eV Type-Bound Procedures procedure, public :: print => print_bins_dielectric public subroutine print_bins_dielectric (self, verbose) Print bins_dielectric components. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self logical, optional :: verbose procedure, public :: load => load_bins_dielectric_nml public subroutine load_bins_dielectric_nml (self, filename, verbose) Loads bins_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_bins_dielectric public subroutine save_bins_dielectric (self, filename, verbose) Saves bins_dielectric . Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/bins_dielectric_t.html"},{"title":"bins_scatter_t – EXCEED-DM ","text":"type, public :: bins_scatter_t Collection of parameters which specify how the DM-electron scattering rate\nis binned in . Contents Variables n_q n_E q_width E_width Type-Bound Procedures print load save Components Type Visibility Attributes Name Initial integer, public :: n_q = 1 Number of bins in momentum space integer, public :: n_E = 1 Number of bins in omega space real(kind=dp), public :: q_width = 1.0e3_dp Width of the q bins Units : eV real(kind=dp), public :: E_width = 0.1_dp Width of the omega bins. To get the event rate per ionization threshold, , set this to\nset this to the parameter. Units : eV Type-Bound Procedures procedure, public :: print => print_bins public subroutine print_bins (self, verbose) Print bins_scatter components. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self logical, optional :: verbose procedure, public :: load => load_bins_nml public subroutine load_bins_nml (self, filename, verbose) Loads bins_scatter parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_bins public subroutine save_bins (self, filename, verbose) Saves bins_scatter . Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/bins_scatter_t.html"},{"title":"core_electron_t – EXCEED-DM ","text":"type, public :: core_electron_t Information about the core electrons for each atom in the unit cell.\nContains the configuration information, e.g. number of atoms, number of core\nstates for each atom, but also the RHF wave function coefficients to get the\natomic wave functions, . Contents Variables n_atom n_state eq_pos_red energy Z config STO_nj STO_nl STO_Zl STO_norm_l STO_Cnl STO_max_nj config_filename sto_filename Type-Bound Procedures load save print bloch_wf_on_grid atomic_sto_wf atomic_sto_wf_radial atomic_sto_wf_FT atomic_sto_wf_FT_radial Components Type Visibility Attributes Name Initial integer, public :: n_atom Number of atoms in the primitive cell. integer, public :: n_state Number of core states. real(kind=dp), public, allocatable :: eq_pos_red (:,:) Dim : [n_atom, 3] Equilibrium positions in reduced coordinates Units : None real(kind=dp), public, allocatable :: energy (:) Dim : [n_state] Energy of each core state. Units : eV integer, public, allocatable :: Z (:) Dim : [n_atom] Proton number of each atom in the primitive cell integer, public, allocatable :: config (:,:) Dim : [n_state, 5] Electron configuration, each element is\n     config(i, 1) - atom id\n     config(i, 2) - n\n     config(i, 3) - l\n     config(i, 4) - m\n     config(i, 5) - n_s (number of spin states) integer, public, allocatable :: STO_nj (:) Dim : [n_state] Number of STO expansion parameters for each state real(kind=dp), public, allocatable :: STO_nl (:,:) Dim : [ n_state, STO_nj(n_state) ] STO n_lj parameters Units : None real(kind=dp), public, allocatable :: STO_Zl (:,:) Dim : [ n_state, STO_nj(n_state) ] STO Z_lj parameters Units : None real(kind=dp), public, allocatable :: STO_norm_l (:,:) Dim : [ n_state, STO_nj(n_state) ] STO N_lj parameters Units : None real(kind=dp), public, allocatable :: STO_Cnl (:,:) Dim : [ n_state, STO_nj(n_state) ] STO C_nlj parameters Units : None integer, public :: STO_max_nj Maximum value of nj across all states. character(len=512), public :: config_filename Core electron configuration filename character(len=512), public :: sto_filename STO wave function coefficient filename Type-Bound Procedures procedure, public :: load => load_core_electron public subroutine load_core_electron (self, core_elec_config_filename, STO_filename, verbose) Loads core_electron parameters from a namelist.\nget the relevant data for each core state Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: core_elec_config_filename character(len=*) :: STO_filename logical, optional :: verbose procedure, public :: save => save_core_electron public subroutine save_core_electron (self, filename, verbose) Saves core_electron . Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_core_electron public subroutine print_core_electron (self, verbose) Prints core_electron components. Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self logical, optional :: verbose procedure, public :: bloch_wf_on_grid => core_bloch_wf_on_grid public subroutine core_bloch_wf_on_grid (self, n_grid, wf, id, pc_vol, red_to_xyz, shift, k_vec_in, r_cut_in, verbose) Compute the core electron wave functions on a grid inside the primitive cell, summed\nover neighboring unit cells. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: n_grid (3) complex(kind=dp) :: wf (n_grid(1),n_grid(2),n_grid(3)) integer :: id real(kind=dp) :: pc_vol real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: r_cut_in logical, optional :: verbose procedure, public :: atomic_sto_wf public function atomic_sto_wf (self, id, x) result(wf) Atomic wave function, summed over individual STO's. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: x (3) Return Value complex(kind=dp) procedure, public :: atomic_sto_wf_radial public function atomic_sto_wf_radial (self, id, r) result(wf) Radial part of atomic_sto_wf . Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: r Return Value real(kind=dp) procedure, public :: atomic_sto_wf_FT public function atomic_sto_wf_FT (self, id, k) result(wf_FT) Fourier transform of the atomic wave function which is a sum of STO's. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config() real(kind=dp) :: k (3) Return Value complex(kind=dp) procedure, public :: atomic_sto_wf_FT_radial public function atomic_sto_wf_FT_radial (self, id, k_mag) result(chi) Radial part of atomic_sto_wf . Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config real(kind=dp) :: k_mag Return Value complex(kind=dp)","tags":"","loc":"type/core_electron_t.html"},{"title":"dm_model_t – EXCEED-DM ","text":"type, public :: dm_model_t Parameters defining the dark matter (DM) model, i.e. the DM particle and mediator. Contents Variables n_mX mX n_med_FF med_FF rhoX_GeV_per_cm3 rhoX v0_km_per_sec vE_km_per_sec vEsc_km_per_sec v0 vE vEsc g_func_N0 g_func_c1 g_func_c2 vX_max tff_id particle_type Type-Bound Procedures load save print Components Type Visibility Attributes Name Initial integer, public :: n_mX = 1 Number of masses real(kind=dp), public, allocatable :: mX (:) Dim : [ n_mX ] List of masses Units : eV integer, public :: n_med_FF = 1 Number of mediator form factors real(kind=dp), public, allocatable :: med_FF (:) Dim : [ n_med_FF ] List of mediator form factors coefficients, Examples: Light mediator :  \\beta = 2  Heavy mediator :  \\beta = 0  Units : None real(kind=dp), public :: rhoX_GeV_per_cm3 = 0.4_dp Dark matter density Units : GeV/cm&#94;3 real(kind=dp), public :: rhoX Dark matter density Units : eV&#94;4 real(kind=dp), public :: v0_km_per_sec = 230.0_dp DM velocity distribution parameter, Units : km/s real(kind=dp), public :: vE_km_per_sec = 240.0_dp DM velocity distribution parameter, Units : km/s real(kind=dp), public :: vEsc_km_per_sec = 600.0_dp DM velocity distribution parameter, Units : km/s real(kind=dp), public :: v0 DM velocity distribution parameter, Units : None real(kind=dp), public :: vE DM velocity distribution parameter, Units : None real(kind=dp), public :: vEsc DM velocity distribution parameter, Units : None real(kind=dp), public :: g_func_N0 Parameter of g_func_N0 Units : None real(kind=dp), public :: g_func_c1 Parameter of g_func_c1 Units : None real(kind=dp), public :: g_func_c2 Parameter of g_func_c2 Units : None real(kind=dp), public :: vX_max Maximum speed of the incoming dark matter vX_max = vE + vEsc Units : None integer, public :: tff_id (2) = [1, 1] Transition form factor ID. Specifies which matrix element to compute, which\nwill depend on the scattering potential of the DM model character(len=64), public :: particle_type = 'fermion' Dark matter particle type Type-Bound Procedures procedure, public :: load => load_dm_model_nml public subroutine load_dm_model_nml (self, filename, verbose) Loads dm_model parameters from a namelist. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_dm_model public subroutine save_dm_model (self, filename, verbose) Saves dm_model . Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_dm_model public subroutine print_dm_model (self, verbose) Prints dm_model components. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self logical, optional :: verbose","tags":"","loc":"type/dm_model_t.html"},{"title":"expt_t – EXCEED-DM ","text":"type, public :: expt_t Experimental parameters, e.g. threshold energy, exposure, detector orientation. Contents Variables E_threshold m_T_kg m_T exposure_yr exposure n_time times vE_direction theta_E Type-Bound Procedures load print save Components Type Visibility Attributes Name Initial real(kind=dp), public :: E_threshold = 0.0_dp Energy threshold. Only events which deposit energy omega >= E_threshold will be considered. Units : eV real(kind=dp), public :: m_T_kg = 1.0_dp Mass of the target Units : kg real(kind=dp), public :: m_T Mass of the target Units : eV real(kind=dp), public :: exposure_yr = 1.0_dp Total exposure of the experiment Units : year real(kind=dp), public :: exposure Total exposure of the experiment Units : eV&#94;(-1) integer, public :: n_time = 1 Number of time of days to compute for real(kind=dp), public, allocatable :: times (:) Dim : [ n_time ] Times of the day. Units : days real(kind=dp), public, allocatable :: vE_direction (:,:) Dim : [ n_time, 3 ] Unit vector of the Earth velocity in the galactic frame, assuming the DM wind\nis incoming on the Earth in the direction . See Fig. 1 of https://arxiv.org/abs/1909.09170 for an illustration. The standard setup assumes that the z-axis of the target is aligned anti-parallel\nto the DM wind at (defined to be ), the Earth then \nrotates about a vector which is off . Units : None real(kind=dp), public :: theta_E = 42.0_dp*(pi/180.0_dp) Angle between the Earth's rotation axis and the DM wind. Units : None Type-Bound Procedures procedure, public :: load => load_expt_nml public subroutine load_expt_nml (self, filename, verbose) Loads expt parameters from a namelist. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_expt public subroutine print_expt (self, verbose) Prints expt components. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self logical, optional :: verbose procedure, public :: save => save_expt public subroutine save_expt (self, filename, verbose) Saves expt . Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/expt_t.html"},{"title":"in_med_scr_t – EXCEED-DM ","text":"type, public :: in_med_scr_t Collection of parameters defining how the DM-electron scattering rate\nshould be screened. Contents Variables type include_screen e0 q_tf omega_p alpha n_E n_q n_q_theta n_q_phi E_width q_width numeric_screen_mat numeric_anisotropic_screen_mat anisotropic_screen Type-Bound Procedures screening analytic_screening numeric_screening load_in_med_scr_nml load save print load_computed_dielectric Components Type Visibility Attributes Name Initial character(len=64), public :: type = '' Type of screening to use Options: 'analytic', 'numeric' Will default to including no screening logical, public :: include_screen = .TRUE. Whether or not to include screening effects at all. real(kind=dp), public :: e0 Static dielectric parameter for analytic screening in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : None real(kind=dp), public :: q_tf Thomas Fermi momentum for analytic screening in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : eV real(kind=dp), public :: omega_p Plasma frequency for analytic screening in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : eV real(kind=dp), public :: alpha shape parameter for analytic screening in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : None integer, public :: n_E Number of bins. Numeric screening only. integer, public :: n_q Number of bins. Numeric screening only. integer, public :: n_q_theta Number of bins. Numeric screening only. integer, public :: n_q_phi Number of bins Numeric screening only. real(kind=dp), public :: E_width Width of the bins. Numeric screening only. Units : eV real(kind=dp), public :: q_width Width of the bins. Numeric screening only. Units : eV complex(kind=dp), public, allocatable :: numeric_screen_mat (:,:,:,:) Dim : [ n_E, n_q, n_q_theta, n_q_phi ] Numerically computed screening matrix, binned in [ ] Only used when type = numeric . Units : None complex(kind=dp), public, allocatable :: numeric_anisotropic_screen_mat (:,:,:,:,:,:) Dim : [ n_E, n_q, n_q_theta, n_q_phi, 3, 3 ] Numerically computed anisotropic screening matrix, binned in [ ]. This will be used \nif the input dielectric file is a 3 3 matrix in each bin. Only used when type = numeric . Units : None logical, public :: anisotropic_screen = .FALSE. Flag to check whether the loaded dielectric is a matrix or scalar quantity. If matrix -> True, if scalar -> False. Type-Bound Procedures procedure, public :: screening public function screening (self, q_vec, omega) result(scr) Screening factor in scattering rate calculations. Read more… Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) procedure, public :: analytic_screening public function analytic_screening (self, q_vec, omega) result(scr) Analytic form of the dielectric function. Read more… Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) procedure, public :: numeric_screening public function numeric_screening (self, q_vec, omega) result(scr) Absolute value of the numerically computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) procedure, public :: load_in_med_scr_nml public subroutine load_in_med_scr_nml (self, filename, verbose) Loads in_med_scr parameters from a namelist. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: load => load_in_med_scr public subroutine load_in_med_scr (self, proc_id, root_process, n_proc, io_files, main_control, target_mat, verbose) Loads the in medium screening parameters. If the user specifies\nthat the screening should be computed numerically then exdm_dielectric will\nbe run. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat logical, optional :: verbose procedure, public :: save => save_in_med_scr public subroutine save_in_med_scr (self, filename, verbose) Saves in_med_scr . Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_in_med_scr public subroutine print_in_med_scr (self, verbose) Prints in_med_scr components. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self logical, optional :: verbose procedure, public :: load_computed_dielectric public subroutine load_computed_dielectric (self, filename, verbose) Load the pre-computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/in_med_scr_t.html"},{"title":"material_t – EXCEED-DM ","text":"type, public :: material_t Target material properties. Contents Variables name pc_vol_A pc_vol rho_T_g_per_cm3 rho_T band_gap Type-Bound Procedures load print save Components Type Visibility Attributes Name Initial character(len=64), public :: name = '' Material name real(kind=dp), public :: pc_vol_A Volume of the unit cell pc_vol_A = det(a_vecs) Units : Ang&#94;3 real(kind=dp), public :: pc_vol Volume of the primitive cell Units : eV&#94;(-3) real(kind=dp), public :: rho_T_g_per_cm3 Target density Units : g/cm&#94;3 real(kind=dp), public :: rho_T Target density Units : eV&#94;4 real(kind=dp), public :: band_gap = 0.0_dp Band gap of the target Units : eV Type-Bound Procedures procedure, public :: load => load_material_nml public subroutine load_material_nml (self, filename, verbose) Loads material parameters from a namelist. Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_material public subroutine print_material (self, verbose) Prints material components. Arguments Type Intent Optional Attributes Name class( material_t ) :: self logical, optional :: verbose procedure, public :: save => save_material public subroutine save_material (self, filename, verbose) Saves material . Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"type/material_t.html"},{"title":"PW_dataset_t – EXCEED-DM ","text":"type, public :: PW_dataset_t Stores the metadata of the Bloch wave function coefficients in the Fourier basis, , e.g. number of points, , number of bands, etc and has routines which load the coefficients from an external data file when needed. . Contents Variables n_k n_val n_cond n_G G_grid_red a_vecs_A b_vecs_A k_weight k_grid_red energy_bands_raw Ef_max n_bands q_cut E_cut a_vecs red_to_xyz b_vecs k_red_to_xyz energy_bands G_grid_xyz k_grid_xyz include_spin spin_degen filename q_max_1BZ Type-Bound Procedures load save print load_wfc_FT_ik_no_spin load_wfc_ik_expanded_no_spin load_wfc_FT_ik_spin load_wfc_ik_expanded_spin compute_PW_cutoff do_scissor_correction Components Type Visibility Attributes Name Initial integer, public :: n_k Number of k points integer, public :: n_val Number of valence bands integer, public :: n_cond Number of conduction bands integer, public :: n_G Number of G points integer, public, allocatable :: G_grid_red (:,:) Dim : [n_G, 3] G vectors in reduced coordinates. Note : This G grid is k-independent and assumes that the 's,\nfor each , are defined on the same grid. Units : None real(kind=dp), public :: a_vecs_A (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : Ang real(kind=dp), public :: b_vecs_A (3,3) Reciprocal lattice vector (i, :) is the ith reciprocal lattice vector Units : Ang&#94;(-1) real(kind=dp), public, allocatable :: k_weight (:) Dim : [n_k] Weights of each k point in the k_red grid, must sum to 2 Units : None real(kind=dp), public, allocatable :: k_grid_red (:,:) Dim : [n_k, 3] List of k vectors in reduced coordinates Units : None real(kind=dp), public, allocatable :: energy_bands_raw (:,:) Dim : [n_k, n_bands] Electron energy eigenvalues taken straight from the input file, no scissor \ncorrection performed. Units : eV real(kind=dp), public :: Ef_max = 60.0_dp Maximum electron energy computed for. Units : eV integer, public :: n_bands Total number of bands n_bands = n_cond + n_val real(kind=dp), public :: q_cut Plane wave expansion cutoff Units : eV real(kind=dp), public :: E_cut Energy cooresponding to q_cut E_cut = q_cut* 2/(2 m_elec) Units : eV real(kind=dp), public :: a_vecs (3,3) Primitive lattice vectors (i, :) is the ith primitive lattice vector Units : eV&#94;(-1) real(kind=dp), public :: red_to_xyz (3,3) Matrix converting reduced cooredinate positions to physical xyz cooredinates\nin eV&#94;(-1) via x_xyz = matmul(red_to_xyz, x_red) red_to_xyz = transpose(a_vecs) Units : eV&#94;(-1) real(kind=dp), public :: b_vecs (3,3) Reciprocal lattice vectors (i, :) is the ith reciprocal lattice vector Units : eV real(kind=dp), public :: k_red_to_xyz (3,3) Matrix converting reduced coordinate momentum to physical xyz coordinates\nin eV via k_xyz = matmul(k_red_to_xyz, k_red) k_red_to_xyz = transpose(b_vecs) Units : eV real(kind=dp), public, allocatable :: energy_bands (:,:) Dim : [n_k, n_bands] Scissor corrected electron energy eigenvalues Units : eV real(kind=dp), public, allocatable :: G_grid_xyz (:,:) Dim : [ n_G , 3] G vectors in physical xyz coordinates Units : eV real(kind=dp), public, allocatable :: k_grid_xyz (:,:) Dim : [n_k, 3] List of k vectors in xyz coordinates Units : eV logical, public :: include_spin = .FALSE. Flag declaring whether the wave functions are spin dependent or not real(kind=dp), public :: spin_degen = 2.0_dp Spin degeneracy factor. SI wave functions - 2\nSD wave functions - 1 character(len=512), public :: filename Filename of data real(kind=dp), public :: q_max_1BZ All transitions with q_max_1BZ are restricted to stay within the 1BZ. Units : Type-Bound Procedures procedure, public :: load => load_PW_dataset_hdf5 public subroutine load_PW_dataset_hdf5 (self, filename, verbose) Loads PW_dataset parameters from an hdf5 file. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_PW_dataset public subroutine save_PW_dataset (self, filename, verbose) Saves PW_dataset . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_PW_dataset public subroutine print_PW_dataset (self, filename, verbose) Prints PW_dataset components. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: load_wfc_FT_ik_no_spin public subroutine load_wfc_FT_ik_no_spin (self, i, k, wfc_FT_ik) Loads the spin independent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:) Dim : [n_G] procedure, public :: load_wfc_ik_expanded_no_spin public subroutine load_wfc_ik_expanded_no_spin (self, i, k, FFT_grid, wfc_ik) Loads the spin independent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) procedure, public :: load_wfc_FT_ik_spin public subroutine load_wfc_FT_ik_spin (self, i, k, wfc_FT_ik) Loads the spin dependent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) Dim : [n_G, 2] procedure, public :: load_wfc_ik_expanded_spin public subroutine load_wfc_ik_expanded_spin (self, i, k, FFT_grid, wfc_ik) Loads the spin dependent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (2,FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) procedure, public :: compute_PW_cutoff public subroutine compute_PW_cutoff (self) Computes plane wave expansion parameters, and . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self procedure, public :: do_scissor_correction public subroutine do_scissor_correction (self, band_gap, verbose) Performs a scissor correction to the band structure. This shifts the valence and conduction\n bands independently such that band_gap . Read more… Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self real(kind=dp) :: band_gap logical, optional :: verbose","tags":"","loc":"type/pw_dataset_t.html"},{"title":"width_parameters_t – EXCEED-DM ","text":"type, public :: width_parameters_t Electron lifetime/widths to use in calculations which require the electronic Green's\nfunctions (e.g. absorption calculations). width's are parameterized as and we require that . Contents Variables n n_a n_b n_m a_min a_max log_b_min log_b_max m_max m_min sigma info Type-Bound Procedures load save print get_width Components Type Visibility Attributes Name Initial integer, public :: n = 1 Total number of width parameters. n = n_a x n_b x n_m integer, public :: n_a = 1 Number of parameters. integer, public :: n_b = 1 Number of parameters. integer, public :: n_m = 1 Number of parameters. real(kind=dp), public :: a_min Minimum parameter. Units : eV real(kind=dp), public :: a_max Minimum parameter. Units : eV real(kind=dp), public :: log_b_min Log10 of the minimum parameter. real(kind=dp), public :: log_b_max Log10 of the maximum parameter. real(kind=dp), public :: m_max Maximum parameter. Units : eV real(kind=dp), public :: m_min Minimum parameter. Units : eV real(kind=dp), public :: sigma = 1D10 parameter, energy difference must be within to be\nadded to the rate. real(kind=dp), public, allocatable :: info (:,:) Dim : [ n , 3] Width parameters [a, b, delta_max]. Type-Bound Procedures procedure, public :: load => load_width_parameters_nml public subroutine load_width_parameters_nml (self, filename, verbose) Loads width_parameters parameters from a namelist. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: save => save_width_parameters public subroutine save_width_parameters (self, filename, verbose) Saves width_parameters . Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => print_width_parameters public subroutine print_width_parameters (self, verbose) Prints width_parameters components. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self logical, optional :: verbose procedure, public :: get_width public function get_width (self, id, omega) result(width) Returns for a given id. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self integer :: id real(kind=dp) :: omega Return Value real(kind=dp)","tags":"","loc":"type/width_parameters_t.html"},{"title":"FFT_grid_t – EXCEED-DM ","text":"type, public :: FFT_grid_t Collection of parameters defining the grid the FFT is performed on, \nand how the FFT should be performed. Contents Variables N n_grid q_max plan sym_G_grid_red sym_G_grid_xyz Type-Bound Procedures init save print set_sym_G_grid Components Type Visibility Attributes Name Initial integer, public :: N Number of points in the FFT integer, public :: n_grid (3) Number of points in the FFT in each dimension real(kind=dp), public :: q_max Maximum q for which the FFT is consistent for. See find_q_max Units : integer, public :: plan (8) The FFTW3 plan integer, public, allocatable :: sym_G_grid_red (:,:,:,:) Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] Shifted, symmetric list of G points in FFT grid in reduced coordinates Units : None real(kind=dp), public, allocatable :: sym_G_grid_xyz (:,:,:,:) Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] Shifted, symmetric list of G points in FFT grid in xyz coordinates Units : eV Type-Bound Procedures procedure, public :: init => FFT_grid_init public subroutine FFT_grid_init (self, n_grid, k_red_to_xyz, fb_char, verbose) Initialize an FFT_grid instance. Read more… Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) character(len=1) :: fb_char 'f' for forward rule, 'b' for backwards logical, optional :: verbose procedure, public :: save => FFT_grid_save public subroutine FFT_grid_save (self, filename, verbose) Saves FFT_grid . Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self character(len=*) :: filename logical, optional :: verbose procedure, public :: print => FFT_grid_print public subroutine FFT_grid_print (self, verbose) Prints FFT_grid components. Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self logical, optional :: verbose procedure, public :: set_sym_G_grid => FFT_grid_set_sym_G_grid public subroutine FFT_grid_set_sym_G_grid (self, k_red_to_xyz, verbose) Symmetric FFT grid. Read more… Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose","tags":"","loc":"type/fft_grid_t.html"},{"title":"parallel_manager_t – EXCEED-DM ","text":"type, public :: parallel_manager_t Manages indexing the jobs that each processor needs to do and \ncommunicates the results to the main/root processor. Contents Variables n_jobs n_jobs_per_proc job_table Type-Bound Procedures init create_job_to_2d_ID_table comm_abs_tran_form comm_self_energies comm_abs_rate Components Type Visibility Attributes Name Initial integer, public :: n_jobs Total number of jobs integer, public :: n_jobs_per_proc Number of transitions per processor integer, public, allocatable :: job_table (:,:) Dim : [ n_proc, n_jobs_per_proc ] job_table(i, :) gives the list of job ID's that processor\ni needs to compute for. Type-Bound Procedures procedure, public :: init => parallel_manager_init public subroutine parallel_manager_init (self, n_jobs, verbose) Initializes a parallel_manager instance. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: n_jobs Number of initial states logical, optional :: verbose procedure, public :: create_job_to_2d_ID_table public subroutine create_job_to_2d_ID_table (self, list1, list2, job_id_to_2d_ID_table, verbose) Given two lists, {list1, list2} create a single list which has\nn[list1]*n[list_2] elements, each of which has 4 elements. The first two elements\nare a pair from {list1, list2}, the second two index the value in the first pair, i.e. Read more… Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: list1 (:) integer :: list2 (:) integer :: job_id_to_2d_ID_table (:,:) Dim : [n_jobs, 4] logical, optional :: verbose procedure, public :: comm_abs_tran_form public subroutine comm_abs_tran_form (self, proc_id, root_process, job_id_to_ik, tran_form_1_no_spin_job, tran_form_1_spin_job, tran_form_v_no_spin_job, tran_form_v_spin_job, tran_form_v2_no_spin_job, tran_form_v2_spin_job, tran_form_1_no_spin, tran_form_1_spin, tran_form_v_no_spin, tran_form_v_spin, tran_form_v2_no_spin, tran_form_v2_spin, numerics, verbose) Communicate the transition form factors computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process integer :: job_id_to_ik (:,:) complex(kind=dp) :: tran_form_1_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_1_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin_job (:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v_spin_job (:,:,:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v2_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_1_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_1_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v_spin (:,:,:,:,:,:) Dim : [3, n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v2_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None type( numerics_abs_t ) :: numerics logical, optional :: verbose procedure, public :: comm_self_energies public subroutine comm_self_energies (self, proc_id, root_process, pi_v2_v2_job, pi_1_1_mat_job, pi_vi_vj_job, pi_v2_v2, pi_1_1_mat, pi_vi_vj, verbose) Communicate the self energies computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process complex(kind=dp) :: pi_v2_v2_job (:,:,:) Dim : [n_omega, n_widths, n_tran_per_proc] self energy with two v&#94;2 insertions Units : eV&#94;2 complex(kind=dp) :: pi_1_1_mat_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] self energy, without q_vec's Units : eV&#94;2 complex(kind=dp) :: pi_vi_vj_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] Units : eV&#94;2 complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) logical, optional :: verbose procedure, public :: comm_abs_rate public subroutine comm_abs_rate (self, proc_id, root_process, abs_rate, verbose) Communicate the absorption rate contribution from each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"type/parallel_manager_t.html"},{"title":"save_control – EXCEED-DM","text":"public subroutine save_control(self, filename, verbose) Uses hdf5 info_messages h5lt Saves control . Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_control.html"},{"title":"print_control – EXCEED-DM","text":"public subroutine print_control(self, verbose) Prints control components. Arguments Type Intent Optional Attributes Name class( control_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_control.html"},{"title":"load_control_nml – EXCEED-DM","text":"public subroutine load_control_nml(self, filename, verbose) Loads control parameters from a namelist. Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_control_nml.html"},{"title":"save_io – EXCEED-DM","text":"public subroutine save_io(self, filename, verbose) Uses hdf5 info_messages h5lt Saves io_files . Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_io.html"},{"title":"print_io – EXCEED-DM","text":"public subroutine print_io(self, verbose) Prints io_files components. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_io.html"},{"title":"load_io_nml – EXCEED-DM","text":"public subroutine load_io_nml(self, filename, verbose) Loads io parameters from a namelist. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_io_nml.html"},{"title":"create_output_file – EXCEED-DM","text":"public recursive subroutine create_output_file(io_files, overwrite_output, verbose) Uses hdf5 prec h5lt Creates the output file, if the file already exists, tries to create a new file with a random number\nattached recursively until a number is found. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files logical :: overwrite_output logical, optional :: verbose Contents None","tags":"","loc":"proc/create_output_file.html"},{"title":"calc_abs_Pi_no_spin – EXCEED-DM","text":"public subroutine calc_abs_Pi_no_spin(proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin independent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:) complex(kind=dp) :: tran_form_v_job (:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_abs_pi_no_spin.html"},{"title":"calc_abs_Pi_spin – EXCEED-DM","text":"public subroutine calc_abs_Pi_spin(proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin dependent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:,:,:) complex(kind=dp) :: tran_form_v_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_abs_pi_spin.html"},{"title":"calc_pi_v2_v2_no_spin – EXCEED-DM","text":"public subroutine calc_pi_v2_v2_no_spin(pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown\nthat as (for the gapped targets of\ninterest here). See discussion in calculation of for more details. [TODO] Check if this procedure is valid for or (constant term). Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_v2_v2_no_spin.html"},{"title":"calc_pi_v2_v2_spin – EXCEED-DM","text":"public subroutine calc_pi_v2_v2_spin(pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown\nthat as (for the gapped targets of\ninterest here). See discussion in calculation of for more details. [TODO] Check if this procedure is valid for or (constant term). Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_v2_v2_spin.html"},{"title":"calc_pi_1_1_mat_no_spin – EXCEED-DM","text":"public subroutine calc_pi_1_1_mat_no_spin(pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_1_1_mat_no_spin.html"},{"title":"calc_pi_1_1_mat_spin – EXCEED-DM","text":"public subroutine calc_pi_1_1_mat_spin(pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_1_1_mat_spin.html"},{"title":"calc_pi_vi_vj_no_spin – EXCEED-DM","text":"public subroutine calc_pi_vi_vj_no_spin(pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown\nthat as (for the gapped targets of interest\nhere). If one naively computes numerically you find that as . While alone this does not look problematic since itself is converging, the\ncalculation of other physical quantities, such as the dielectric , will diverge. This is remedied by explicitly only computing the first non-divergent term, which can be shown, see \nhttps://journals.aps.org/prb/pdf/10.1103/PhysRevB.48.11705, to be related to the naive calculation with the addition of a term inside the 1BZ sum. We follow that procedure here. [TODO] Check if this procedure is valid for or (constant term). Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_vi_vj_no_spin.html"},{"title":"calc_pi_vi_vj_spin – EXCEED-DM","text":"public subroutine calc_pi_vi_vj_spin(pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Note: this calculation has some subtleties due to having to take care of divergent terms. Specifically, it can be shown\nthat as (for the gapped targets of interest\nhere). If one naively computes numerically you find that as . While alone this does not look problematic since itself is converging, the\ncalculation of other physical quantities, such as the dielectric , will diverge. This is remedied by explicitly only computing the first non-divergent term, which can be shown, see \nhttps://journals.aps.org/prb/pdf/10.1103/PhysRevB.48.11705, to be related to the naive calculation with the addition of a term inside the 1BZ sum. We follow that procedure here. [TODO] Check if this procedure is valid for or (constant term). Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k Contents None","tags":"","loc":"proc/calc_pi_vi_vj_spin.html"},{"title":"save_self_energies – EXCEED-DM","text":"public subroutine save_self_energies(filename, pi_v2_v2, pi_1_1_mat, pi_vi_vj, verbose) Saves the self energies, . Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/save_self_energies.html"},{"title":"calc_pi_v2_v2 – EXCEED-DM","text":"public interface calc_pi_v2_v2 Contents Module Procedures calc_pi_v2_v2_no_spin calc_pi_v2_v2_spin Module Procedures public subroutine calc_pi_v2_v2_no_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_v2_v2_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k","tags":"","loc":"interface/calc_pi_v2_v2.html"},{"title":"calc_pi_1_1_mat – EXCEED-DM","text":"public interface calc_pi_1_1_mat Contents Module Procedures calc_pi_1_1_mat_no_spin calc_pi_1_1_mat_spin Module Procedures public subroutine calc_pi_1_1_mat_no_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_1_1_mat_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k","tags":"","loc":"interface/calc_pi_1_1_mat.html"},{"title":"calc_pi_vi_vj – EXCEED-DM","text":"public interface calc_pi_vi_vj Contents Module Procedures calc_pi_vi_vj_no_spin calc_pi_vi_vj_spin Module Procedures public subroutine calc_pi_vi_vj_no_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_vi_vj_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k","tags":"","loc":"interface/calc_pi_vi_vj.html"},{"title":"calc_abs_Pi – EXCEED-DM","text":"public interface calc_abs_Pi Contents Module Procedures calc_abs_Pi_no_spin calc_abs_Pi_spin Module Procedures public subroutine calc_abs_Pi_no_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin independent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:) complex(kind=dp) :: tran_form_v_job (:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose public subroutine calc_abs_Pi_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin dependent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:,:,:) complex(kind=dp) :: tran_form_v_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"interface/calc_abs_pi.html"},{"title":"calc_abs_tran_form – EXCEED-DM","text":"public subroutine calc_abs_tran_form(proc_id, root_process, tran_form_1_no_spin_job, tran_form_1_spin_job, tran_form_v_no_spin_job, tran_form_v_spin_job, tran_form_v2_no_spin_job, tran_form_v2_spin_job, PW_dataset, ik_manager, job_id_to_ik, numerics, filename, verbose) Computes all of the transition form factors, (with extra spin indicies if the wave functions are spin dependent) for the \nDM absorption calculation. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_no_spin_job (:,:) complex(kind=dp) :: tran_form_1_spin_job (:,:,:,:) complex(kind=dp) :: tran_form_v_no_spin_job (:,:,:) complex(kind=dp) :: tran_form_v_spin_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_no_spin_job (:,:) complex(kind=dp) :: tran_form_v2_spin_job (:,:,:,:) type(PW_dataset_t) :: PW_dataset type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type( numerics_abs_t ) :: numerics character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_abs_tran_form.html"},{"title":"calc_tran_form_1_no_spin – EXCEED-DM","text":"public subroutine calc_tran_form_1_no_spin(tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent scalar transition form factor: for a given i, i', k. Have this function here for a consistent interface. This vanished by orthogonality of the\nwave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) Contents None","tags":"","loc":"proc/calc_tran_form_1_no_spin.html"},{"title":"calc_tran_form_1_spin – EXCEED-DM","text":"public subroutine calc_tran_form_1_spin(tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent scalar transition form factor: for a given i, i', k. Note: Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) Contents None","tags":"","loc":"proc/calc_tran_form_1_spin.html"},{"title":"calc_tran_form_v_no_spin – EXCEED-DM","text":"public subroutine calc_tran_form_v_no_spin(tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent vector transition form factor: for a given i, i', k. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) Contents None","tags":"","loc":"proc/calc_tran_form_v_no_spin.html"},{"title":"calc_tran_form_v_spin – EXCEED-DM","text":"public subroutine calc_tran_form_v_spin(tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent vector transition form factor: for a given i, i', k. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:,:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) Contents None","tags":"","loc":"proc/calc_tran_form_v_spin.html"},{"title":"calc_tran_form_v2_no_spin – EXCEED-DM","text":"public subroutine calc_tran_form_v2_no_spin(tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent transition form factor: for a given i, i', k. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) Contents None","tags":"","loc":"proc/calc_tran_form_v2_no_spin.html"},{"title":"calc_tran_form_v2_spin – EXCEED-DM","text":"public subroutine calc_tran_form_v2_spin(tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent transition form factor: for a given i, i', k. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) Contents None","tags":"","loc":"proc/calc_tran_form_v2_spin.html"},{"title":"save_tran_form – EXCEED-DM","text":"public subroutine save_tran_form(filename, tran_form_1_no_spin, tran_form_1_spin, tran_form_v_no_spin, tran_form_v_spin, tran_form_v2_no_spin, tran_form_v2_spin, include_spin, verbose) Uses info_messages Saves the transition form factors, , \nwith indicies if the wave functions are spin dependent. Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: tran_form_1_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_1_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v_spin (:,:,:,:,:,:) Dim : [3, n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v2_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None logical :: include_spin logical, optional :: verbose Contents None","tags":"","loc":"proc/save_tran_form.html"},{"title":"calc_tran_form_1 – EXCEED-DM","text":"public interface calc_tran_form_1 Contents Module Procedures calc_tran_form_1_no_spin calc_tran_form_1_spin Module Procedures public subroutine calc_tran_form_1_no_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_1_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:)","tags":"","loc":"interface/calc_tran_form_1.html"},{"title":"calc_tran_form_v – EXCEED-DM","text":"public interface calc_tran_form_v Contents Module Procedures calc_tran_form_v_no_spin calc_tran_form_v_spin Module Procedures public subroutine calc_tran_form_v_no_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:,:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:)","tags":"","loc":"interface/calc_tran_form_v.html"},{"title":"calc_tran_form_v2 – EXCEED-DM","text":"public interface calc_tran_form_v2 Contents Module Procedures calc_tran_form_v2_no_spin calc_tran_form_v2_spin Module Procedures public subroutine calc_tran_form_v2_no_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v2_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:)","tags":"","loc":"interface/calc_tran_form_v2.html"},{"title":"run_exdm_absorption – EXCEED-DM","text":"public subroutine run_exdm_absorption(proc_id, root_process, n_proc, io_files, main_control, target_mat, expt, dm_model, verbose) Computes DM absorption rates. Note : currently specific to valence to conduction transitions Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat type( expt_t ) :: expt type( dm_model_t ) :: dm_model logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_absorption.html"},{"title":"save_abs_rate – EXCEED-DM","text":"public subroutine save_abs_rate(filename, abs_rate, verbose) Save the absorption rate data. Arguments Type Intent Optional Attributes Name character(len=*) :: filename real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/save_abs_rate.html"},{"title":"abs_create_k_id_list – EXCEED-DM","text":"public subroutine abs_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/abs_create_k_id_list.html"},{"title":"abs_create_val_id_list – EXCEED-DM","text":"public subroutine abs_create_val_id_list(self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_val Contents None","tags":"","loc":"proc/abs_create_val_id_list.html"},{"title":"numerics_abs_save – EXCEED-DM","text":"public subroutine numerics_abs_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_abs . Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_abs_save.html"},{"title":"numerics_abs_load_nml – EXCEED-DM","text":"public subroutine numerics_abs_load_nml(self, filename, n_val, n_cond, dm_model, verbose) Loads numerics_abs parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond type( dm_model_t ) :: dm_model logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_abs_load_nml.html"},{"title":"numerics_abs_print – EXCEED-DM","text":"public subroutine numerics_abs_print(self, verbose) Prints numerics_abs components. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_abs_print.html"},{"title":"mb_vel_distribution – EXCEED-DM","text":"public function mb_vel_distribution(v_vec, dm_model, boost_vec_in) result(mb_val) Maxwell-Boltzmann velocity distribution, boosted with . Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model real(kind=dp), optional :: boost_vec_in (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/mb_vel_distribution.html"},{"title":"check_mb_dist_normalization – EXCEED-DM","text":"public subroutine check_mb_dist_normalization(v_mesh, dm_model, boost_vec_in, verbose) Check the integral of the MB velocity distribution. If the samepling is fine\nenough, the value of the integral should be 1. Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_mesh (:,:) type( dm_model_t ) :: dm_model real(kind=dp), optional :: boost_vec_in (3) logical, optional :: verbose Contents None","tags":"","loc":"proc/check_mb_dist_normalization.html"},{"title":"calc_rate_ps – EXCEED-DM","text":"public subroutine calc_rate_ps(pi_1_1_mat, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the pseudoscalar DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_ps.html"},{"title":"calc_rate_scalar – EXCEED-DM","text":"public subroutine calc_rate_scalar(pi_1_1_mat, pi_v2_v2, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the scalar DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_scalar.html"},{"title":"calc_rate_scalar_LO – EXCEED-DM","text":"public subroutine calc_rate_scalar_LO(pi_v2_v2, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the scalar DM absorption rate from the LO contribution, at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_scalar_lo.html"},{"title":"calc_rate_vector – EXCEED-DM","text":"public subroutine calc_rate_vector(pi_1_1_mat, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the vector DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_rate_vector.html"},{"title":"int_to_str – EXCEED-DM","text":"public function int_to_str(num) result(string) Converts an integer to a string. Arguments Type Intent Optional Attributes Name integer :: num Return Value character(len=64) Contents None","tags":"","loc":"proc/int_to_str.html"},{"title":"exdm_shutdown_message – EXCEED-DM","text":"public subroutine exdm_shutdown_message(proc_id, root_process) Uses iso_fortran_env timing Message to display when EXCEED-DM starts. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process Contents None","tags":"","loc":"proc/exdm_shutdown_message.html"},{"title":"print_timing_info – EXCEED-DM","text":"public subroutine print_timing_info(dt, verbose) Uses timing Prints a program timing info. Arguments Type Intent Optional Attributes Name real(kind=dp) :: dt logical, optional :: verbose Contents None","tags":"","loc":"proc/print_timing_info.html"},{"title":"print_warning_message – EXCEED-DM","text":"public subroutine print_warning_message(message, verbose) Prints a warning message. Arguments Type Intent Optional Attributes Name character(len=*) :: message logical, optional :: verbose Contents None","tags":"","loc":"proc/print_warning_message.html"},{"title":"print_error_message – EXCEED-DM","text":"public subroutine print_error_message(message, verbose) Prints an error message. Arguments Type Intent Optional Attributes Name character(len=*) :: message logical, optional :: verbose Contents None","tags":"","loc":"proc/print_error_message.html"},{"title":"exdm_startup_message – EXCEED-DM","text":"public subroutine exdm_startup_message(proc_id, root_process, n_proc, version) Uses iso_fortran_env timing Message to display when EXCEED-DM starts. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc character(len=64) :: version Contents None","tags":"","loc":"proc/exdm_startup_message.html"},{"title":"print_section_seperator – EXCEED-DM","text":"public subroutine print_section_seperator() Prints the section seperator. Arguments None Contents None","tags":"","loc":"proc/print_section_seperator.html"},{"title":"print_error_msg_header – EXCEED-DM","text":"public subroutine print_error_msg_header() Prints the error message header. Arguments None Contents None","tags":"","loc":"proc/print_error_msg_header.html"},{"title":"print_error_msg_seperator – EXCEED-DM","text":"public subroutine print_error_msg_seperator() Prints the error message seperator. Arguments None Contents None","tags":"","loc":"proc/print_error_msg_seperator.html"},{"title":"print_warning_msg_header – EXCEED-DM","text":"public subroutine print_warning_msg_header() Prints the warning message header. Arguments None Contents None","tags":"","loc":"proc/print_warning_msg_header.html"},{"title":"print_warning_msg_seperator – EXCEED-DM","text":"public subroutine print_warning_msg_seperator() Prints the warning message seperator. Arguments None Contents None","tags":"","loc":"proc/print_warning_msg_seperator.html"},{"title":"integrate_log_interpolate – EXCEED-DM","text":"public function integrate_log_interpolate(x_data, dydx_data, x1, x2) result(integral) Given evaluated at a list of points in , numerically integrate between while modelling as a power law between points. Arguments Type Intent Optional Attributes Name real(kind=dp) :: x_data (:) real(kind=dp) :: dydx_data (:) real(kind=dp) :: x1 real(kind=dp) :: x2 Return Value real(kind=dp) Contents None","tags":"","loc":"proc/integrate_log_interpolate.html"},{"title":"Q_func – EXCEED-DM","text":"public function Q_func(x, a, b, Q_max) result(Q) Note : . Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer Contents None","tags":"","loc":"proc/q_func.html"},{"title":"uniform_list – EXCEED-DM","text":"public function uniform_list(N, x1, x2) result(li) Returns a list of N uniformly distributed numbers between x1 and x2 ,\nincluding x1 and x2 . Note : N Arguments Type Intent Optional Attributes Name integer :: N real(kind=dp) :: x1 real(kind=dp) :: x2 Return Value real(kind=dp)\n  (N) Contents None","tags":"","loc":"proc/uniform_list.html"},{"title":"pauli_spin_matrix – EXCEED-DM","text":"public function pauli_spin_matrix(i) result(mat) Returns the th Pauli spin matrix, . Identity matrix is defined as the th component. Arguments Type Intent Optional Attributes Name integer :: i Return Value complex(kind=dp)\n  (2,2) Contents None","tags":"","loc":"proc/pauli_spin_matrix.html"},{"title":"int_method_power_law_interp – EXCEED-DM","text":"public function int_method_power_law_interp(x1, x2, dydx1, dydx2) result(integral) Integration method assuming is a power law between points. The complicated implementation is due to problems when is large. Arguments Type Intent Optional Attributes Name real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: dydx1 real(kind=dp) :: dydx2 Return Value real(kind=dp) Contents None","tags":"","loc":"proc/int_method_power_law_interp.html"},{"title":"integrate_power_law – EXCEED-DM","text":"public function integrate_power_law(b, x1, x2, x_s) result(integral) Integral of a power law function. The complicated implementation is due to problems when is large. Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) Contents None","tags":"","loc":"proc/integrate_power_law.html"},{"title":"power_law_fit – EXCEED-DM","text":"public function power_law_fit(log_x_pts, log_y_pts) result(fit_params) Finds such that . Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/power_law_fit.html"},{"title":"generate_uniform_points_on_sphere – EXCEED-DM","text":"public function generate_uniform_points_on_sphere(n_theta, n_phi) result(angular_mesh) Generates an ( n_theta n_phi ) list of coordinates\nwhich are uniformly distributed on the sphere. Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) Contents None","tags":"","loc":"proc/generate_uniform_points_on_sphere.html"},{"title":"factorial – EXCEED-DM","text":"public function factorial(n) result(fact) function. Arguments Type Intent Optional Attributes Name integer :: n Return Value integer Contents None","tags":"","loc":"proc/factorial.html"},{"title":"sph_harmonic – EXCEED-DM","text":"public recursive function sph_harmonic(l, m, theta, phi) result(y_lm) Spherical harmonic function, with phase convention identical to Mathematica. Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sph_harmonic.html"},{"title":"get_phi – EXCEED-DM","text":"public function get_phi(n_hat) result(phi) Returns the value of a unit direction vector, n_hat . Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_phi.html"},{"title":"get_theta – EXCEED-DM","text":"public function get_theta(n_hat) result(theta) Returns the value of a unit direction vector, n_hat . Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_theta.html"},{"title":"get_max_r_inside_parallelepiped – EXCEED-DM","text":"public function get_max_r_inside_parallelepiped(n_grid, red_to_xyz, verbose) result(r_max) Given a cube of points in reduced coordinates, find the largest sphere which sits inside the parallelipipid in xyz\ncoordinates. The 8 corners of the parallelipipid are related to the 8 corners in reduced coordinates by the transformation\nmatrix, red_to_xyz . This function is useful for: 1) Finding the maximum an FFT is \"consistent\" for. Consider a 2D FFT computed on two square grids in xyz coordinates of dimension, 1) and 2) ,\n so the second grid includes all of the points in the first grid. Now consider two functions, , , coming from the FFT of the same function on these grids, binned in . will\n equal up to some ; in this case , since, e.g., the value of will be different in grid 2 since grid 2 includes all with magnitude ,\n whereas grid 1 only contains some of them (i.e., it's missing ). However all grids larger than grid 1 will contain all and therefore in this example r_max ) q_max corresponds to r_max when the red_to_xyz matrix is set to k_red_to_xyz , and n_grid is the size of the FFT <FFT_grid_t>%n_grid . Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_max_r_inside_parallelepiped.html"},{"title":"get_q_max_1BZ – EXCEED-DM","text":"public function get_q_max_1BZ(k_red_to_xyz, verbose) result(q_max) Given a reduce to xyz transformation matrix for points in k-space, k_red_to_xyz ,\ncompute the radius of the largest sphere which can fit inside, q_max . Arguments Type Intent Optional Attributes Name real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_q_max_1bz.html"},{"title":"calc_eigvals_33 – EXCEED-DM","text":"public subroutine calc_eigvals_33(mat, eigval) Compute the eigenvalues of a 3x3 complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: mat (3,3) complex(kind=dp) :: eigval (3) Contents None","tags":"","loc":"proc/calc_eigvals_33.html"},{"title":"calc_eig_system_33 – EXCEED-DM","text":"public subroutine calc_eig_system_33(mat, eig_val, eig_vec) Compute the eigenvalues and (right) eigenvectors of a complex 3x3 matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: mat (3,3) complex(kind=dp) :: eig_val (3) complex(kind=dp) :: eig_vec (3,3) Contents None","tags":"","loc":"proc/calc_eig_system_33.html"},{"title":"pretty_time_format – EXCEED-DM","text":"public function pretty_time_format(t) result(time_str) Returns a nicely formatted string of the time. Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512) Contents None","tags":"","loc":"proc/pretty_time_format.html"},{"title":"pretty_date_and_time – EXCEED-DM","text":"public function pretty_date_and_time() result(dt_str) Returns a nicely formatted string of the current date and time. Arguments None Return Value character(len=512) Contents None","tags":"","loc":"proc/pretty_date_and_time.html"},{"title":"save_timing_info – EXCEED-DM","text":"public subroutine save_timing_info(filename, dt, verbose) Uses hdf5 h5lt Saves the version number. Arguments Type Intent Optional Attributes Name character(len=*) :: filename real(kind=dp) :: dt logical, optional :: verbose Contents None","tags":"","loc":"proc/save_timing_info.html"},{"title":"dielectric_calc_vc_spin – EXCEED-DM","text":"public subroutine dielectric_calc_vc_spin(di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/dielectric_calc_vc_spin.html"},{"title":"dielectric_calc_vc_no_spin – EXCEED-DM","text":"public subroutine dielectric_calc_vc_no_spin(di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/dielectric_calc_vc_no_spin.html"},{"title":"dielectric_calc_vc – EXCEED-DM","text":"public interface dielectric_calc_vc Contents Module Procedures dielectric_calc_vc_no_spin dielectric_calc_vc_spin Module Procedures public subroutine dielectric_calc_vc_no_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine dielectric_calc_vc_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose","tags":"","loc":"interface/dielectric_calc_vc.html"},{"title":"run_exdm_dielectric – EXCEED-DM","text":"public subroutine run_exdm_dielectric(proc_id, root_process, n_proc, io_files, main_control, target_mat, verbose) Compute the dielectric function, . Note : currently only includes valence conduction contributions. Equations: Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_dielectric.html"},{"title":"time_exdm_dielectric_calc – EXCEED-DM","text":"public subroutine time_exdm_dielectric_calc(FFT_grid, PW_dataset, target_mat, bins, widths, numerics, n_jobs_per_proc, val_id, cond_id, k, kf, verbose) Uses timing mpi Clocks the valence conduction dielectric calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_dielectric_calc.html"},{"title":"save_dielectric – EXCEED-DM","text":"public subroutine save_dielectric(filename, dielectric, verbose) Saves the dielectric. Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: dielectric (:,:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/save_dielectric.html"},{"title":"compute_n_q_bin – EXCEED-DM","text":"public subroutine compute_n_q_bin(self, bins, PW_dataset, verbose) Uses PW_dataset_type math_mod bins_dielectric_type Find the number of points from the uniformly spaced grid that are in each\nin a bin. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self type( bins_dielectric_t ) :: bins type(PW_dataset_t) :: PW_dataset logical, optional :: verbose Contents None","tags":"","loc":"proc/compute_n_q_bin.html"},{"title":"define_q_grid – EXCEED-DM","text":"public subroutine define_q_grid(self, q_max, PW_dataset, FFT_grid) Uses FFT_util PW_dataset_type Given a uniform grid  in the 1BZ for , \nand a uniform grid of 's, finds the uniform lattice of points which have . The fundamental lattice spacing is ,\nwhere is the numebr of points in each direction. Therefore every point\nin the grid is uniquely indexed, index = [1, 1, 1] \n+ once the minimum in the grid is known. We also find the number of points in the\ngrid, . Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self real(kind=dp) :: q_max type(PW_dataset_t) :: PW_dataset type(FFT_grid_t) :: FFT_grid Contents None","tags":"","loc":"proc/define_q_grid.html"},{"title":"dielectric_create_k_id_list – EXCEED-DM","text":"public subroutine dielectric_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/dielectric_create_k_id_list.html"},{"title":"dielectric_create_val_id_list – EXCEED-DM","text":"public subroutine dielectric_create_val_id_list(self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_val Contents None","tags":"","loc":"proc/dielectric_create_val_id_list.html"},{"title":"numerics_dielectric_save – EXCEED-DM","text":"public subroutine numerics_dielectric_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_dielectric . Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_dielectric_save.html"},{"title":"numerics_dielectric_load_nml – EXCEED-DM","text":"public subroutine numerics_dielectric_load_nml(self, filename, n_val, n_cond, verbose) Loads numerics_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_dielectric_load_nml.html"},{"title":"numerics_dielectric_print – EXCEED-DM","text":"public subroutine numerics_dielectric_print(self, verbose) Prints numerics_dielectric components. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_dielectric_print.html"},{"title":"check_dielectric_memory – EXCEED-DM","text":"public subroutine check_dielectric_memory(n, verbose) Uses info_messages Checks to see if the dielectric is going to take up too\nmuch memory. Arguments Type Intent Optional Attributes Name integer :: n logical, optional :: verbose Contents None","tags":"","loc":"proc/check_dielectric_memory.html"},{"title":"save_version – EXCEED-DM","text":"public subroutine save_version(filename, verbose) Uses hdf5 info_messages h5lt Saves the version number. Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_version.html"},{"title":"run_exdm_scatter – EXCEED-DM","text":"public subroutine run_exdm_scatter(proc_id, root_process, n_proc, io_files, main_control, target_mat, expt, dm_model, verbose) Compute the DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat type( expt_t ) :: expt type( dm_model_t ) :: dm_model logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter.html"},{"title":"save_scatter_rates – EXCEED-DM","text":"public subroutine save_scatter_rates(filename, bins, expt, dm_model, binned_rate_init, verbose) Saves the binned and total scattering rates. Arguments Type Intent Optional Attributes Name character(len=*) :: filename type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( dm_model_t ) :: dm_model type( binned_scatter_rate_t ) :: binned_rate_init (:) logical, optional :: verbose Contents None","tags":"","loc":"proc/save_scatter_rates.html"},{"title":"v_minus – EXCEED-DM","text":"public function v_minus(q_vec, mX, vE_vec, omega) result(v_m) Note : assumes . Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/v_minus.html"},{"title":"g_func – EXCEED-DM","text":"public function g_func(q, v_m, dm_model) result(g_fun) Kinematic, function. Units : Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m type( dm_model_t ) :: dm_model Return Value real(kind=dp) Contents None","tags":"","loc":"proc/g_func.html"},{"title":"red_mass – EXCEED-DM","text":"public function red_mass(m1, m2) result(mu) Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) Contents None","tags":"","loc":"proc/red_mass.html"},{"title":"F_med_sq_func – EXCEED-DM","text":"public function F_med_sq_func(q_mag, power) result(F_med_sq_val) Mediator form factor squared, . Units : None Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp) Contents None","tags":"","loc":"proc/f_med_sq_func.html"},{"title":"calc_tff_pw_pw_spin – EXCEED-DM","text":"public subroutine calc_tff_pw_pw_spin(tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin dependent wave functions defined on a uniform grid in the unit cell. TFF = FFT( ) FFT( ) Dim : [ n_FFT_grid ] Units : None Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_tff_pw_pw_spin.html"},{"title":"calc_tff_pw_pw_no_spin – EXCEED-DM","text":"public subroutine calc_tff_pw_pw_no_spin(tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin independent wave functions defined on a uniform grid in the unit cell. TFF = FFT( ) FFT( ) Dim : [ n_FFT_grid ] Units : None Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Contents None","tags":"","loc":"proc/calc_tff_pw_pw_no_spin.html"},{"title":"calc_tff_pw_pw – EXCEED-DM","text":"public interface calc_tff_pw_pw Contents Module Procedures calc_tff_pw_pw_no_spin calc_tff_pw_pw_spin Module Procedures public subroutine calc_tff_pw_pw_no_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin independent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_pw_pw_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin dependent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose","tags":"","loc":"interface/calc_tff_pw_pw.html"},{"title":"exdm_scatter_cc_calc – EXCEED-DM","text":"public subroutine exdm_scatter_cc_calc(binned_rate, FFT_grid, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_i, wfc_fkf, init_id, cond_id, kf, verbose) Compute contributions to the core conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_i (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_cc_calc.html"},{"title":"exdm_scatter_cc_set_n_init – EXCEED-DM","text":"public subroutine exdm_scatter_cc_set_n_init(io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core conduction DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init Contents None","tags":"","loc":"proc/exdm_scatter_cc_set_n_init.html"},{"title":"run_exdm_scatter_cc – EXCEED-DM","text":"public subroutine run_exdm_scatter_cc(n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter_cc.html"},{"title":"time_exdm_scatter_cc_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_cc_calc(FFT_grid, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, n_jobs_per_proc, init_id, cond_id, kf, verbose) Uses timing mpi Clocks the core conduction DM-electron scattering rate calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cc_t ) :: numerics integer :: n_jobs_per_proc integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_cc_calc.html"},{"title":"cc_create_core_id_list – EXCEED-DM","text":"public subroutine cc_create_core_id_list(self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self type( core_electron_t ) :: core_electron Contents None","tags":"","loc":"proc/cc_create_core_id_list.html"},{"title":"cc_create_k_id_list – EXCEED-DM","text":"public subroutine cc_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/cc_create_k_id_list.html"},{"title":"numerics_scatter_cc_save – EXCEED-DM","text":"public subroutine numerics_scatter_cc_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_scatter_cc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_save.html"},{"title":"numerics_scatter_cc_load_nml – EXCEED-DM","text":"public subroutine numerics_scatter_cc_load_nml(self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_load_nml.html"},{"title":"numerics_scatter_cc_print – EXCEED-DM","text":"public subroutine numerics_scatter_cc_print(self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_print.html"},{"title":"exdm_scatter_cc_ext_calc – EXCEED-DM","text":"public subroutine exdm_scatter_cc_ext_calc(binned_rate, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, wfc_FT_fkf, init_id, cond_id, kf, verbose) Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cc_ext_t ) :: numerics complex(kind=dp) :: wfc_FT_fkf (:) integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_cc_ext_calc.html"},{"title":"cc_ext_interpolate_dRdq_to_binned_rate – EXCEED-DM","text":"public subroutine cc_ext_interpolate_dRdq_to_binned_rate(q_list, dRdq, b_rate, q_bin_width) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_list (:) real(kind=dp) :: dRdq (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: q_bin_width Contents None","tags":"","loc":"proc/cc_ext_interpolate_drdq_to_binned_rate.html"},{"title":"exdm_scatter_cc_ext_set_n_init – EXCEED-DM","text":"public subroutine exdm_scatter_cc_ext_set_n_init(io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core conduction (extended) DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init Contents None","tags":"","loc":"proc/exdm_scatter_cc_ext_set_n_init.html"},{"title":"run_exdm_scatter_cc_ext – EXCEED-DM","text":"public subroutine run_exdm_scatter_cc_ext(n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core conduction DM-electron scattering rate by computing . Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter_cc_ext.html"},{"title":"cc_ext_create_core_id_list – EXCEED-DM","text":"public subroutine cc_ext_create_core_id_list(self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction (extended) DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self type( core_electron_t ) :: core_electron Contents None","tags":"","loc":"proc/cc_ext_create_core_id_list.html"},{"title":"cc_ext_create_k_id_list – EXCEED-DM","text":"public subroutine cc_ext_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/cc_ext_create_k_id_list.html"},{"title":"numerics_scatter_cc_ext_save – EXCEED-DM","text":"public subroutine numerics_scatter_cc_ext_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_scatter_cc_ext . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_ext_save.html"},{"title":"numerics_scatter_cc_ext_load_nml – EXCEED-DM","text":"public subroutine numerics_scatter_cc_ext_load_nml(self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_ext_load_nml.html"},{"title":"numerics_scatter_cc_ext_print – EXCEED-DM","text":"public subroutine numerics_scatter_cc_ext_print(self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cc_ext_print.html"},{"title":"exdm_scatter_cf_calc – EXCEED-DM","text":"public subroutine exdm_scatter_cf_calc(binned_rate, core_electron, target_mat, bins, dm_model, expt, in_med_scr, numerics, init_id, w_id, verbose) Compute contributions to the core free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type( core_electron_t ) :: core_electron type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cf_t ) :: numerics integer :: init_id integer :: w_id logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_cf_calc.html"},{"title":"cf_interpolate_dRdw_to_binned_rate – EXCEED-DM","text":"public subroutine cf_interpolate_dRdw_to_binned_rate(w_id, omega_list, dRdw, b_rate, E_bin_width, band_gap) Given and ,\nfind the power law fit parameter, , such that .\nThen integrate this function over each bin, , . Note that is assumed to be zero for . Specific to core free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name integer :: w_id real(kind=dp) :: omega_list (:) real(kind=dp) :: dRdw (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: E_bin_width real(kind=dp) :: band_gap Contents None","tags":"","loc":"proc/cf_interpolate_drdw_to_binned_rate.html"},{"title":"exdm_scatter_cf_set_n_init – EXCEED-DM","text":"public subroutine exdm_scatter_cf_set_n_init(io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core free DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init Contents None","tags":"","loc":"proc/exdm_scatter_cf_set_n_init.html"},{"title":"run_exdm_scatter_cf – EXCEED-DM","text":"public subroutine run_exdm_scatter_cf(n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter_cf.html"},{"title":"numerics_scatter_cf_save – EXCEED-DM","text":"public subroutine numerics_scatter_cf_save(self, filename, verbose) Uses hdf5 h5lt Save numerics_scatter_cf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cf_save.html"},{"title":"numerics_scatter_cf_print – EXCEED-DM","text":"public subroutine numerics_scatter_cf_print(self, verbose) Prints numerics_scatter_cf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cf_print.html"},{"title":"numerics_scatter_cf_load_nml – EXCEED-DM","text":"public subroutine numerics_scatter_cf_load_nml(self, filename, core_electron, verbose) Loads numerics_scatter_cf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename type( core_electron_t ) :: core_electron logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_cf_load_nml.html"},{"title":"cf_create_w_id_list – EXCEED-DM","text":"public subroutine cf_create_w_id_list(self) Specify the indicies for each point that should be included. \nSpecific to the core free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self Contents None","tags":"","loc":"proc/cf_create_w_id_list.html"},{"title":"cf_create_core_id_list – EXCEED-DM","text":"public subroutine cf_create_core_id_list(self, core_electron) Create the list of core id's to compute for. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self type( core_electron_t ) :: core_electron Contents None","tags":"","loc":"proc/cf_create_core_id_list.html"},{"title":"exdm_scatter_vc_calc_spin – EXCEED-DM","text":"public subroutine exdm_scatter_vc_calc_spin(binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin dependent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_vc_calc_spin.html"},{"title":"exdm_scatter_vc_calc_no_spin – EXCEED-DM","text":"public subroutine exdm_scatter_vc_calc_no_spin(binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin independent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_vc_calc_no_spin.html"},{"title":"exdm_scatter_vc_calc – EXCEED-DM","text":"public interface exdm_scatter_vc_calc Contents Module Procedures exdm_scatter_vc_calc_no_spin exdm_scatter_vc_calc_spin Module Procedures public subroutine exdm_scatter_vc_calc_no_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin independent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine exdm_scatter_vc_calc_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin dependent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose","tags":"","loc":"interface/exdm_scatter_vc_calc.html"},{"title":"exdm_scatter_vc_set_n_init – EXCEED-DM","text":"public subroutine exdm_scatter_vc_set_n_init(io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the valence conduction DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init Contents None","tags":"","loc":"proc/exdm_scatter_vc_set_n_init.html"},{"title":"run_exdm_scatter_vc – EXCEED-DM","text":"public subroutine run_exdm_scatter_vc(n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the valence conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter_vc.html"},{"title":"time_exdm_scatter_vc_calc – EXCEED-DM","text":"public subroutine time_exdm_scatter_vc_calc(FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, n_jobs_per_proc, val_id, cond_id, k, kf, verbose) Uses timing mpi Clocks the valence conduction DM-electron scattering rate calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_vc_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Contents None","tags":"","loc":"proc/time_exdm_scatter_vc_calc.html"},{"title":"vc_create_k_id_list – EXCEED-DM","text":"public subroutine vc_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence conduction DM-electron rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/vc_create_k_id_list.html"},{"title":"vc_create_val_id_list – EXCEED-DM","text":"public subroutine vc_create_val_id_list(self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_val Contents None","tags":"","loc":"proc/vc_create_val_id_list.html"},{"title":"numerics_scatter_vc_save – EXCEED-DM","text":"public subroutine numerics_scatter_vc_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_scatter_vc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vc_save.html"},{"title":"numerics_scatter_vc_load_nml – EXCEED-DM","text":"public subroutine numerics_scatter_vc_load_nml(self, filename, n_val, n_cond, verbose) Loads numerics_scatter_vc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vc_load_nml.html"},{"title":"numerics_scatter_vc_print – EXCEED-DM","text":"public subroutine numerics_scatter_vc_print(self, verbose) Prints numerics_scatter_vc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vc_print.html"},{"title":"exdm_scatter_vf_calc – EXCEED-DM","text":"public subroutine exdm_scatter_vf_calc(binned_rate, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, wfc_FT_ik, val_id, k, verbose) Computes the valence to free scattering rate by first computing for a list of values, then interpolates and integrates to get the binned rate\nin bins . Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_vf_t ) :: numerics complex(kind=dp) :: wfc_FT_ik (:) integer :: val_id integer :: k logical, optional :: verbose Contents None","tags":"","loc":"proc/exdm_scatter_vf_calc.html"},{"title":"vf_interpolate_dRdw_to_binned_rate – EXCEED-DM","text":"public subroutine vf_interpolate_dRdw_to_binned_rate(omega_list, dRdw, b_rate, E_bin_width, band_gap) Given a list of values, and at those values, go through adjacent pairs, and ,\nfind the power law fit parameter, , such that .\nThen integrate this function over each bin, , for each . Note that is assumed to be zero for . Specific to valence free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name real(kind=dp) :: omega_list (:) real(kind=dp) :: dRdw (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: E_bin_width real(kind=dp) :: band_gap Contents None","tags":"","loc":"proc/vf_interpolate_drdw_to_binned_rate.html"},{"title":"exdm_scatter_vf_set_n_init – EXCEED-DM","text":"public subroutine exdm_scatter_vf_set_n_init(io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the valence free DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init Contents None","tags":"","loc":"proc/exdm_scatter_vf_set_n_init.html"},{"title":"run_exdm_scatter_vf – EXCEED-DM","text":"public subroutine run_exdm_scatter_vf(n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the valence free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose Contents None","tags":"","loc":"proc/run_exdm_scatter_vf.html"},{"title":"vf_create_k_id_list – EXCEED-DM","text":"public subroutine vf_create_k_id_list(self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence free DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_k Contents None","tags":"","loc":"proc/vf_create_k_id_list.html"},{"title":"vf_create_val_id_list – EXCEED-DM","text":"public subroutine vf_create_val_id_list(self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_val Contents None","tags":"","loc":"proc/vf_create_val_id_list.html"},{"title":"numerics_scatter_vf_save – EXCEED-DM","text":"public subroutine numerics_scatter_vf_save(self, filename, verbose) Uses hdf5 h5lt Saves numerics_scatter_vf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vf_save.html"},{"title":"numerics_scatter_vf_load_nml – EXCEED-DM","text":"public subroutine numerics_scatter_vf_load_nml(self, filename, PW_dataset, verbose) Uses PW_dataset_type math_mod Loads numerics_scatter_vf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename type(PW_dataset_t) :: PW_dataset logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vf_load_nml.html"},{"title":"numerics_scatter_vf_print – EXCEED-DM","text":"public subroutine numerics_scatter_vf_print(self, verbose) Prints numerics_scatter_vf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/numerics_scatter_vf_print.html"},{"title":"binned_scatter_rate_compute_rate – EXCEED-DM","text":"public function binned_scatter_rate_compute_rate(self) result(rate) Sums binned_rate%binned_rate over the bins to get the total rate. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self Return Value real(kind=dp)\n  (size(self%binned_rate,3),size(self%binned_rate,4),size(self%binned_rate,5)) Contents None","tags":"","loc":"proc/binned_scatter_rate_compute_rate.html"},{"title":"binned_scatter_rate_init – EXCEED-DM","text":"public subroutine binned_scatter_rate_init(self, bins, dm_model, expt) Creates a binned_rate object and sets binned_rate%binned_rate = 0. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt Contents None","tags":"","loc":"proc/binned_scatter_rate_init.html"},{"title":"print_bins_dielectric – EXCEED-DM","text":"public subroutine print_bins_dielectric(self, verbose) Uses info_messages Print bins_dielectric components. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_bins_dielectric.html"},{"title":"load_bins_dielectric_nml – EXCEED-DM","text":"public subroutine load_bins_dielectric_nml(self, filename, verbose) Uses info_messages Loads bins_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_bins_dielectric_nml.html"},{"title":"save_bins_dielectric – EXCEED-DM","text":"public subroutine save_bins_dielectric(self, filename, verbose) Uses hdf5 info_messages h5lt Saves bins_dielectric . Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_bins_dielectric.html"},{"title":"print_bins – EXCEED-DM","text":"public subroutine print_bins(self, verbose) Uses info_messages Print bins_scatter components. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_bins.html"},{"title":"load_bins_nml – EXCEED-DM","text":"public subroutine load_bins_nml(self, filename, verbose) Uses info_messages Loads bins_scatter parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_bins_nml.html"},{"title":"save_bins – EXCEED-DM","text":"public subroutine save_bins(self, filename, verbose) Uses hdf5 info_messages h5lt Saves bins_scatter . Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_bins.html"},{"title":"atomic_sto_wf_FT_radial – EXCEED-DM","text":"public function atomic_sto_wf_FT_radial(self, id, k_mag) result(chi) Radial part of atomic_sto_wf . Units : Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/atomic_sto_wf_ft_radial.html"},{"title":"atomic_sto_wf_FT – EXCEED-DM","text":"public function atomic_sto_wf_FT(self, id, k) result(wf_FT) Fourier transform of the atomic wave function which is a sum of STO's. Units : Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config() real(kind=dp) :: k (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/atomic_sto_wf_ft.html"},{"title":"sto_wf_radial – EXCEED-DM","text":"public function sto_wf_radial(n, N0, Z, r) result(wf) Individual Slater Type Orbital (STO) Units : eV&#94;(3/2) Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: N0 real(kind=dp) :: Z real(kind=dp) :: r Return Value real(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_radial.html"},{"title":"sto_wf_FT_radial – EXCEED-DM","text":"public function sto_wf_FT_radial(n, l, norm, Z, k_mag) result(wf_FT) Radial part of the Fourier transform of a Slater type orbital (STO) wave function. Reference : https://en.wikipedia.org/wiki/Slater-type_orbital Units : Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/sto_wf_ft_radial.html"},{"title":"atomic_sto_wf_radial – EXCEED-DM","text":"public function atomic_sto_wf_radial(self, id, r) result(wf) Radial part of atomic_sto_wf . Units : Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: r Return Value real(kind=dp) Contents None","tags":"","loc":"proc/atomic_sto_wf_radial.html"},{"title":"atomic_sto_wf – EXCEED-DM","text":"public function atomic_sto_wf(self, id, x) result(wf) Atomic wave function, summed over individual STO's. Units : Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: x (3) Return Value complex(kind=dp) Contents None","tags":"","loc":"proc/atomic_sto_wf.html"},{"title":"get_sto_dataset_str – EXCEED-DM","text":"public function get_sto_dataset_str(Z, n, l) result(dset_name) Returns the (string) name of the dataset where the RHF STO coefficients are for atom with \nproton number, , and quantum numbers, inside the RHF data file. Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Contents None","tags":"","loc":"proc/get_sto_dataset_str.html"},{"title":"core_bloch_wf_on_grid – EXCEED-DM","text":"public subroutine core_bloch_wf_on_grid(self, n_grid, wf, id, pc_vol, red_to_xyz, shift, k_vec_in, r_cut_in, verbose) Compute the core electron wave functions on a grid inside the primitive cell, summed\nover neighboring unit cells. wf By default, will compute the above assuming and sum over only the nearest \nneighbor unit cells. Units : None Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: n_grid (3) complex(kind=dp) :: wf (n_grid(1),n_grid(2),n_grid(3)) integer :: id real(kind=dp) :: pc_vol real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: r_cut_in logical, optional :: verbose Contents None","tags":"","loc":"proc/core_bloch_wf_on_grid.html"},{"title":"save_core_electron – EXCEED-DM","text":"public subroutine save_core_electron(self, filename, verbose) Saves core_electron . Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_core_electron.html"},{"title":"print_core_electron – EXCEED-DM","text":"public subroutine print_core_electron(self, verbose) Prints core_electron components. Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_core_electron.html"},{"title":"load_core_electron – EXCEED-DM","text":"public subroutine load_core_electron(self, core_elec_config_filename, STO_filename, verbose) Loads core_electron parameters from a namelist.\nget the relevant data for each core state Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: core_elec_config_filename character(len=*) :: STO_filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_core_electron.html"},{"title":"print_dm_model – EXCEED-DM","text":"public subroutine print_dm_model(self, verbose) Prints dm_model components. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_dm_model.html"},{"title":"load_dm_model_nml – EXCEED-DM","text":"public subroutine load_dm_model_nml(self, filename, verbose) Loads dm_model parameters from a namelist. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_dm_model_nml.html"},{"title":"save_dm_model – EXCEED-DM","text":"public subroutine save_dm_model(self, filename, verbose) Saves dm_model . Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_dm_model.html"},{"title":"load_expt_nml – EXCEED-DM","text":"public subroutine load_expt_nml(self, filename, verbose) Uses units info_messages math_mod Loads expt parameters from a namelist. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_expt_nml.html"},{"title":"print_expt – EXCEED-DM","text":"public subroutine print_expt(self, verbose) Uses info_messages Prints expt components. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_expt.html"},{"title":"save_expt – EXCEED-DM","text":"public subroutine save_expt(self, filename, verbose) Uses hdf5 info_messages h5lt Saves expt . Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_expt.html"},{"title":"numeric_screening – EXCEED-DM","text":"public function numeric_screening(self, q_vec, omega) result(scr) Uses math_mod Absolute value of the numerically computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/numeric_screening.html"},{"title":"analytic_screening – EXCEED-DM","text":"public function analytic_screening(self, q_vec, omega) result(scr) Analytic form of the dielectric function. Eq 6 in https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/analytic_screening.html"},{"title":"screening – EXCEED-DM","text":"public function screening(self, q_vec, omega) result(scr) Screening factor in scattering rate calculations. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/screening.html"},{"title":"save_in_med_scr – EXCEED-DM","text":"public subroutine save_in_med_scr(self, filename, verbose) Uses hdf5 info_messages h5lt Saves in_med_scr . Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_in_med_scr.html"},{"title":"print_in_med_scr – EXCEED-DM","text":"public subroutine print_in_med_scr(self, verbose) Uses info_messages Prints in_med_scr components. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_in_med_scr.html"},{"title":"load_in_med_scr_nml – EXCEED-DM","text":"public subroutine load_in_med_scr_nml(self, filename, verbose) Uses info_messages Loads in_med_scr parameters from a namelist. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_in_med_scr_nml.html"},{"title":"load_computed_dielectric – EXCEED-DM","text":"public subroutine load_computed_dielectric(self, filename, verbose) Uses hdf5 info_messages h5lt Load the pre-computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_computed_dielectric.html"},{"title":"load_in_med_scr – EXCEED-DM","text":"public subroutine load_in_med_scr(self, proc_id, root_process, n_proc, io_files, main_control, target_mat, verbose) Uses mpi exdm_dielectric hdf5 h5lt material_type io_input control_input Loads the in medium screening parameters. If the user specifies\nthat the screening should be computed numerically then exdm_dielectric will\nbe run. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat logical, optional :: verbose Contents None","tags":"","loc":"proc/load_in_med_scr.html"},{"title":"print_material – EXCEED-DM","text":"public subroutine print_material(self, verbose) Prints material components. Arguments Type Intent Optional Attributes Name class( material_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_material.html"},{"title":"load_material_nml – EXCEED-DM","text":"public subroutine load_material_nml(self, filename, verbose) Loads material parameters from a namelist. Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_material_nml.html"},{"title":"save_material – EXCEED-DM","text":"public subroutine save_material(self, filename, verbose) Saves material . Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_material.html"},{"title":"load_wfc_ik_expanded_no_spin – EXCEED-DM","text":"public subroutine load_wfc_ik_expanded_no_spin(self, i, k, FFT_grid, wfc_ik) Uses FFT_util Loads the spin independent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) Contents None","tags":"","loc":"proc/load_wfc_ik_expanded_no_spin.html"},{"title":"load_wfc_ik_expanded_spin – EXCEED-DM","text":"public subroutine load_wfc_ik_expanded_spin(self, i, k, FFT_grid, wfc_ik) Uses FFT_util Loads the spin dependent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (2,FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) Contents None","tags":"","loc":"proc/load_wfc_ik_expanded_spin.html"},{"title":"load_wfc_FT_ik_no_spin – EXCEED-DM","text":"public subroutine load_wfc_FT_ik_no_spin(self, i, k, wfc_FT_ik) Loads the spin independent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:) Dim : [n_G] Contents None","tags":"","loc":"proc/load_wfc_ft_ik_no_spin.html"},{"title":"load_wfc_FT_ik_spin – EXCEED-DM","text":"public subroutine load_wfc_FT_ik_spin(self, i, k, wfc_FT_ik) Loads the spin dependent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) Dim : [n_G, 2] Contents None","tags":"","loc":"proc/load_wfc_ft_ik_spin.html"},{"title":"load_PW_dataset_hdf5 – EXCEED-DM","text":"public subroutine load_PW_dataset_hdf5(self, filename, verbose) Uses math_mod Loads PW_dataset parameters from an hdf5 file. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_pw_dataset_hdf5.html"},{"title":"save_PW_dataset – EXCEED-DM","text":"public subroutine save_PW_dataset(self, filename, verbose) Saves PW_dataset . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_pw_dataset.html"},{"title":"print_PW_dataset – EXCEED-DM","text":"public subroutine print_PW_dataset(self, filename, verbose) Prints PW_dataset components. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/print_pw_dataset.html"},{"title":"compute_PW_cutoff – EXCEED-DM","text":"public subroutine compute_PW_cutoff(self) Computes plane wave expansion parameters, and . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self Contents None","tags":"","loc":"proc/compute_pw_cutoff.html"},{"title":"do_scissor_correction – EXCEED-DM","text":"public subroutine do_scissor_correction(self, band_gap, verbose) Performs a scissor correction to the band structure. This shifts the valence and conduction\n bands independently such that band_gap . Additionally, shifts all of the bands by a constant value such that the valence band maximum, , is equal to 0. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self real(kind=dp) :: band_gap logical, optional :: verbose Contents None","tags":"","loc":"proc/do_scissor_correction.html"},{"title":"get_width – EXCEED-DM","text":"public function get_width(self, id, omega) result(width) Returns for a given id. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self integer :: id real(kind=dp) :: omega Return Value real(kind=dp) Contents None","tags":"","loc":"proc/get_width.html"},{"title":"save_width_parameters – EXCEED-DM","text":"public subroutine save_width_parameters(self, filename, verbose) Uses hdf5 info_messages h5lt Saves width_parameters . Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/save_width_parameters.html"},{"title":"print_width_parameters – EXCEED-DM","text":"public subroutine print_width_parameters(self, verbose) Uses info_messages Prints width_parameters components. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/print_width_parameters.html"},{"title":"load_width_parameters_nml – EXCEED-DM","text":"public subroutine load_width_parameters_nml(self, filename, verbose) Uses info_messages math_mod Loads width_parameters parameters from a namelist. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/load_width_parameters_nml.html"},{"title":"FFT_grid_print – EXCEED-DM","text":"public subroutine FFT_grid_print(self, verbose) Prints FFT_grid components. Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self logical, optional :: verbose Contents None","tags":"","loc":"proc/fft_grid_print.html"},{"title":"FFT_grid_save – EXCEED-DM","text":"public subroutine FFT_grid_save(self, filename, verbose) Uses hdf5 h5lt Saves FFT_grid . Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self character(len=*) :: filename logical, optional :: verbose Contents None","tags":"","loc":"proc/fft_grid_save.html"},{"title":"FFT_grid_init – EXCEED-DM","text":"public subroutine FFT_grid_init(self, n_grid, k_red_to_xyz, fb_char, verbose) Uses math_mod Initialize an FFT_grid instance. 1) Find 2) Initialize the FFT plan. (Default: FFTW3 'patient' planning)\n3) Set the symmetric FFT grids. Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) character(len=1) :: fb_char 'f' for forward rule, 'b' for backwards logical, optional :: verbose Contents None","tags":"","loc":"proc/fft_grid_init.html"},{"title":"FFT_grid_set_sym_G_grid – EXCEED-DM","text":"public subroutine FFT_grid_set_sym_G_grid(self, k_red_to_xyz, verbose) Symmetric FFT grid. Standard convention for FFTs is to compute for frequencies 0 -> N-1. \nThis subroutine creates a map which takes the larger half of the positive\nfrequencies and maps then back to negative values, for a symmetric G grid. Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Contents None","tags":"","loc":"proc/fft_grid_set_sym_g_grid.html"},{"title":"set_fft_plan_forward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_forward_3d(n_grid, fft_plan) Sets the FFTW3 FFT plan with a 'forwards' convention. See https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029 . Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_forward_3d.html"},{"title":"set_fft_plan_backward_3d – EXCEED-DM","text":"public subroutine set_fft_plan_backward_3d(n_grid, fft_plan) Sets the FFTW3 FFT plan with a 'backwards' convention. See https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029 . Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) Contents None","tags":"","loc":"proc/set_fft_plan_backward_3d.html"},{"title":"G_red_to_FFT_G_grid_index – EXCEED-DM","text":"public subroutine G_red_to_FFT_G_grid_index(n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \ngrid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3) Contents None","tags":"","loc":"proc/g_red_to_fft_g_grid_index.html"},{"title":"comm_reduce_dielectric – EXCEED-DM","text":"public subroutine comm_reduce_dielectric(proc_id, root_process, dielectric, verbose) Communicate the dielectric pieces computed at each processor to the total dielectric\non the main processor using MPI_Reduce. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: dielectric (:,:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/comm_reduce_dielectric.html"},{"title":"comm_abs_rate – EXCEED-DM","text":"public subroutine comm_abs_rate(self, proc_id, root_process, abs_rate, verbose) Communicate the absorption rate contribution from each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/comm_abs_rate.html"},{"title":"comm_self_energies – EXCEED-DM","text":"public subroutine comm_self_energies(self, proc_id, root_process, pi_v2_v2_job, pi_1_1_mat_job, pi_vi_vj_job, pi_v2_v2, pi_1_1_mat, pi_vi_vj, verbose) Communicate the self energies computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process complex(kind=dp) :: pi_v2_v2_job (:,:,:) Dim : [n_omega, n_widths, n_tran_per_proc] self energy with two v&#94;2 insertions Units : eV&#94;2 complex(kind=dp) :: pi_1_1_mat_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] self energy, without q_vec's Units : eV&#94;2 complex(kind=dp) :: pi_vi_vj_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] Units : eV&#94;2 complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) logical, optional :: verbose Contents None","tags":"","loc":"proc/comm_self_energies.html"},{"title":"comm_abs_tran_form – EXCEED-DM","text":"public subroutine comm_abs_tran_form(self, proc_id, root_process, job_id_to_ik, tran_form_1_no_spin_job, tran_form_1_spin_job, tran_form_v_no_spin_job, tran_form_v_spin_job, tran_form_v2_no_spin_job, tran_form_v2_spin_job, tran_form_1_no_spin, tran_form_1_spin, tran_form_v_no_spin, tran_form_v_spin, tran_form_v2_no_spin, tran_form_v2_spin, numerics, verbose) Uses numerics_abs Communicate the transition form factors computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process integer :: job_id_to_ik (:,:) complex(kind=dp) :: tran_form_1_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_1_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin_job (:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v_spin_job (:,:,:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v2_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_1_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_1_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v_spin (:,:,:,:,:,:) Dim : [3, n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v2_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None type( numerics_abs_t ) :: numerics logical, optional :: verbose Contents None","tags":"","loc":"proc/comm_abs_tran_form.html"},{"title":"comm_reduce_binned_rate_init – EXCEED-DM","text":"public subroutine comm_reduce_binned_rate_init(proc_id, root_process, binned_rate_init, verbose) Uses binned_scatter_rate_type Return and sum all of the binned_rate_init's from the processors using MPI_Reduce. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (:) logical, optional :: verbose Contents None","tags":"","loc":"proc/comm_reduce_binned_rate_init.html"},{"title":"create_job_to_2d_ID_table – EXCEED-DM","text":"public subroutine create_job_to_2d_ID_table(self, list1, list2, job_id_to_2d_ID_table, verbose) Given two lists, {list1, list2} create a single list which has\nn[list1]*n[list_2] elements, each of which has 4 elements. The first two elements\nare a pair from {list1, list2}, the second two index the value in the first pair, i.e. job_id_to_2d_ID_table(1, 1) = list1(1) job_id_to_2d_ID_table(1, 2) = list2(7) job_id_to_2d_ID_table(1, 3) = 1 job_id_to_2d_ID_table(1, 4) = 7 Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: list1 (:) integer :: list2 (:) integer :: job_id_to_2d_ID_table (:,:) Dim : [n_jobs, 4] logical, optional :: verbose Contents None","tags":"","loc":"proc/create_job_to_2d_id_table.html"},{"title":"parallel_manager_init – EXCEED-DM","text":"public subroutine parallel_manager_init(self, n_jobs, verbose) Initializes a parallel_manager instance. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: n_jobs Number of initial states logical, optional :: verbose Contents None","tags":"","loc":"proc/parallel_manager_init.html"},{"title":"control_input – EXCEED-DM","text":"Collection of variables controlling how EXCEED-DM is run, i.e. what is computed and how it is computed. Uses info_messages Contents Derived Types control_t Subroutines save_control print_control load_control_nml Derived Types type, public :: control_t Stores all variables associated with the program control. Components Type Visibility Attributes Name Initial character(len=64), public :: process = '' character(len=64), public :: calc_mode = '' logical, public :: timer = .TRUE. Optional Read more… logical, public :: quiet = .FALSE. Don't print any output logical, public :: overwrite_output = .FALSE. If .TRUE. the output file will be overwritten Type-Bound Procedures procedure, public :: print => print_control procedure, public :: load => load_control_nml procedure, public :: save => save_control Subroutines public subroutine save_control (self, filename, verbose) Saves control . Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_control (self, verbose) Prints control components. Arguments Type Intent Optional Attributes Name class( control_t ) :: self logical, optional :: verbose public subroutine load_control_nml (self, filename, verbose) Loads control parameters from a namelist. Arguments Type Intent Optional Attributes Name class( control_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/control_input.html"},{"title":"io_input – EXCEED-DM","text":"Input and output filenames. Uses info_messages Contents Derived Types io_files_t Subroutines save_io print_io load_io_nml create_output_file Derived Types type, public :: io_files_t All input and output filenames. Components Type Visibility Attributes Name Initial character(len=512), public :: nml_input_filename = '' Namelist input filename character(len=512), public :: PW_data_filename = '' Bloch wave function coefficient file name character(len=64), public :: run_description = '' description of the calculation character(len=512), public :: out_folder = '.' Ouput folder character(len=512), public :: out_filename = '' Output filename Read more… character(len=512), public :: sto_data_filename = '' Input file specifying the Slater type orbital (sto)\nwave function coefficients for the core electron\nstates character(len=512), public :: core_elec_config_filename = '' File specifying the core electron configuration character(len=512), public :: dielectric_filename = '' File specifying the dielectric function. If the dielectric\nwill be computed this will be where the computed values are\nstored. If this file already exists, the dielectric function\nwill be loaded from this file. Type-Bound Procedures procedure, public :: print => print_io procedure, public :: load => load_io_nml procedure, public :: save => save_io Subroutines public subroutine save_io (self, filename, verbose) Saves io_files . Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_io (self, verbose) Prints io_files components. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self logical, optional :: verbose public subroutine load_io_nml (self, filename, verbose) Loads io parameters from a namelist. Arguments Type Intent Optional Attributes Name class( io_files_t ) :: self character(len=*) :: filename logical, optional :: verbose public recursive subroutine create_output_file (io_files, overwrite_output, verbose) Creates the output file, if the file already exists, tries to create a new file with a random number\nattached recursively until a number is found. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files logical :: overwrite_output logical, optional :: verbose","tags":"","loc":"module/io_input.html"},{"title":"abs_calc_PI – EXCEED-DM","text":"Computes self-energies, , for absorption rate calculations. Uses prec mpi PW_dataset_type MPI_util hdf5 width_parameters_type constants h5lt dm_model_type material_type Contents Interfaces calc_pi_v2_v2 calc_pi_1_1_mat calc_pi_vi_vj calc_abs_Pi Subroutines calc_abs_Pi_no_spin calc_abs_Pi_spin calc_pi_v2_v2_no_spin calc_pi_v2_v2_spin calc_pi_1_1_mat_no_spin calc_pi_1_1_mat_spin calc_pi_vi_vj_no_spin calc_pi_vi_vj_spin save_self_energies Interfaces public interface calc_pi_v2_v2 public subroutine calc_pi_v2_v2_no_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_v2_v2_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public interface calc_pi_1_1_mat public subroutine calc_pi_1_1_mat_no_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_1_1_mat_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public interface calc_pi_vi_vj public subroutine calc_pi_vi_vj_no_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_vi_vj_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public interface calc_abs_Pi public subroutine calc_abs_Pi_no_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin independent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:) complex(kind=dp) :: tran_form_v_job (:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose public subroutine calc_abs_Pi_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin dependent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:,:,:) complex(kind=dp) :: tran_form_v_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose Subroutines public subroutine calc_abs_Pi_no_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin independent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:) complex(kind=dp) :: tran_form_v_job (:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose public subroutine calc_abs_Pi_spin (proc_id, root_process, tran_form_1_job, tran_form_v_job, tran_form_v2_job, pi_v2_v2, pi_vi_vj, pi_1_1_mat, ik_manager, job_id_to_ik, PW_dataset, widths, dm_model, target_mat, filename, verbose) Compute the self energies with spin dependent wave functions. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_job (:,:,:,:) complex(kind=dp) :: tran_form_v_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_job (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type(PW_dataset_t) :: PW_dataset type( width_parameters_t ) :: widths type( dm_model_t ) :: dm_model type( material_t ) :: target_mat character(len=*) :: filename logical, optional :: verbose public subroutine calc_pi_v2_v2_no_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_v2_v2_spin (pi_v2_v2, tran_form_v2, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: tran_form_v2 (:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_1_1_mat_no_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_1_1_mat_spin (pi_1_1_mat, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_vi_vj_no_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin independent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine calc_pi_vi_vj_spin (pi_vi_vj, tran_form_v, dm_model, widths, PW_dataset, target_mat, val_id, k) Compute from spin dependent wave functions. Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_vi_vj (:,:,:,:) complex(kind=dp) :: tran_form_v (:,:,:,:) type( dm_model_t ) :: dm_model type( width_parameters_t ) :: widths type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat integer :: val_id integer :: k public subroutine save_self_energies (filename, pi_v2_v2, pi_1_1_mat, pi_vi_vj, verbose) Saves the self energies, . Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) logical, optional :: verbose","tags":"","loc":"module/abs_calc_pi.html"},{"title":"abs_tran_form_calc – EXCEED-DM","text":"Computes the transition form factors, , for absorption rate calculation. Uses prec PW_dataset_type numerics_abs MPI_util constants Contents Interfaces calc_tran_form_1 calc_tran_form_v calc_tran_form_v2 Subroutines calc_abs_tran_form calc_tran_form_1_no_spin calc_tran_form_1_spin calc_tran_form_v_no_spin calc_tran_form_v_spin calc_tran_form_v2_no_spin calc_tran_form_v2_spin save_tran_form Interfaces public interface calc_tran_form_1 public subroutine calc_tran_form_1_no_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_1_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) public interface calc_tran_form_v public subroutine calc_tran_form_v_no_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:,:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) public interface calc_tran_form_v2 public subroutine calc_tran_form_v2_no_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v2_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) Subroutines public subroutine calc_abs_tran_form (proc_id, root_process, tran_form_1_no_spin_job, tran_form_1_spin_job, tran_form_v_no_spin_job, tran_form_v_spin_job, tran_form_v2_no_spin_job, tran_form_v2_spin_job, PW_dataset, ik_manager, job_id_to_ik, numerics, filename, verbose) Computes all of the transition form factors, (with extra spin indicies if the wave functions are spin dependent) for the \nDM absorption calculation. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: tran_form_1_no_spin_job (:,:) complex(kind=dp) :: tran_form_1_spin_job (:,:,:,:) complex(kind=dp) :: tran_form_v_no_spin_job (:,:,:) complex(kind=dp) :: tran_form_v_spin_job (:,:,:,:,:) complex(kind=dp) :: tran_form_v2_no_spin_job (:,:) complex(kind=dp) :: tran_form_v2_spin_job (:,:,:,:) type(PW_dataset_t) :: PW_dataset type( parallel_manager_t ) :: ik_manager integer :: job_id_to_ik (:,:) type( numerics_abs_t ) :: numerics character(len=*) :: filename logical, optional :: verbose public subroutine calc_tran_form_1_no_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_1_spin (tran_form_1, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent scalar transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_1 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) public subroutine calc_tran_form_v_no_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v_spin (tran_form_v, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent vector transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v (:,:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) public subroutine calc_tran_form_v2_no_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin independent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:) complex(kind=dp) :: wfc_FT_fk (:) public subroutine calc_tran_form_v2_spin (tran_form_v2, PW_dataset, val_id, cond_id, k, wfc_FT_ik, wfc_FT_fk) Computes the spin dependent transition form factor: Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp) :: tran_form_v2 (:,:) type(PW_dataset_t) :: PW_dataset integer :: val_id integer :: cond_id integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) complex(kind=dp) :: wfc_FT_fk (:,:) public subroutine save_tran_form (filename, tran_form_1_no_spin, tran_form_1_spin, tran_form_v_no_spin, tran_form_v_spin, tran_form_v2_no_spin, tran_form_v2_spin, include_spin, verbose) Saves the transition form factors, , \nwith indicies if the wave functions are spin dependent. Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: tran_form_1_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_1_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v_spin (:,:,:,:,:,:) Dim : [3, n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v2_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None logical :: include_spin logical, optional :: verbose","tags":"","loc":"module/abs_tran_form_calc.html"},{"title":"exdm_absorption – EXCEED-DM","text":"Computes DM absorption rates. Note : currently specific to valence to conduction transitions Uses prec mpi PW_dataset_type numerics_abs rate_calc_vector rate_calc_scalar rate_calc_scalar_LO dm_model_type material_type MPI_util expt_type abs_tran_form_calc abs_calc_PI control_input hdf5 width_parameters_type h5lt rate_calc_ps io_input Contents Subroutines run_exdm_absorption save_abs_rate Subroutines public subroutine run_exdm_absorption (proc_id, root_process, n_proc, io_files, main_control, target_mat, expt, dm_model, verbose) Computes DM absorption rates. Read more… Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat type( expt_t ) :: expt type( dm_model_t ) :: dm_model logical, optional :: verbose public subroutine save_abs_rate (filename, abs_rate, verbose) Save the absorption rate data. Arguments Type Intent Optional Attributes Name character(len=*) :: filename real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"module/exdm_absorption.html"},{"title":"numerics_abs – EXCEED-DM","text":"Numerics parameters specific to DM absorption rate calculations. Uses physics_abs_functions info_messages math_mod Contents Derived Types numerics_abs_t Subroutines abs_create_k_id_list abs_create_val_id_list numerics_abs_save numerics_abs_load_nml numerics_abs_print Derived Types type, public :: numerics_abs_t Numerics parameters specific to DM absorption calculations. Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_k] Read more… logical, public :: save_tran_form = .FALSE. If .TRUE. will save the transition form factors to the output file. integer, public :: n_v Number of points in integration over integer, public :: n_v_theta Number of points in integration over integer, public :: n_v_phi Number of points in integration over real(kind=dp), public, allocatable :: v_angular_mesh (:,:) Dim : [ n_v_theta*n_v_phi, 2] Read more… real(kind=dp), public, allocatable :: v_list (:) Dim : [n_v] Read more… real(kind=dp), public, allocatable :: v_mesh (:,:) Dim : [ n_v n_v_theta n_v_phi, 3] Read more… Type-Bound Procedures procedure, public :: print => numerics_abs_print procedure, public :: load => numerics_abs_load_nml procedure, public :: save => numerics_abs_save procedure, public :: create_val_id_list => abs_create_val_id_list procedure, public :: create_k_id_list => abs_create_k_id_list Subroutines public subroutine abs_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_k public subroutine abs_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the DM absorption rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self integer :: n_val public subroutine numerics_abs_save (self, filename, verbose) Saves numerics_abs . Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_abs_load_nml (self, filename, n_val, n_cond, dm_model, verbose) Loads numerics_abs parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond type( dm_model_t ) :: dm_model logical, optional :: verbose public subroutine numerics_abs_print (self, verbose) Prints numerics_abs components. Arguments Type Intent Optional Attributes Name class( numerics_abs_t ) :: self logical, optional :: verbose","tags":"","loc":"module/numerics_abs.html"},{"title":"physics_abs_functions – EXCEED-DM","text":"Physics functions needed for DM absorption rate calcuations. Uses constants prec dm_model_type Contents Functions mb_vel_distribution Subroutines check_mb_dist_normalization Functions public function mb_vel_distribution (v_vec, dm_model, boost_vec_in) result(mb_val) Maxwell-Boltzmann velocity distribution, boosted with . Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model real(kind=dp), optional :: boost_vec_in (3) Return Value real(kind=dp) Subroutines public subroutine check_mb_dist_normalization (v_mesh, dm_model, boost_vec_in, verbose) Check the integral of the MB velocity distribution. If the samepling is fine\nenough, the value of the integral should be 1. Arguments Type Intent Optional Attributes Name real(kind=dp) :: v_mesh (:,:) type( dm_model_t ) :: dm_model real(kind=dp), optional :: boost_vec_in (3) logical, optional :: verbose","tags":"","loc":"module/physics_abs_functions.html"},{"title":"rate_calc_ps – EXCEED-DM","text":"Compute the pseudoscalar DM absorption rate. Uses prec numerics_abs width_parameters_type math_mod expt_type constants dm_model_type physics_abs_functions material_type Contents Subroutines calc_rate_ps Subroutines public subroutine calc_rate_ps (pi_1_1_mat, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the pseudoscalar DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"module/rate_calc_ps.html"},{"title":"rate_calc_scalar – EXCEED-DM","text":"Compute the scalar DM absorption rate. Uses prec numerics_abs width_parameters_type math_mod expt_type constants dm_model_type physics_abs_functions material_type Contents Subroutines calc_rate_scalar Subroutines public subroutine calc_rate_scalar (pi_1_1_mat, pi_v2_v2, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the scalar DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_v2_v2 (:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"module/rate_calc_scalar.html"},{"title":"rate_calc_scalar_LO – EXCEED-DM","text":"Compute the scalar DM absorption rate (leading order contribution, from ), only). Uses prec numerics_abs width_parameters_type math_mod expt_type constants dm_model_type physics_abs_functions material_type Contents Subroutines calc_rate_scalar_LO Subroutines public subroutine calc_rate_scalar_LO (pi_v2_v2, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the scalar DM absorption rate from the LO contribution, at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_v2_v2 (:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"module/rate_calc_scalar_lo.html"},{"title":"rate_calc_vector – EXCEED-DM","text":"Compute the vector DM absorption rate. Uses prec numerics_abs width_parameters_type math_mod expt_type constants dm_model_type physics_abs_functions material_type Contents Subroutines calc_rate_vector Subroutines public subroutine calc_rate_vector (pi_1_1_mat, v_vec, dm_model, expt, widths, target_mat, numerics, abs_rate, verbose) Compute the vector DM absorption rate at a given . Arguments Type Intent Optional Attributes Name complex(kind=dp) :: pi_1_1_mat (:,:,:,:) real(kind=dp) :: v_vec (3) type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( width_parameters_t ) :: widths type( material_t ) :: target_mat type( numerics_abs_t ) :: numerics real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose","tags":"","loc":"module/rate_calc_vector.html"},{"title":"constants – EXCEED-DM","text":"Collection of useful constants: . Uses prec Contents Variables m_elec alpha_EM a0 pi ii e_EM Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: m_elec = 511.0e3_dp Electron mass Units : eV real(kind=dp), public, parameter :: alpha_EM = 1.0_dp/137.0_dp Fine structure constant real(kind=dp), public, parameter :: a0 = 2.681336e-4_dp Bohr radius Units : eV&#94;(-1) real(kind=dp), public, parameter :: pi = 4.0_dp*atan(1.0_dp) complex(kind=dp), public, parameter :: ii = (0.0_dp, 1.0_dp) Imaginary unit real(kind=dp), public, parameter :: e_EM = sqrt(4*pi*alpha_EM) Unit of electric charge","tags":"","loc":"module/constants.html"},{"title":"info_messages – EXCEED-DM","text":"Procedures for printing program information and errrors/warnings. Contents Variables sec_length Functions int_to_str Subroutines exdm_shutdown_message print_timing_info print_warning_message print_error_message exdm_startup_message print_section_seperator print_error_msg_header print_error_msg_seperator print_warning_msg_header print_warning_msg_seperator Variables Type Visibility Attributes Name Initial integer, public :: sec_length = 80 Functions public function int_to_str (num) result(string) Converts an integer to a string. Arguments Type Intent Optional Attributes Name integer :: num Return Value character(len=64) Subroutines public subroutine exdm_shutdown_message (proc_id, root_process) Message to display when EXCEED-DM starts. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process public subroutine print_timing_info (dt, verbose) Prints a program timing info. Arguments Type Intent Optional Attributes Name real(kind=dp) :: dt logical, optional :: verbose public subroutine print_warning_message (message, verbose) Prints a warning message. Arguments Type Intent Optional Attributes Name character(len=*) :: message logical, optional :: verbose public subroutine print_error_message (message, verbose) Prints an error message. Arguments Type Intent Optional Attributes Name character(len=*) :: message logical, optional :: verbose public subroutine exdm_startup_message (proc_id, root_process, n_proc, version) Message to display when EXCEED-DM starts. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc character(len=64) :: version public subroutine print_section_seperator () Prints the section seperator. Arguments None public subroutine print_error_msg_header () Prints the error message header. Arguments None public subroutine print_error_msg_seperator () Prints the error message seperator. Arguments None public subroutine print_warning_msg_header () Prints the warning message header. Arguments None public subroutine print_warning_msg_seperator () Prints the warning message seperator. Arguments None","tags":"","loc":"module/info_messages.html"},{"title":"math_mod – EXCEED-DM","text":"Collection of math functions. Uses constants special_functions prec Contents Functions integrate_log_interpolate Q_func uniform_list pauli_spin_matrix int_method_power_law_interp integrate_power_law power_law_fit generate_uniform_points_on_sphere factorial sph_harmonic get_phi get_theta get_max_r_inside_parallelepiped get_q_max_1BZ Subroutines calc_eigvals_33 calc_eig_system_33 Functions public function integrate_log_interpolate (x_data, dydx_data, x1, x2) result(integral) Given evaluated at a list of points in , numerically integrate between while modelling as a power law between points. Arguments Type Intent Optional Attributes Name real(kind=dp) :: x_data (:) real(kind=dp) :: dydx_data (:) real(kind=dp) :: x1 real(kind=dp) :: x2 Return Value real(kind=dp) public function Q_func (x, a, b, Q_max) result(Q) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: a real(kind=dp) :: b integer :: Q_max Return Value integer public function uniform_list (N, x1, x2) result(li) Returns a list of N uniformly distributed numbers between x1 and x2 ,\nincluding x1 and x2 . Read more… Arguments Type Intent Optional Attributes Name integer :: N real(kind=dp) :: x1 real(kind=dp) :: x2 Return Value real(kind=dp)\n  (N) public function pauli_spin_matrix (i) result(mat) Returns the th Pauli spin matrix, . Identity matrix is defined as the th component. Arguments Type Intent Optional Attributes Name integer :: i Return Value complex(kind=dp)\n  (2,2) public function int_method_power_law_interp (x1, x2, dydx1, dydx2) result(integral) Integration method assuming is a power law between points. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: dydx1 real(kind=dp) :: dydx2 Return Value real(kind=dp) public function integrate_power_law (b, x1, x2, x_s) result(integral) Integral of a power law function. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: b real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_s Return Value real(kind=dp) public function power_law_fit (log_x_pts, log_y_pts) result(fit_params) Finds such that . Arguments Type Intent Optional Attributes Name real(kind=dp) :: log_x_pts (2) real(kind=dp) :: log_y_pts (2) Return Value real(kind=dp) public function generate_uniform_points_on_sphere (n_theta, n_phi) result(angular_mesh) Generates an ( n_theta n_phi ) list of coordinates\nwhich are uniformly distributed on the sphere. Arguments Type Intent Optional Attributes Name integer :: n_theta integer :: n_phi Return Value real(kind=dp)\n  (n_theta*n_phi,2) public function factorial (n) result(fact) function. Arguments Type Intent Optional Attributes Name integer :: n Return Value integer public recursive function sph_harmonic (l, m, theta, phi) result(y_lm) Spherical harmonic function, with phase convention identical to Mathematica. Arguments Type Intent Optional Attributes Name integer :: l integer :: m real(kind=dp) :: theta real(kind=dp) :: phi Return Value complex(kind=dp) public function get_phi (n_hat) result(phi) Returns the value of a unit direction vector, n_hat . Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) public function get_theta (n_hat) result(theta) Returns the value of a unit direction vector, n_hat . Arguments Type Intent Optional Attributes Name real(kind=dp) :: n_hat (3) Return Value real(kind=dp) public function get_max_r_inside_parallelepiped (n_grid, red_to_xyz, verbose) result(r_max) Given a cube of points in reduced coordinates, find the largest sphere which sits inside the parallelipipid in xyz\ncoordinates. The 8 corners of the parallelipipid are related to the 8 corners in reduced coordinates by the transformation\nmatrix, red_to_xyz . Read more… Arguments Type Intent Optional Attributes Name integer :: n_grid (3) real(kind=dp) :: red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp) public function get_q_max_1BZ (k_red_to_xyz, verbose) result(q_max) Given a reduce to xyz transformation matrix for points in k-space, k_red_to_xyz ,\ncompute the radius of the largest sphere which can fit inside, q_max . Arguments Type Intent Optional Attributes Name real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose Return Value real(kind=dp) Subroutines public subroutine calc_eigvals_33 (mat, eigval) Compute the eigenvalues of a 3x3 complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: mat (3,3) complex(kind=dp) :: eigval (3) public subroutine calc_eig_system_33 (mat, eig_val, eig_vec) Compute the eigenvalues and (right) eigenvectors of a complex 3x3 matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: mat (3,3) complex(kind=dp) :: eig_val (3) complex(kind=dp) :: eig_vec (3,3)","tags":"","loc":"module/math_mod.html"},{"title":"prec – EXCEED-DM","text":"Double precision (dp) definition. Uses iso_fortran_env Contents None","tags":"","loc":"module/prec.html"},{"title":"timing – EXCEED-DM","text":"Useful functions for timing a program. Uses prec Contents Variables time delta_t Functions pretty_time_format pretty_date_and_time Subroutines save_timing_info Variables Type Visibility Attributes Name Initial real(kind=dp), public :: time (100) holds raw timing variables real(kind=dp), public :: delta_t (100) holds difference in timing variables Functions public function pretty_time_format (t) result(time_str) Returns a nicely formatted string of the time. Arguments Type Intent Optional Attributes Name real(kind=dp) :: t Return Value character(len=512) public function pretty_date_and_time () result(dt_str) Returns a nicely formatted string of the current date and time. Arguments None Return Value character(len=512) Subroutines public subroutine save_timing_info (filename, dt, verbose) Saves the version number. Arguments Type Intent Optional Attributes Name character(len=*) :: filename real(kind=dp) :: dt logical, optional :: verbose","tags":"","loc":"module/timing.html"},{"title":"units – EXCEED-DM","text":"Unit conversion factors. To convert a variable from units to units: var_y = x_to_y * var_x. Uses prec Contents Variables inv_Ang_to_eV inv_eV_to_cm Ang_to_inv_eV g_to_eV kg_to_eV inv_cm_to_eV eV_to_inv_cm km_per_sec_to_none yr_to_inv_eV Variables Type Visibility Attributes Name Initial real(kind=dp), public :: inv_Ang_to_eV = 1973.37_dp real(kind=dp), public :: inv_eV_to_cm = 1.97327e-5_dp real(kind=dp), public :: Ang_to_inv_eV = 5.068e-4_dp real(kind=dp), public :: g_to_eV = 5.61e32_dp real(kind=dp), public :: kg_to_eV = 5.61e35_dp real(kind=dp), public :: inv_cm_to_eV = 1.97327e-5_dp real(kind=dp), public :: eV_to_inv_cm = 5.06773e4_dp real(kind=dp), public :: km_per_sec_to_none = 3.33563e-6_dp real(kind=dp), public :: yr_to_inv_eV = 4.7912e22_dp","tags":"","loc":"module/units.html"},{"title":"calc_dielectric_vc – EXCEED-DM","text":"Compute contributions to the dielectric, , from valence conduction\ntransitions. Uses FFT_util prec PW_dataset_type dm_model_type transition_form_factor width_parameters_type numerics_dielectric math_mod expt_type constants units material_type bins_dielectric_type Contents Interfaces dielectric_calc_vc Subroutines dielectric_calc_vc_spin dielectric_calc_vc_no_spin Interfaces public interface dielectric_calc_vc public subroutine dielectric_calc_vc_no_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine dielectric_calc_vc_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Subroutines public subroutine dielectric_calc_vc_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin dependent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine dielectric_calc_vc_no_spin (di, FFT_grid, PW_dataset, target_mat, bins, widths, numerics, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the dielectric, , from valence conduction\ntransitions with spin independent wave functions. Arguments Type Intent Optional Attributes Name complex(kind=dp) :: di (:,:,:,:) type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose","tags":"","loc":"module/calc_dielectric_vc.html"},{"title":"exdm_dielectric – EXCEED-DM","text":"Compute the dielectric function, . Note : currently only includes valence conduction contributions. Equations: Uses FFT_util prec mpi PW_dataset_type MPI_util calc_dielectric_vc width_parameters_type numerics_dielectric expt_type control_input dm_model_type io_input material_type bins_dielectric_type Contents Subroutines run_exdm_dielectric time_exdm_dielectric_calc save_dielectric Subroutines public subroutine run_exdm_dielectric (proc_id, root_process, n_proc, io_files, main_control, target_mat, verbose) Compute the dielectric function, . Read more… Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat logical, optional :: verbose public subroutine time_exdm_dielectric_calc (FFT_grid, PW_dataset, target_mat, bins, widths, numerics, n_jobs_per_proc, val_id, cond_id, k, kf, verbose) Clocks the valence conduction dielectric calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_dielectric_t ) :: bins type( width_parameters_t ) :: widths type( numerics_dielectric_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine save_dielectric (filename, dielectric, verbose) Saves the dielectric. Arguments Type Intent Optional Attributes Name character(len=*) :: filename complex(kind=dp) :: dielectric (:,:,:,:) logical, optional :: verbose","tags":"","loc":"module/exdm_dielectric.html"},{"title":"numerics_dielectric – EXCEED-DM","text":"Numerics parameters specific to the dielectric calculation. Uses prec info_messages Contents Derived Types numerics_dielectric_t Subroutines compute_n_q_bin define_q_grid dielectric_create_k_id_list dielectric_create_val_id_list numerics_dielectric_save numerics_dielectric_load_nml numerics_dielectric_print check_dielectric_memory Derived Types type, public :: numerics_dielectric_t Numerics parameters specific to the dielectric calculation. Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_k] Read more… integer, public :: n_k_vec (3) Number of vectors in each direction. real(kind=dp), public :: q_grid_min (3) Offset parameter to map coordinates to\nindicies. integer, public :: n_q_grid (3) Number of points in the q grid with integer, public, allocatable :: n_q_bin (:,:,:) Dim : [n_q, n_q_theta, n_q_phi] Read more… Type-Bound Procedures procedure, public :: print => numerics_dielectric_print procedure, public :: load => numerics_dielectric_load_nml procedure, public :: save => numerics_dielectric_save procedure, public :: create_val_id_list => dielectric_create_val_id_list procedure, public :: create_k_id_list => dielectric_create_k_id_list procedure, public :: define_q_grid procedure, public :: compute_n_q_bin Subroutines public subroutine compute_n_q_bin (self, bins, PW_dataset, verbose) Find the number of points from the uniformly spaced grid that are in each\nin a bin. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self type( bins_dielectric_t ) :: bins type(PW_dataset_t) :: PW_dataset logical, optional :: verbose public subroutine define_q_grid (self, q_max, PW_dataset, FFT_grid) Given a uniform grid  in the 1BZ for , \nand a uniform grid of 's, finds the uniform lattice of points which have . Read more… Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self real(kind=dp) :: q_max type(PW_dataset_t) :: PW_dataset type(FFT_grid_t) :: FFT_grid public subroutine dielectric_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_k public subroutine dielectric_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the dielectric calculation. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self integer :: n_val public subroutine numerics_dielectric_save (self, filename, verbose) Saves numerics_dielectric . Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_dielectric_load_nml (self, filename, n_val, n_cond, verbose) Loads numerics_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose public subroutine numerics_dielectric_print (self, verbose) Prints numerics_dielectric components. Arguments Type Intent Optional Attributes Name class( numerics_dielectric_t ) :: self logical, optional :: verbose public subroutine check_dielectric_memory (n, verbose) Checks to see if the dielectric is going to take up too\nmuch memory. Arguments Type Intent Optional Attributes Name integer :: n logical, optional :: verbose","tags":"","loc":"module/numerics_dielectric.html"},{"title":"version_control – EXCEED-DM","text":"Keeps track of the current version of the program. Contents Variables version Subroutines save_version Variables Type Visibility Attributes Name Initial character(len=64), public :: version = \"0.2.8\" Subroutines public subroutine save_version (filename, verbose) Saves the version number. Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/version_control.html"},{"title":"exdm_scatter – EXCEED-DM","text":"Compute the DM-electron scattering rate. Uses exdm_scatter_cf prec mpi dm_model_type exdm_scatter_cc exdm_scatter_cc_ext MPI_util hdf5 binned_scatter_rate_type expt_type exdm_scatter_vf bins_scatter_type h5lt in_med_scr_type exdm_scatter_vc material_type io_input control_input Contents Subroutines run_exdm_scatter save_scatter_rates Subroutines public subroutine run_exdm_scatter (proc_id, root_process, n_proc, io_files, main_control, target_mat, expt, dm_model, verbose) Compute the DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat type( expt_t ) :: expt type( dm_model_t ) :: dm_model logical, optional :: verbose public subroutine save_scatter_rates (filename, bins, expt, dm_model, binned_rate_init, verbose) Saves the binned and total scattering rates. Arguments Type Intent Optional Attributes Name character(len=*) :: filename type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( dm_model_t ) :: dm_model type( binned_scatter_rate_t ) :: binned_rate_init (:) logical, optional :: verbose","tags":"","loc":"module/exdm_scatter.html"},{"title":"physics_scatter_functions – EXCEED-DM","text":"Physics functions needed for DM-electron scattering rate calcuations. Uses units constants prec dm_model_type Contents Functions v_minus g_func red_mass F_med_sq_func Functions public function v_minus (q_vec, mX, vE_vec, omega) result(v_m) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_vec (3) real(kind=dp) :: mX real(kind=dp) :: vE_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function g_func (q, v_m, dm_model) result(g_fun) Kinematic, function. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q real(kind=dp) :: v_m type( dm_model_t ) :: dm_model Return Value real(kind=dp) public function red_mass (m1, m2) result(mu) Arguments Type Intent Optional Attributes Name real(kind=dp) :: m1 real(kind=dp) :: m2 Return Value real(kind=dp) public function F_med_sq_func (q_mag, power) result(F_med_sq_val) Mediator form factor squared, . Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_mag real(kind=dp) :: power Return Value real(kind=dp)","tags":"","loc":"module/physics_scatter_functions.html"},{"title":"transition_form_factor – EXCEED-DM","text":"Define general scattering operators such that the scattering rate for\nany DM model can be computed. This will generalize the transition form factor (TFF) defined as All spin independent results come from . Note that this quantity is different \nthan the mediator form factor and screening factor, both of which can be set independently of this function. Each that the user can specify will have a unique index. A catalog will be kept of all the operators and their corresponding index. The calculation can become more difficult technically depending on the operator so a hierarchy will be kept in\norder to simplify the calculation when possible. TODO: For now we will assume that only a single T_if needs to be computed. Future work could improve on this by\nsetting up wrapper functions which compute multiple T's and sum them. This will be necessary when the scattering operator\nhas more than one term, e.g. . Catalog : 1 -  \\mathcal{O} = 1  [ vc (SI/SD), cc (SI) ] 2 -  \\mathcal{O} = \\mathbf{S}_e  [vc (SD)] Notes : Bracketed quantities indicate what transition types are currently supported, s indicates its only\nsupported for spin dependent wave functions. Uses constants prec math_mod Contents Interfaces calc_tff_pw_pw Subroutines calc_tff_pw_pw_spin calc_tff_pw_pw_no_spin Interfaces public interface calc_tff_pw_pw public subroutine calc_tff_pw_pw_no_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin independent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_pw_pw_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin dependent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose Subroutines public subroutine calc_tff_pw_pw_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin dependent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (2,n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose public subroutine calc_tff_pw_pw_no_spin (tff_id, TFF, wfc_i, wfc_f, n_FFT_grid, FFT_plan, verbose) Compute the transition form factor between two spin independent wave functions defined on a uniform grid in the unit cell. Read more… Arguments Type Intent Optional Attributes Name integer :: tff_id (2) real(kind=dp) :: TFF (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_i (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) complex(kind=dp) :: wfc_f (n_FFT_grid(1),n_FFT_grid(2),n_FFT_grid(3)) integer :: n_FFT_grid (3) integer :: FFT_plan (8) logical, optional :: verbose","tags":"","loc":"module/transition_form_factor.html"},{"title":"calc_exdm_scatter_cc – EXCEED-DM","text":"Compute contributions to the core conduction DM-electron scattering rate. Uses FFT_util prec PW_dataset_type dm_model_type physics_scatter_functions transition_form_factor binned_scatter_rate_type math_mod expt_type constants core_electron_type units bins_scatter_type in_med_scr_type material_type Contents Subroutines exdm_scatter_cc_calc Subroutines public subroutine exdm_scatter_cc_calc (binned_rate, FFT_grid, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_i, wfc_fkf, init_id, cond_id, kf, verbose) Compute contributions to the core conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_i (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_cc.html"},{"title":"exdm_scatter_cc – EXCEED-DM","text":"Compute the core conduction DM-electron scattering rate. Uses FFT_util prec mpi PW_dataset_type calc_exdm_scatter_cc MPI_util binned_scatter_rate_type expt_type core_electron_type info_messages in_med_scr_type numerics_scatter_cc dm_model_type io_input material_type control_input Contents Subroutines exdm_scatter_cc_set_n_init run_exdm_scatter_cc time_exdm_scatter_cc_calc Subroutines public subroutine exdm_scatter_cc_set_n_init (io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core conduction DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init public subroutine run_exdm_scatter_cc (n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose public subroutine time_exdm_scatter_cc_calc (FFT_grid, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, n_jobs_per_proc, init_id, cond_id, kf, verbose) Clocks the core conduction DM-electron scattering rate calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cc_t ) :: numerics integer :: n_jobs_per_proc integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_cc.html"},{"title":"numerics_scatter_cc – EXCEED-DM","text":"Numerics parameters specific to the core conduction DM-electron scattering rate calculation. Uses core_electron_type info_messages Contents Derived Types numerics_scatter_cc_t Subroutines cc_create_core_id_list cc_create_k_id_list numerics_scatter_cc_save numerics_scatter_cc_load_nml numerics_scatter_cc_print Derived Types type, public :: numerics_scatter_cc_t Numerics parameters specific to the core conduction DM-electron scattering rate calculation. Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. integer, public :: n_cond_max = 0 Maximum number of conduction bands. integer, public :: n_FFT_grid (3) = [0, 0, 0] Dimension of the FFT grid to compute on. integer, public, allocatable :: core_id_list (:) Dim : [n_init] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_init] Read more… Type-Bound Procedures procedure, public :: print => numerics_scatter_cc_print procedure, public :: load => numerics_scatter_cc_load_nml procedure, public :: save => numerics_scatter_cc_save procedure, public :: create_k_id_list => cc_create_k_id_list procedure, public :: create_core_id_list => cc_create_core_id_list Subroutines public subroutine cc_create_core_id_list (self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self type( core_electron_t ) :: core_electron public subroutine cc_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self integer :: n_k public subroutine numerics_scatter_cc_save (self, filename, verbose) Saves numerics_scatter_cc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_scatter_cc_load_nml (self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose public subroutine numerics_scatter_cc_print (self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_t ) :: self logical, optional :: verbose","tags":"","loc":"module/numerics_scatter_cc.html"},{"title":"calc_exdm_scatter_cc_ext – EXCEED-DM","text":"Compute contributions to the core conduction (extended) DM-electron scattering \nrate. Uses prec PW_dataset_type dm_model_type numerics_scatter_cc_ext physics_scatter_functions transition_form_factor binned_scatter_rate_type math_mod expt_type constants core_electron_type units bins_scatter_type in_med_scr_type material_type Contents Subroutines exdm_scatter_cc_ext_calc cc_ext_interpolate_dRdq_to_binned_rate Subroutines public subroutine exdm_scatter_cc_ext_calc (binned_rate, core_electron, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, wfc_FT_fkf, init_id, cond_id, kf, verbose) Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type( core_electron_t ) :: core_electron type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cc_ext_t ) :: numerics complex(kind=dp) :: wfc_FT_fkf (:) integer :: init_id integer :: cond_id integer :: kf logical, optional :: verbose public subroutine cc_ext_interpolate_dRdq_to_binned_rate (q_list, dRdq, b_rate, q_bin_width) Arguments Type Intent Optional Attributes Name real(kind=dp) :: q_list (:) real(kind=dp) :: dRdq (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: q_bin_width","tags":"","loc":"module/calc_exdm_scatter_cc_ext.html"},{"title":"exdm_scatter_cc_ext – EXCEED-DM","text":"Compute the core conduction DM-electron scattering rate by computing . Uses FFT_util prec mpi PW_dataset_type numerics_scatter_cc_ext MPI_util calc_exdm_scatter_cc_ext binned_scatter_rate_type expt_type core_electron_type info_messages in_med_scr_type dm_model_type io_input material_type control_input Contents Subroutines exdm_scatter_cc_ext_set_n_init run_exdm_scatter_cc_ext Subroutines public subroutine exdm_scatter_cc_ext_set_n_init (io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core conduction (extended) DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init public subroutine run_exdm_scatter_cc_ext (n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core conduction DM-electron scattering rate by computing . Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_cc_ext.html"},{"title":"numerics_scatter_cc_ext – EXCEED-DM","text":"Uses core_electron_type info_messages Contents Derived Types numerics_scatter_cc_ext_t Subroutines cc_ext_create_core_id_list cc_ext_create_k_id_list numerics_scatter_cc_ext_save numerics_scatter_cc_ext_load_nml numerics_scatter_cc_ext_print Derived Types type, public :: numerics_scatter_cc_ext_t Numerics parameters specific to the core conduction DM-electron scattering rate calculation. Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. integer, public :: n_cond_max = 0 Maximum number of conduction bands. integer, public, allocatable :: core_id_list (:) Dim : [n_init] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_init] Read more… integer, public :: n_q real(kind=dp), public :: q_min integer, public :: n_q_theta = 1 integer, public :: n_q_phi = 1 real(kind=dp), public, allocatable :: q_angular_mesh (:,:) Dim : [ n_q_theta x n_kf_phi , 2 ] Read more… Type-Bound Procedures procedure, public :: print => numerics_scatter_cc_ext_print procedure, public :: load => numerics_scatter_cc_ext_load_nml procedure, public :: save => numerics_scatter_cc_ext_save procedure, public :: create_k_id_list => cc_ext_create_k_id_list procedure, public :: create_core_id_list => cc_ext_create_core_id_list Subroutines public subroutine cc_ext_create_core_id_list (self, core_electron) Specify the indicies for each core state that should be included. \nSpecific to the  core conduction (extended) DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self type( core_electron_t ) :: core_electron public subroutine cc_ext_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the core conduction DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self integer :: n_k public subroutine numerics_scatter_cc_ext_save (self, filename, verbose) Saves numerics_scatter_cc_ext . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_scatter_cc_ext_load_nml (self, filename, n_cond, verbose) Loads numerics_scatter_cc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self character(len=*) :: filename integer :: n_cond logical, optional :: verbose public subroutine numerics_scatter_cc_ext_print (self, verbose) Prints numerics_scatter_cc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cc_ext_t ) :: self logical, optional :: verbose","tags":"","loc":"module/numerics_scatter_cc_ext.html"},{"title":"calc_exdm_scatter_cf – EXCEED-DM","text":"Compute contributions to the core free DM-electron scattering rate. Uses prec physics_scatter_functions dm_model_type numerics_scatter_cf transition_form_factor binned_scatter_rate_type math_mod expt_type constants core_electron_type units bins_scatter_type in_med_scr_type material_type Contents Subroutines exdm_scatter_cf_calc cf_interpolate_dRdw_to_binned_rate Subroutines public subroutine exdm_scatter_cf_calc (binned_rate, core_electron, target_mat, bins, dm_model, expt, in_med_scr, numerics, init_id, w_id, verbose) Compute contributions to the core free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type( core_electron_t ) :: core_electron type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_cf_t ) :: numerics integer :: init_id integer :: w_id logical, optional :: verbose public subroutine cf_interpolate_dRdw_to_binned_rate (w_id, omega_list, dRdw, b_rate, E_bin_width, band_gap) Given and ,\nfind the power law fit parameter, , such that .\nThen integrate this function over each bin, , . Note that is assumed to be zero for . Read more… Arguments Type Intent Optional Attributes Name integer :: w_id real(kind=dp) :: omega_list (:) real(kind=dp) :: dRdw (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: E_bin_width real(kind=dp) :: band_gap","tags":"","loc":"module/calc_exdm_scatter_cf.html"},{"title":"exdm_scatter_cf – EXCEED-DM","text":"Compute the core free DM-electron scattering rate. Uses FFT_util prec mpi PW_dataset_type numerics_scatter_cf calc_exdm_scatter_cf MPI_util binned_scatter_rate_type expt_type core_electron_type info_messages in_med_scr_type dm_model_type io_input material_type control_input Contents Subroutines exdm_scatter_cf_set_n_init run_exdm_scatter_cf Subroutines public subroutine exdm_scatter_cf_set_n_init (io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the core free DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init public subroutine run_exdm_scatter_cf (n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the core free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_cf.html"},{"title":"numerics_scatter_cf – EXCEED-DM","text":"Numerics parameters specific to the core free DM-electron scattering rate calculation. Uses core_electron_type prec info_messages Contents Derived Types numerics_scatter_cf_t Subroutines numerics_scatter_cf_save numerics_scatter_cf_print numerics_scatter_cf_load_nml cf_create_w_id_list cf_create_core_id_list Derived Types type, public :: numerics_scatter_cf_t Numerics parameters specific to the core free DM-electron scattering rate calculation. Components Type Visibility Attributes Name Initial integer, public :: n_principal_max = 10 Maximum principal quantum number to include. integer, public :: n_principal_min = 1 Minimum principal quantum number to include. character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use Read more… real(kind=dp), public, allocatable :: Zeff (:) Dim : [ n_state ] Read more… integer, public :: n_kf_theta = 1 Number of points in the integration of integer, public :: n_kf_phi = 1 Number of points in the integration of real(kind=dp), public, allocatable :: kf_angular_mesh (:,:) Dim : [ n_kf_theta*n_kf_phi, 2 ] Read more… integer, public :: n_omega Number of points to compute for. The core -> free scattering\nrate calculation is done by computing n_omega values of between Read more… real(kind=dp), public, allocatable :: omega_list (:) List of points to compute for. The core -> free scattering\nrate calculation is done by computing n_omega values of between Read more… integer, public :: n_ki = 2 Number of points in integration over integer, public :: n_ki_theta = 1 Number of points in integration over integer, public :: n_ki_phi = 1 Number of points in integration over real(kind=dp), public, allocatable :: ki_angular_mesh (:,:) Dim : [ n_ki_theta*n_ki_phi, 2 ] Read more… real(kind=dp), public :: ki_s = 100.0_dp Scale parameter for maximum to integrate over. Read more… real(kind=dp), public :: ki_min = 1.0e3_dp Minimum in the integration over Read more… integer, public, allocatable :: core_id_list (:) Dim : [n_init] Read more… integer, public, allocatable :: w_id_list (:) Dim : [n_omega] Read more… real(kind=dp), public :: Ef_min Smallest final electron energy to compute for. Type-Bound Procedures procedure, public :: print => numerics_scatter_cf_print procedure, public :: load => numerics_scatter_cf_load_nml procedure, public :: save => numerics_scatter_cf_save procedure, public :: create_core_id_list => cf_create_core_id_list procedure, public :: create_w_id_list => cf_create_w_id_list Subroutines public subroutine numerics_scatter_cf_save (self, filename, verbose) Save numerics_scatter_cf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_scatter_cf_print (self, verbose) Prints numerics_scatter_cf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self logical, optional :: verbose public subroutine numerics_scatter_cf_load_nml (self, filename, core_electron, verbose) Loads numerics_scatter_cf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self character(len=*) :: filename type( core_electron_t ) :: core_electron logical, optional :: verbose public subroutine cf_create_w_id_list (self) Specify the indicies for each point that should be included. \nSpecific to the core free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self public subroutine cf_create_core_id_list (self, core_electron) Create the list of core id's to compute for. Arguments Type Intent Optional Attributes Name class( numerics_scatter_cf_t ) :: self type( core_electron_t ) :: core_electron","tags":"","loc":"module/numerics_scatter_cf.html"},{"title":"calc_exdm_scatter_vc – EXCEED-DM","text":"Compute contributions to the valence conduction DM-electron scattering rate. Uses FFT_util prec PW_dataset_type dm_model_type physics_scatter_functions transition_form_factor binned_scatter_rate_type math_mod expt_type constants units bins_scatter_type in_med_scr_type material_type Contents Interfaces exdm_scatter_vc_calc Subroutines exdm_scatter_vc_calc_spin exdm_scatter_vc_calc_no_spin Interfaces public interface exdm_scatter_vc_calc public subroutine exdm_scatter_vc_calc_no_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin independent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine exdm_scatter_vc_calc_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin dependent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose Subroutines public subroutine exdm_scatter_vc_calc_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin dependent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose public subroutine exdm_scatter_vc_calc_no_spin (binned_rate, FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, wfc_ik, wfc_fkf, val_id, cond_id, k, kf, verbose) Compute contributions to the valence conduction \nDM-electron scattering rate from spin independent wave functions. Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr complex(kind=dp) :: wfc_ik (:,:,:) complex(kind=dp) :: wfc_fkf (:,:,:) integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose","tags":"","loc":"module/calc_exdm_scatter_vc.html"},{"title":"exdm_scatter_vc – EXCEED-DM","text":"Compute the valence conduction DM-electron scattering rate. Uses FFT_util prec mpi PW_dataset_type numerics_scatter_vc MPI_util calc_exdm_scatter_vc binned_scatter_rate_type expt_type in_med_scr_type dm_model_type io_input material_type control_input Contents Subroutines exdm_scatter_vc_set_n_init run_exdm_scatter_vc time_exdm_scatter_vc_calc Subroutines public subroutine exdm_scatter_vc_set_n_init (io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the valence conduction DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init public subroutine run_exdm_scatter_vc (n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the valence conduction DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose public subroutine time_exdm_scatter_vc_calc (FFT_grid, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, n_jobs_per_proc, val_id, cond_id, k, kf, verbose) Clocks the valence conduction DM-electron scattering rate calculation\nby running a smaller version of the program. Arguments Type Intent Optional Attributes Name type(FFT_grid_t) :: FFT_grid type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_vc_t ) :: numerics integer :: n_jobs_per_proc integer :: val_id integer :: cond_id integer :: k integer :: kf logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_vc.html"},{"title":"numerics_scatter_vc – EXCEED-DM","text":"Numerics parameters specific to the valence conduction DM-electron scattering rate calculation. Uses info_messages Contents Derived Types numerics_scatter_vc_t Subroutines vc_create_k_id_list vc_create_val_id_list numerics_scatter_vc_save numerics_scatter_vc_load_nml numerics_scatter_vc_print Derived Types type, public :: numerics_scatter_vc_t Numerics parameters specific to the valence conduction DM-electron scattering rate calculation. Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands integer, public :: n_cond_max = 0 Maximum number of conduction bands integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_k] Read more… Type-Bound Procedures procedure, public :: print => numerics_scatter_vc_print procedure, public :: load => numerics_scatter_vc_load_nml procedure, public :: save => numerics_scatter_vc_save procedure, public :: create_val_id_list => vc_create_val_id_list procedure, public :: create_k_id_list => vc_create_k_id_list Subroutines public subroutine vc_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence conduction DM-electron rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_k public subroutine vc_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence conduction DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self integer :: n_val public subroutine numerics_scatter_vc_save (self, filename, verbose) Saves numerics_scatter_vc . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_scatter_vc_load_nml (self, filename, n_val, n_cond, verbose) Loads numerics_scatter_vc parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self character(len=*) :: filename integer :: n_val integer :: n_cond logical, optional :: verbose public subroutine numerics_scatter_vc_print (self, verbose) Prints numerics_scatter_vc components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vc_t ) :: self logical, optional :: verbose","tags":"","loc":"module/numerics_scatter_vc.html"},{"title":"calc_exdm_scatter_vf – EXCEED-DM","text":"Compute contributions to the valence free DM-electron scattering rate. Uses prec PW_dataset_type dm_model_type physics_scatter_functions transition_form_factor binned_scatter_rate_type math_mod expt_type constants units bins_scatter_type in_med_scr_type material_type numerics_scatter_vf Contents Subroutines exdm_scatter_vf_calc vf_interpolate_dRdw_to_binned_rate Subroutines public subroutine exdm_scatter_vf_calc (binned_rate, PW_dataset, target_mat, bins, dm_model, expt, in_med_scr, numerics, wfc_FT_ik, val_id, k, verbose) Computes the valence to free scattering rate by first computing for a list of values, then interpolates and integrates to get the binned rate\nin bins . Arguments Type Intent Optional Attributes Name type( binned_scatter_rate_t ) :: binned_rate type(PW_dataset_t) :: PW_dataset type( material_t ) :: target_mat type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr type( numerics_scatter_vf_t ) :: numerics complex(kind=dp) :: wfc_FT_ik (:) integer :: val_id integer :: k logical, optional :: verbose public subroutine vf_interpolate_dRdw_to_binned_rate (omega_list, dRdw, b_rate, E_bin_width, band_gap) Given a list of values, and at those values, go through adjacent pairs, and ,\nfind the power law fit parameter, , such that .\nThen integrate this function over each bin, , for each . Note that is assumed to be zero for . Read more… Arguments Type Intent Optional Attributes Name real(kind=dp) :: omega_list (:) real(kind=dp) :: dRdw (:) real(kind=dp) :: b_rate (:) real(kind=dp) :: E_bin_width real(kind=dp) :: band_gap","tags":"","loc":"module/calc_exdm_scatter_vf.html"},{"title":"exdm_scatter_vf – EXCEED-DM","text":"Compute the valence free DM-electron scattering rate. Uses FFT_util prec mpi PW_dataset_type MPI_util binned_scatter_rate_type expt_type calc_exdm_scatter_vf info_messages in_med_scr_type numerics_scatter_vf dm_model_type io_input material_type control_input Contents Subroutines exdm_scatter_vf_set_n_init run_exdm_scatter_vf Subroutines public subroutine exdm_scatter_vf_set_n_init (io_files, n_init) Sets the number of initial states to record the rate for.\nSpecific to the valence free DM-electron\nscattering rate calculation. Arguments Type Intent Optional Attributes Name type( io_files_t ) :: io_files integer :: n_init public subroutine run_exdm_scatter_vf (n_init, n_proc, proc_id, root_process, binned_rate_init, main_control, io_files, target_mat, dm_model, bins, expt, in_med_scr, verbose) Compute the valence free DM-electron scattering rate. Arguments Type Intent Optional Attributes Name integer :: n_init integer :: n_proc integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (n_init) type( control_t ) :: main_control type( io_files_t ) :: io_files type( material_t ) :: target_mat type( dm_model_t ) :: dm_model type( bins_scatter_t ) :: bins type( expt_t ) :: expt type( in_med_scr_t ) :: in_med_scr logical, optional :: verbose","tags":"","loc":"module/exdm_scatter_vf.html"},{"title":"numerics_scatter_vf – EXCEED-DM","text":"Numerics parameters specific to the valence free DM-electron scattering rate calculation. Uses prec info_messages Contents Derived Types numerics_scatter_vf_t Subroutines vf_create_k_id_list vf_create_val_id_list numerics_scatter_vf_save numerics_scatter_vf_load_nml numerics_scatter_vf_print Derived Types type, public :: numerics_scatter_vf_t Numerics parameters specific to the valence free DM-electron scattering rate calculation. Components Type Visibility Attributes Name Initial integer, public :: n_val_max = 0 Maximum number of valence bands character(len=64), public :: Zeff_type = 'one' Specify what Zeff to use Read more… real(kind=dp), public, allocatable :: Zeff (:,:) Dim : [ n_val, n_k ] Read more… integer, public, allocatable :: val_id_list (:) Dim : [n_val_max] Read more… integer, public, allocatable :: k_id_list (:) Dim : [n_k] Read more… integer, public :: n_kf_theta = 1 Number of points in the integration of integer, public :: n_kf_phi = 1 Number of points in the integration of real(kind=dp), public, allocatable :: kf_angular_mesh (:,:) Dim : [ n_kf_theta*n_kf_phi, 2 ] Read more… integer, public :: n_omega Number of points to compute for. The valence -> free scattering\nrate calculation is done by computing n_omega values of between Read more… real(kind=dp), public, allocatable :: omega_list (:) List of points to compute for. The valence -> free scattering\nrate calculation is done by computing n_omega values of between Read more… Type-Bound Procedures procedure, public :: print => numerics_scatter_vf_print procedure, public :: load => numerics_scatter_vf_load_nml procedure, public :: save => numerics_scatter_vf_save procedure, public :: create_val_id_list => vf_create_val_id_list procedure, public :: create_k_id_list => vf_create_k_id_list Subroutines public subroutine vf_create_k_id_list (self, n_k) Specify the indicies for each point that should be included. \nSpecific to the valence free DM-electron scattering rate calculations. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_k public subroutine vf_create_val_id_list (self, n_val) Specify the indicies for each valence band that should be included. \nSpecific to the valence free DM-electron scattering rate calculation. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self integer :: n_val public subroutine numerics_scatter_vf_save (self, filename, verbose) Saves numerics_scatter_vf . Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine numerics_scatter_vf_load_nml (self, filename, PW_dataset, verbose) Loads numerics_scatter_vf parameters from a namelist. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self character(len=*) :: filename type(PW_dataset_t) :: PW_dataset logical, optional :: verbose public subroutine numerics_scatter_vf_print (self, verbose) Prints numerics_scatter_vf components. Arguments Type Intent Optional Attributes Name class( numerics_scatter_vf_t ) :: self logical, optional :: verbose","tags":"","loc":"module/numerics_scatter_vf.html"},{"title":"binned_scatter_rate_type – EXCEED-DM","text":"Defines the binned_scatter_rate data type. Uses dm_model_type prec bins_scatter_type expt_type Contents Derived Types binned_scatter_rate_t Functions binned_scatter_rate_compute_rate Subroutines binned_scatter_rate_init Derived Types type, public :: binned_scatter_rate_t Binned scattering rate for each DM mass, mediator form factor, and time of day. Binning is\nin momentum deposition, and energy deposition, (referred to as E in the code). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: binned_rate (:,:,:,:,:) Dim : [ bins%n_q, bins%n_E, dm_model%n_mX, dm_model%n_med_FF, expt%n_time ] Read more… Type-Bound Procedures procedure, public :: init => binned_scatter_rate_init procedure, public :: compute_rate => binned_scatter_rate_compute_rate Functions public function binned_scatter_rate_compute_rate (self) result(rate) Sums binned_rate%binned_rate over the bins to get the total rate. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self Return Value real(kind=dp)\n  (size(self%binned_rate,3),size(self%binned_rate,4),size(self%binned_rate,5)) Subroutines public subroutine binned_scatter_rate_init (self, bins, dm_model, expt) Creates a binned_rate object and sets binned_rate%binned_rate = 0. Arguments Type Intent Optional Attributes Name class( binned_scatter_rate_t ) :: self type( bins_scatter_t ) :: bins type( dm_model_t ) :: dm_model type( expt_t ) :: expt","tags":"","loc":"module/binned_scatter_rate_type.html"},{"title":"bins_dielectric_type – EXCEED-DM","text":"Defines the bins_dielectric type. Uses prec Contents Derived Types bins_dielectric_t Subroutines print_bins_dielectric load_bins_dielectric_nml save_bins_dielectric Derived Types type, public :: bins_dielectric_t Collection of parameters which specify how the dielectric function\nis binned in . Components Type Visibility Attributes Name Initial integer, public :: n_q = 1 Number of bins for . integer, public :: n_q_theta = 1 Number of bins for the coordinate of integer, public :: n_q_phi = 1 Number of bins for the coordinate of integer, public :: n_E = 1 Number of bins in omega space real(kind=dp), public :: q_width = 1.0e3_dp Width of the q bins Read more… real(kind=dp), public :: E_width = 0.1_dp Width of the omega bins. Read more… Type-Bound Procedures procedure, public :: print => print_bins_dielectric procedure, public :: load => load_bins_dielectric_nml procedure, public :: save => save_bins_dielectric Subroutines public subroutine print_bins_dielectric (self, verbose) Print bins_dielectric components. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self logical, optional :: verbose public subroutine load_bins_dielectric_nml (self, filename, verbose) Loads bins_dielectric parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine save_bins_dielectric (self, filename, verbose) Saves bins_dielectric . Arguments Type Intent Optional Attributes Name class( bins_dielectric_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/bins_dielectric_type.html"},{"title":"bins_scatter_type – EXCEED-DM","text":"Defines the bins_scatter type. Uses prec Contents Derived Types bins_scatter_t Subroutines print_bins load_bins_nml save_bins Derived Types type, public :: bins_scatter_t Collection of parameters which specify how the DM-electron scattering rate\nis binned in . Components Type Visibility Attributes Name Initial integer, public :: n_q = 1 Number of bins in momentum space integer, public :: n_E = 1 Number of bins in omega space real(kind=dp), public :: q_width = 1.0e3_dp Width of the q bins Read more… real(kind=dp), public :: E_width = 0.1_dp Width of the omega bins. Read more… Type-Bound Procedures procedure, public :: print => print_bins procedure, public :: load => load_bins_nml procedure, public :: save => save_bins Subroutines public subroutine print_bins (self, verbose) Print bins_scatter components. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self logical, optional :: verbose public subroutine load_bins_nml (self, filename, verbose) Loads bins_scatter parameters from a namelist. Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine save_bins (self, filename, verbose) Saves bins_scatter . Arguments Type Intent Optional Attributes Name class( bins_scatter_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/bins_scatter_type.html"},{"title":"core_electron_type – EXCEED-DM","text":"Defines the core_electron type. Uses prec hdf5 math_mod constants units h5lt info_messages Contents Derived Types core_electron_t Functions atomic_sto_wf_FT_radial atomic_sto_wf_FT sto_wf_radial sto_wf_FT_radial atomic_sto_wf_radial atomic_sto_wf get_sto_dataset_str Subroutines core_bloch_wf_on_grid save_core_electron print_core_electron load_core_electron Derived Types type, public :: core_electron_t Information about the core electrons for each atom in the unit cell.\nContains the configuration information, e.g. number of atoms, number of core\nstates for each atom, but also the RHF wave function coefficients to get the\natomic wave functions, . Components Type Visibility Attributes Name Initial integer, public :: n_atom Number of atoms in the primitive cell. integer, public :: n_state Number of core states. real(kind=dp), public, allocatable :: eq_pos_red (:,:) Dim : [n_atom, 3] Read more… real(kind=dp), public, allocatable :: energy (:) Dim : [n_state] Read more… integer, public, allocatable :: Z (:) Dim : [n_atom] Read more… integer, public, allocatable :: config (:,:) Dim : [n_state, 5] Read more… integer, public, allocatable :: STO_nj (:) Dim : [n_state] Read more… real(kind=dp), public, allocatable :: STO_nl (:,:) Dim : [ n_state, STO_nj(n_state) ] Read more… real(kind=dp), public, allocatable :: STO_Zl (:,:) Dim : [ n_state, STO_nj(n_state) ] Read more… real(kind=dp), public, allocatable :: STO_norm_l (:,:) Dim : [ n_state, STO_nj(n_state) ] Read more… real(kind=dp), public, allocatable :: STO_Cnl (:,:) Dim : [ n_state, STO_nj(n_state) ] Read more… integer, public :: STO_max_nj Maximum value of nj across all states. character(len=512), public :: config_filename Core electron configuration filename character(len=512), public :: sto_filename STO wave function coefficient filename Type-Bound Procedures procedure, public :: load => load_core_electron procedure, public :: save => save_core_electron procedure, public :: print => print_core_electron procedure, public :: bloch_wf_on_grid => core_bloch_wf_on_grid procedure, public :: atomic_sto_wf procedure, public :: atomic_sto_wf_radial procedure, public :: atomic_sto_wf_FT procedure, public :: atomic_sto_wf_FT_radial Functions public function atomic_sto_wf_FT_radial (self, id, k_mag) result(chi) Radial part of atomic_sto_wf . Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config real(kind=dp) :: k_mag Return Value complex(kind=dp) public function atomic_sto_wf_FT (self, id, k) result(wf_FT) Fourier transform of the atomic wave function which is a sum of STO's. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id references a specific element in self%config() real(kind=dp) :: k (3) Return Value complex(kind=dp) public function sto_wf_radial (n, N0, Z, r) result(wf) Individual Slater Type Orbital (STO) Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=dp) :: N0 real(kind=dp) :: Z real(kind=dp) :: r Return Value real(kind=dp) public function sto_wf_FT_radial (n, l, norm, Z, k_mag) result(wf_FT) Radial part of the Fourier transform of a Slater type orbital (STO) wave function. Read more… Arguments Type Intent Optional Attributes Name integer :: n integer :: l real(kind=dp) :: norm real(kind=dp) :: Z real(kind=dp) :: k_mag Return Value complex(kind=dp) public function atomic_sto_wf_radial (self, id, r) result(wf) Radial part of atomic_sto_wf . Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: r Return Value real(kind=dp) public function atomic_sto_wf (self, id, x) result(wf) Atomic wave function, summed over individual STO's. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: id real(kind=dp) :: x (3) Return Value complex(kind=dp) public function get_sto_dataset_str (Z, n, l) result(dset_name) Returns the (string) name of the dataset where the RHF STO coefficients are for atom with \nproton number, , and quantum numbers, inside the RHF data file. Arguments Type Intent Optional Attributes Name integer :: Z integer :: n integer :: l Return Value character(len=64) Subroutines public subroutine core_bloch_wf_on_grid (self, n_grid, wf, id, pc_vol, red_to_xyz, shift, k_vec_in, r_cut_in, verbose) Compute the core electron wave functions on a grid inside the primitive cell, summed\nover neighboring unit cells. Read more… Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self integer :: n_grid (3) complex(kind=dp) :: wf (n_grid(1),n_grid(2),n_grid(3)) integer :: id real(kind=dp) :: pc_vol real(kind=dp) :: red_to_xyz (3,3) logical, optional :: shift real(kind=dp), optional :: k_vec_in (3) integer, optional :: r_cut_in logical, optional :: verbose public subroutine save_core_electron (self, filename, verbose) Saves core_electron . Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_core_electron (self, verbose) Prints core_electron components. Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self logical, optional :: verbose public subroutine load_core_electron (self, core_elec_config_filename, STO_filename, verbose) Loads core_electron parameters from a namelist.\nget the relevant data for each core state Arguments Type Intent Optional Attributes Name class( core_electron_t ) :: self character(len=*) :: core_elec_config_filename character(len=*) :: STO_filename logical, optional :: verbose","tags":"","loc":"module/core_electron_type.html"},{"title":"dm_model_type – EXCEED-DM","text":"Defines the dm_model type. Uses prec hdf5 math_mod constants info_messages h5lt units Contents Derived Types dm_model_t Subroutines print_dm_model load_dm_model_nml save_dm_model Derived Types type, public :: dm_model_t Parameters defining the dark matter (DM) model, i.e. the DM particle and mediator. Components Type Visibility Attributes Name Initial integer, public :: n_mX = 1 Number of masses real(kind=dp), public, allocatable :: mX (:) Dim : [ n_mX ] Read more… integer, public :: n_med_FF = 1 Number of mediator form factors real(kind=dp), public, allocatable :: med_FF (:) Dim : [ n_med_FF ] Read more… real(kind=dp), public :: rhoX_GeV_per_cm3 = 0.4_dp Dark matter density Read more… real(kind=dp), public :: rhoX Dark matter density Read more… real(kind=dp), public :: v0_km_per_sec = 230.0_dp DM velocity distribution parameter, Read more… real(kind=dp), public :: vE_km_per_sec = 240.0_dp DM velocity distribution parameter, Read more… real(kind=dp), public :: vEsc_km_per_sec = 600.0_dp DM velocity distribution parameter, Read more… real(kind=dp), public :: v0 DM velocity distribution parameter, Read more… real(kind=dp), public :: vE DM velocity distribution parameter, Read more… real(kind=dp), public :: vEsc DM velocity distribution parameter, Read more… real(kind=dp), public :: g_func_N0 Parameter of Read more… real(kind=dp), public :: g_func_c1 Parameter of Read more… real(kind=dp), public :: g_func_c2 Parameter of Read more… real(kind=dp), public :: vX_max Maximum speed of the incoming dark matter Read more… integer, public :: tff_id (2) = [1, 1] Transition form factor ID. Specifies which matrix element to compute, which\nwill depend on the scattering potential of the DM model character(len=64), public :: particle_type = 'fermion' Dark matter particle type Type-Bound Procedures procedure, public :: load => load_dm_model_nml procedure, public :: save => save_dm_model procedure, public :: print => print_dm_model Subroutines public subroutine print_dm_model (self, verbose) Prints dm_model components. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self logical, optional :: verbose public subroutine load_dm_model_nml (self, filename, verbose) Loads dm_model parameters from a namelist. Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine save_dm_model (self, filename, verbose) Saves dm_model . Arguments Type Intent Optional Attributes Name class( dm_model_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/dm_model_type.html"},{"title":"expt_type – EXCEED-DM","text":"Defines expt type. Uses constants prec Contents Derived Types expt_t Subroutines load_expt_nml print_expt save_expt Derived Types type, public :: expt_t Experimental parameters, e.g. threshold energy, exposure, detector orientation. Components Type Visibility Attributes Name Initial real(kind=dp), public :: E_threshold = 0.0_dp Energy threshold. Only events which deposit energy omega >= E_threshold will be considered. Read more… real(kind=dp), public :: m_T_kg = 1.0_dp Mass of the target Read more… real(kind=dp), public :: m_T Mass of the target Read more… real(kind=dp), public :: exposure_yr = 1.0_dp Total exposure of the experiment Read more… real(kind=dp), public :: exposure Total exposure of the experiment Read more… integer, public :: n_time = 1 Number of time of days to compute for real(kind=dp), public, allocatable :: times (:) Dim : [ n_time ] Read more… real(kind=dp), public, allocatable :: vE_direction (:,:) Dim : [ n_time, 3 ] Read more… real(kind=dp), public :: theta_E = 42.0_dp*(pi/180.0_dp) Angle between the Earth's rotation axis and the DM wind. Read more… Type-Bound Procedures procedure, public :: load => load_expt_nml procedure, public :: print => print_expt procedure, public :: save => save_expt Subroutines public subroutine load_expt_nml (self, filename, verbose) Loads expt parameters from a namelist. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_expt (self, verbose) Prints expt components. Arguments Type Intent Optional Attributes Name class( expt_t ) :: self logical, optional :: verbose public subroutine save_expt (self, filename, verbose) Saves expt . Arguments Type Intent Optional Attributes Name class( expt_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/expt_type.html"},{"title":"in_med_scr_type – EXCEED-DM","text":"Defines the in_med_scr type. Uses constants prec Contents Derived Types in_med_scr_t Functions numeric_screening analytic_screening screening Subroutines save_in_med_scr print_in_med_scr load_in_med_scr_nml load_computed_dielectric load_in_med_scr Derived Types type, public :: in_med_scr_t Collection of parameters defining how the DM-electron scattering rate\nshould be screened. Components Type Visibility Attributes Name Initial character(len=64), public :: type = '' Type of screening to use Read more… logical, public :: include_screen = .TRUE. Whether or not to include screening effects at all. real(kind=dp), public :: e0 Static dielectric parameter for analytic screening Read more… real(kind=dp), public :: q_tf Thomas Fermi momentum for analytic screening Read more… real(kind=dp), public :: omega_p Plasma frequency for analytic screening Read more… real(kind=dp), public :: alpha shape parameter for analytic screening Read more… integer, public :: n_E Number of bins. Read more… integer, public :: n_q Number of bins. Read more… integer, public :: n_q_theta Number of bins. Read more… integer, public :: n_q_phi Number of bins Read more… real(kind=dp), public :: E_width Width of the bins. Read more… real(kind=dp), public :: q_width Width of the bins. Read more… complex(kind=dp), public, allocatable :: numeric_screen_mat (:,:,:,:) Dim : [ n_E, n_q, n_q_theta, n_q_phi ] Read more… complex(kind=dp), public, allocatable :: numeric_anisotropic_screen_mat (:,:,:,:,:,:) Dim : [ n_E, n_q, n_q_theta, n_q_phi, 3, 3 ] Read more… logical, public :: anisotropic_screen = .FALSE. Flag to check whether the loaded dielectric is a matrix or scalar quantity. If matrix -> True, if scalar -> False. Type-Bound Procedures procedure, public :: screening procedure, public :: analytic_screening procedure, public :: numeric_screening procedure, public :: load_in_med_scr_nml procedure, public :: load => load_in_med_scr procedure, public :: save => save_in_med_scr procedure, public :: print => print_in_med_scr procedure, public :: load_computed_dielectric Functions public function numeric_screening (self, q_vec, omega) result(scr) Absolute value of the numerically computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function analytic_screening (self, q_vec, omega) result(scr) Analytic form of the dielectric function. Read more… Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) public function screening (self, q_vec, omega) result(scr) Screening factor in scattering rate calculations. Read more… Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self real(kind=dp) :: q_vec (3) real(kind=dp) :: omega Return Value real(kind=dp) Subroutines public subroutine save_in_med_scr (self, filename, verbose) Saves in_med_scr . Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_in_med_scr (self, verbose) Prints in_med_scr components. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self logical, optional :: verbose public subroutine load_in_med_scr_nml (self, filename, verbose) Loads in_med_scr parameters from a namelist. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine load_computed_dielectric (self, filename, verbose) Load the pre-computed dielectric. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine load_in_med_scr (self, proc_id, root_process, n_proc, io_files, main_control, target_mat, verbose) Loads the in medium screening parameters. If the user specifies\nthat the screening should be computed numerically then exdm_dielectric will\nbe run. Arguments Type Intent Optional Attributes Name class( in_med_scr_t ) :: self integer :: proc_id integer :: root_process integer :: n_proc type( io_files_t ) :: io_files type( control_t ) :: main_control type( material_t ) :: target_mat logical, optional :: verbose","tags":"","loc":"module/in_med_scr_type.html"},{"title":"material_type – EXCEED-DM","text":"Defines the material type. Uses prec hdf5 units info_messages h5lt Contents Derived Types material_t Subroutines print_material load_material_nml save_material Derived Types type, public :: material_t Target material properties. Components Type Visibility Attributes Name Initial character(len=64), public :: name = '' Material name real(kind=dp), public :: pc_vol_A Volume of the unit cell Read more… real(kind=dp), public :: pc_vol Volume of the primitive cell Read more… real(kind=dp), public :: rho_T_g_per_cm3 Target density Read more… real(kind=dp), public :: rho_T Target density Read more… real(kind=dp), public :: band_gap = 0.0_dp Band gap of the target Read more… Type-Bound Procedures procedure, public :: load => load_material_nml procedure, public :: print => print_material procedure, public :: save => save_material Subroutines public subroutine print_material (self, verbose) Prints material components. Arguments Type Intent Optional Attributes Name class( material_t ) :: self logical, optional :: verbose public subroutine load_material_nml (self, filename, verbose) Loads material parameters from a namelist. Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine save_material (self, filename, verbose) Saves material . Arguments Type Intent Optional Attributes Name class( material_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/material_type.html"},{"title":"PW_dataset_type – EXCEED-DM","text":"Defines the PW_dataset type. Uses prec hdf5 constants units h5lt info_messages Contents Derived Types PW_dataset_t Subroutines load_wfc_ik_expanded_no_spin load_wfc_ik_expanded_spin load_wfc_FT_ik_no_spin load_wfc_FT_ik_spin load_PW_dataset_hdf5 save_PW_dataset print_PW_dataset compute_PW_cutoff do_scissor_correction Derived Types type, public :: PW_dataset_t Stores the metadata of the Bloch wave function coefficients in the Fourier basis, , e.g. number of points, , number of bands, etc and has routines which load the coefficients from an external data file when needed. Read more… Components Type Visibility Attributes Name Initial integer, public :: n_k Number of k points integer, public :: n_val Number of valence bands integer, public :: n_cond Number of conduction bands integer, public :: n_G Number of G points integer, public, allocatable :: G_grid_red (:,:) Dim : [n_G, 3] Read more… real(kind=dp), public :: a_vecs_A (3,3) Primitive lattice vectors Read more… real(kind=dp), public :: b_vecs_A (3,3) Reciprocal lattice vector Read more… real(kind=dp), public, allocatable :: k_weight (:) Dim : [n_k] Read more… real(kind=dp), public, allocatable :: k_grid_red (:,:) Dim : [n_k, 3] Read more… real(kind=dp), public, allocatable :: energy_bands_raw (:,:) Dim : [n_k, n_bands] Read more… real(kind=dp), public :: Ef_max = 60.0_dp Maximum electron energy computed for. Read more… integer, public :: n_bands Total number of bands Read more… real(kind=dp), public :: q_cut Plane wave expansion cutoff Read more… real(kind=dp), public :: E_cut Energy cooresponding to q_cut Read more… real(kind=dp), public :: a_vecs (3,3) Primitive lattice vectors Read more… real(kind=dp), public :: red_to_xyz (3,3) Matrix converting reduced cooredinate positions to physical xyz cooredinates\nin eV&#94;(-1) via Read more… real(kind=dp), public :: b_vecs (3,3) Reciprocal lattice vectors Read more… real(kind=dp), public :: k_red_to_xyz (3,3) Matrix converting reduced coordinate momentum to physical xyz coordinates\nin eV via Read more… real(kind=dp), public, allocatable :: energy_bands (:,:) Dim : [n_k, n_bands] Read more… real(kind=dp), public, allocatable :: G_grid_xyz (:,:) Dim : [ n_G , 3] Read more… real(kind=dp), public, allocatable :: k_grid_xyz (:,:) Dim : [n_k, 3] Read more… logical, public :: include_spin = .FALSE. Flag declaring whether the wave functions are spin dependent or not real(kind=dp), public :: spin_degen = 2.0_dp Spin degeneracy factor. Read more… character(len=512), public :: filename Filename of data real(kind=dp), public :: q_max_1BZ All transitions with q_max_1BZ are restricted to stay within the 1BZ. Read more… Type-Bound Procedures procedure, public :: load => load_PW_dataset_hdf5 procedure, public :: save => save_PW_dataset procedure, public :: print => print_PW_dataset procedure, public :: load_wfc_FT_ik_no_spin procedure, public :: load_wfc_ik_expanded_no_spin procedure, public :: load_wfc_FT_ik_spin procedure, public :: load_wfc_ik_expanded_spin procedure, public :: compute_PW_cutoff procedure, public :: do_scissor_correction Subroutines public subroutine load_wfc_ik_expanded_no_spin (self, i, k, FFT_grid, wfc_ik) Loads the spin independent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) public subroutine load_wfc_ik_expanded_spin (self, i, k, FFT_grid, wfc_ik) Loads the spin dependent wave function coefficients, for a given , expands (zero-pads), then Fourier transforms them to get . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k type(FFT_grid_t) :: FFT_grid complex(kind=dp) :: wfc_ik (2,FFT_grid%n_grid(1),FFT_grid%n_grid(2),FFT_grid%n_grid(3)) public subroutine load_wfc_FT_ik_no_spin (self, i, k, wfc_FT_ik) Loads the spin independent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:) Dim : [n_G] public subroutine load_wfc_FT_ik_spin (self, i, k, wfc_FT_ik) Loads the spin dependent Bloch coefficients, for a given . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self integer :: i integer :: k complex(kind=dp) :: wfc_FT_ik (:,:) Dim : [n_G, 2] public subroutine load_PW_dataset_hdf5 (self, filename, verbose) Loads PW_dataset parameters from an hdf5 file. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine save_PW_dataset (self, filename, verbose) Saves PW_dataset . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_PW_dataset (self, filename, verbose) Prints PW_dataset components. Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine compute_PW_cutoff (self) Computes plane wave expansion parameters, and . Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self public subroutine do_scissor_correction (self, band_gap, verbose) Performs a scissor correction to the band structure. This shifts the valence and conduction\n bands independently such that band_gap . Read more… Arguments Type Intent Optional Attributes Name class( PW_dataset_t ) :: self real(kind=dp) :: band_gap logical, optional :: verbose","tags":"","loc":"module/pw_dataset_type.html"},{"title":"width_parameters_type – EXCEED-DM","text":"Defines the width_parameters type. Uses prec Contents Derived Types width_parameters_t Functions get_width Subroutines save_width_parameters print_width_parameters load_width_parameters_nml Derived Types type, public :: width_parameters_t Electron lifetime/widths to use in calculations which require the electronic Green's\nfunctions (e.g. absorption calculations). width's are parameterized as Read more… Components Type Visibility Attributes Name Initial integer, public :: n = 1 Total number of width parameters. Read more… integer, public :: n_a = 1 Number of parameters. integer, public :: n_b = 1 Number of parameters. integer, public :: n_m = 1 Number of parameters. real(kind=dp), public :: a_min Minimum parameter. Read more… real(kind=dp), public :: a_max Minimum parameter. Read more… real(kind=dp), public :: log_b_min Log10 of the minimum parameter. real(kind=dp), public :: log_b_max Log10 of the maximum parameter. real(kind=dp), public :: m_max Maximum parameter. Read more… real(kind=dp), public :: m_min Minimum parameter. Read more… real(kind=dp), public :: sigma = 1D10 parameter, energy difference must be within to be\nadded to the rate. real(kind=dp), public, allocatable :: info (:,:) Dim : [ n , 3] Read more… Type-Bound Procedures procedure, public :: load => load_width_parameters_nml procedure, public :: save => save_width_parameters procedure, public :: print => print_width_parameters procedure, public :: get_width Functions public function get_width (self, id, omega) result(width) Returns for a given id. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self integer :: id real(kind=dp) :: omega Return Value real(kind=dp) Subroutines public subroutine save_width_parameters (self, filename, verbose) Saves width_parameters . Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine print_width_parameters (self, verbose) Prints width_parameters components. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self logical, optional :: verbose public subroutine load_width_parameters_nml (self, filename, verbose) Loads width_parameters parameters from a namelist. Arguments Type Intent Optional Attributes Name class( width_parameters_t ) :: self character(len=*) :: filename logical, optional :: verbose","tags":"","loc":"module/width_parameters_type.html"},{"title":"FFT_util – EXCEED-DM","text":"Utilities for computing FFT's. Uses fftw3 prec info_messages Contents Derived Types FFT_grid_t Subroutines FFT_grid_print FFT_grid_save FFT_grid_init FFT_grid_set_sym_G_grid set_fft_plan_forward_3d set_fft_plan_backward_3d G_red_to_FFT_G_grid_index Derived Types type, public :: FFT_grid_t Collection of parameters defining the grid the FFT is performed on, \nand how the FFT should be performed. Components Type Visibility Attributes Name Initial integer, public :: N Number of points in the FFT integer, public :: n_grid (3) Number of points in the FFT in each dimension real(kind=dp), public :: q_max Maximum q for which the FFT is consistent for. See find_q_max Read more… integer, public :: plan (8) The FFTW3 plan integer, public, allocatable :: sym_G_grid_red (:,:,:,:) Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] Read more… real(kind=dp), public, allocatable :: sym_G_grid_xyz (:,:,:,:) Dim : [ n_grid(1), n_grid(2), n_grid(3), 3 ] Read more… Type-Bound Procedures procedure, public :: init => FFT_grid_init procedure, public :: save => FFT_grid_save procedure, public :: print => FFT_grid_print procedure, public :: set_sym_G_grid => FFT_grid_set_sym_G_grid Subroutines public subroutine FFT_grid_print (self, verbose) Prints FFT_grid components. Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self logical, optional :: verbose public subroutine FFT_grid_save (self, filename, verbose) Saves FFT_grid . Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self character(len=*) :: filename logical, optional :: verbose public subroutine FFT_grid_init (self, n_grid, k_red_to_xyz, fb_char, verbose) Initialize an FFT_grid instance. Read more… Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self integer :: n_grid (3) real(kind=dp) :: k_red_to_xyz (3,3) character(len=1) :: fb_char 'f' for forward rule, 'b' for backwards logical, optional :: verbose public subroutine FFT_grid_set_sym_G_grid (self, k_red_to_xyz, verbose) Symmetric FFT grid. Read more… Arguments Type Intent Optional Attributes Name class( FFT_grid_t ) :: self real(kind=dp) :: k_red_to_xyz (3,3) logical, optional :: verbose public subroutine set_fft_plan_forward_3d (n_grid, fft_plan) Sets the FFTW3 FFT plan with a 'forwards' convention. See https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029 . Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine set_fft_plan_backward_3d (n_grid, fft_plan) Sets the FFTW3 FFT plan with a 'backwards' convention. See https://www.fftw.org/fftw3_doc/The-1d-Discrete-Fourier-Transform-_0028DFT_0029.html#The-1d-Discrete-Fourier-Transform-_0028DFT_0029 . Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: fft_plan (8) public subroutine G_red_to_FFT_G_grid_index (n_grid, G_red, idx) Given a G_red vector returns the index of that vector in the FFT \ngrid. Arguments Type Intent Optional Attributes Name integer :: n_grid (3) integer :: G_red (3) integer :: idx (3)","tags":"","loc":"module/fft_util.html"},{"title":"MPI_util – EXCEED-DM","text":"Utilities and wrapper functions for MPI routines. Generally, whenever data has to be communicated\nfrom one processor to another the MPI_Send and MPI_Recv calls are inside subroutines\nin this module. Uses prec mpi info_messages Contents Derived Types parallel_manager_t Subroutines comm_reduce_dielectric comm_abs_rate comm_self_energies comm_abs_tran_form comm_reduce_binned_rate_init create_job_to_2d_ID_table parallel_manager_init Derived Types type, public :: parallel_manager_t Manages indexing the jobs that each processor needs to do and \ncommunicates the results to the main/root processor. Components Type Visibility Attributes Name Initial integer, public :: n_jobs Total number of jobs integer, public :: n_jobs_per_proc Number of transitions per processor integer, public, allocatable :: job_table (:,:) Dim : [ n_proc, n_jobs_per_proc ] Read more… Type-Bound Procedures procedure, public :: init => parallel_manager_init procedure, public :: create_job_to_2d_ID_table procedure, public :: comm_abs_tran_form procedure, public :: comm_self_energies procedure, public :: comm_abs_rate Subroutines public subroutine comm_reduce_dielectric (proc_id, root_process, dielectric, verbose) Communicate the dielectric pieces computed at each processor to the total dielectric\non the main processor using MPI_Reduce. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process complex(kind=dp) :: dielectric (:,:,:,:) logical, optional :: verbose public subroutine comm_abs_rate (self, proc_id, root_process, abs_rate, verbose) Communicate the absorption rate contribution from each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process real(kind=dp) :: abs_rate (:,:,:) logical, optional :: verbose public subroutine comm_self_energies (self, proc_id, root_process, pi_v2_v2_job, pi_1_1_mat_job, pi_vi_vj_job, pi_v2_v2, pi_1_1_mat, pi_vi_vj, verbose) Communicate the self energies computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process complex(kind=dp) :: pi_v2_v2_job (:,:,:) Dim : [n_omega, n_widths, n_tran_per_proc] self energy with two v&#94;2 insertions Units : eV&#94;2 complex(kind=dp) :: pi_1_1_mat_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] self energy, without q_vec's Units : eV&#94;2 complex(kind=dp) :: pi_vi_vj_job (:,:,:,:,:) Dim : [3, 3, n_omega, n_widths, n_tran_per_proc] Units : eV&#94;2 complex(kind=dp) :: pi_v2_v2 (:,:) complex(kind=dp) :: pi_1_1_mat (:,:,:,:) complex(kind=dp) :: pi_vi_vj (:,:,:,:) logical, optional :: verbose public subroutine comm_abs_tran_form (self, proc_id, root_process, job_id_to_ik, tran_form_1_no_spin_job, tran_form_1_spin_job, tran_form_v_no_spin_job, tran_form_v_spin_job, tran_form_v2_no_spin_job, tran_form_v2_spin_job, tran_form_1_no_spin, tran_form_1_spin, tran_form_v_no_spin, tran_form_v_spin, tran_form_v2_no_spin, tran_form_v2_spin, numerics, verbose) Communicate the transition form factors computed at each processor to the main processor. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: proc_id integer :: root_process integer :: job_id_to_ik (:,:) complex(kind=dp) :: tran_form_1_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_1_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin_job (:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v_spin_job (:,:,:,:,:) Dim : [3, n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin_job (:,:) Dim : [n_jobs_per_proc, n_cond_max] Units : None complex(kind=dp) :: tran_form_v2_spin_job (:,:,:,:) Dim : [n_jobs_per_proc, n_cond_max, 2, 2] Units : None complex(kind=dp) :: tran_form_1_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_1_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v_no_spin (:,:,:,:) Dim : [3, n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v_spin (:,:,:,:,:,:) Dim : [3, n_init, n_fin, n_k, 2, 2] Units : None complex(kind=dp) :: tran_form_v2_no_spin (:,:,:) Dim : [n_init, n_fin, n_k] Units : None complex(kind=dp) :: tran_form_v2_spin (:,:,:,:,:) Dim : [n_init, n_fin, n_k, 2, 2] Units : None type( numerics_abs_t ) :: numerics logical, optional :: verbose public subroutine comm_reduce_binned_rate_init (proc_id, root_process, binned_rate_init, verbose) Return and sum all of the binned_rate_init's from the processors using MPI_Reduce. Arguments Type Intent Optional Attributes Name integer :: proc_id integer :: root_process type( binned_scatter_rate_t ) :: binned_rate_init (:) logical, optional :: verbose public subroutine create_job_to_2d_ID_table (self, list1, list2, job_id_to_2d_ID_table, verbose) Given two lists, {list1, list2} create a single list which has\nn[list1]*n[list_2] elements, each of which has 4 elements. The first two elements\nare a pair from {list1, list2}, the second two index the value in the first pair, i.e. Read more… Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: list1 (:) integer :: list2 (:) integer :: job_id_to_2d_ID_table (:,:) Dim : [n_jobs, 4] logical, optional :: verbose public subroutine parallel_manager_init (self, n_jobs, verbose) Initializes a parallel_manager instance. Arguments Type Intent Optional Attributes Name class( parallel_manager_t ) :: self integer :: n_jobs Number of initial states logical, optional :: verbose","tags":"","loc":"module/mpi_util.html"},{"title":"exdm – EXCEED-DM","text":"Uses iso_fortran_env mpi dm_model_type exdm_absorption exdm_scatter exdm_dielectric expt_type version_control info_messages material_type io_input timing control_input EXCEED-DM : EXtended Calculation of Electronic Excitations for Direct detection of Dark Matter Github    : https://github.com/tanner-trickle/EXCEED-DM Contents Variables proc_id n_proc root_process err nml_input_filename verbose main_control io_files target_mat dm_model expt Variables Type Attributes Name Initial integer :: proc_id Processor ID integer :: n_proc Number of processors integer :: root_process = 0 Root processor ID integer :: err Error code character(len=512) :: nml_input_filename = '' Namelist input filename. logical :: verbose = .FALSE. If verbose = .TRUE., print output type( control_t ) :: main_control Control parameters type( io_files_t ) :: io_files Input/output filenames type( material_t ) :: target_mat The target material type( dm_model_t ) :: dm_model Dark matter model parameters type( expt_t ) :: expt Experimental parameters","tags":"","loc":"program/exdm.html"},{"title":"Documentation – EXCEED-DM","text":"Welcome to the EXCEED-DM documentation!","tags":"","loc":"page//index.html"},{"title":"CHANGELOG – EXCEED-DM","text":"v0.2.8 Minor updates to dm_model and PW_dataset types Added routine to find the maximum momentum transfer within the 1BZ, get_q_max_1BZ . Generalized dielectric inputs, anisotropic dielectrics in each (q, omega) bin are now accepted. See the Dielectric Data File documentation for more details. Added cc_ext calculation mode, a new way to compute the core -> conduction contribution which allows the q range to extend to the kinematic bound. Added a new integration routine when going from differential quantities such as dR/d omega, dR/dq to the binned values. Added timing information to printed and saved output. Updated documentation. v0.2.7 Fixed bug with Ef_max cutoff by shifting valence band maximum to be the zero-point energy. Updated build system to CMake , removing FoBiS entirely. The OpenMPI subroutine, MPI_Reduce is used when appropriate verus manual send and recieve calls. Currently implemented in scattering rate and dielectric calculations Temporary file is deleted when creating the core electron configuration file with utilities/core_elec_config/create_elec_config.ipynb Removed TODO.md which was not being used (may reintroduce in the future if it becomes useful). Updated the binned_wfc utility. Added documentation for the binned_wfc utility. Optimized dielectric calculation, improved binned procedure to save memory. Update to documentation and refactored main folder. Added home page to README.md . v0.2.6 Added the option to build with cmake . This will become the default build option in v1.0.0 . Installation instructions can be found in install-cmake.md or on the website. Communication of scattering rate data is now done with an MPI_Reduce command versus manual send and recv calls. Added a timing subroutine when computing the dielectric. Miscellaneous updates to documentation. Minor bug fixes: some variables were not saving to the output files. v0.2.5 Major code refactor and other miscellaneous improvements on the way to v1.0.0 Changed valence -> conduction parallelization scheme from {i, i'} -> {i, k}, allowing for significant speedups when ( number of valence bands ) x ( number of conduction bands ) < ( number of processors ) Added n_val_max , n_cond_max options to specify the maximum number of valence and conduction bands to keep in the calculation (valence -> conduction scattering, absorption, and dielectric calculations). n_val_max counts down from the Fermi surface and n_cond_max counts up from the Fermi surface. Changed core -> conduction parallelization scheme from {i, i'} -> {i, kf}, allowing for significant speedups when ( number of core states ) x ( number of conduction bands ) < ( number of processors ) Added n_prinicipal_min , n_principal_max to set the minimum and maximum principal quantum numbers to include in scattering rate calculations involving core initial states. Changed valence -> free parallelization scheme to {i, k}. Changed absorption parallelization scheme to {i, k} Added option to skip saving transition form factors in absorption calculation. Reworked dielectric calculation, added more namelist input options. Changed dielectric parallelization scheme from {i, i'} -> {i, k}, allowing for significant speedups when ( number of valence bands ) x ( number of conduction bands ) < ( number of processors ) Added dielectric process which computes just the dielectric. Utilizing type structures to make code more modular/reusable. Each type has at least its own load , save , and print procedure. PW_dataset - handles the plane wave Bloch wave function coefficients dm_model - dark matter model parameters material - collection of target material parameters expt - experimental parameters core_electron - Core electron configuration and STO wave function coefficients for the core electrons and more! Output scattering rate units are now cm&#94;(-2), for easier conversion to cross section constraints. Output absorption rates are total rates given use specified experimental masses and exposures. EXCEED-DM version is now written to output for easy comparison with previous and future versions. Added k_ subgroup to Bloch coefficient data structure for easy access to the wave function coefficients at a given i , k . Updated example files in examples/dft accordingly. Updated core electron configuration file specification Updated example files in examples/(Si, Ge)/core accordingly. Updated utilities/create_elec_config.ipynb . Added example input files for Germanium. Improved/standardized output printing with an info_messages module. Improved comments inside the code, many variable explanations have associated LaTeX'ed equations which can be read by viewing the documentation in a browser. Major update to documentation. Check it out here folder. All modules, procedures, and types have some documentation. Specific documentation pages for all input and output files. /examples/Si/dft/Si_2x2x2_AE_spin.hdf5 are now realistic spin dependent wave function coefficients for Si (just spin-independent ones doubled.). Added preliminary logo, docs/media/exdm-prelim-logo.png . v0.2.4 Reworked the implementation of the vector/pseudoscalar DM absorption calculation. Fixed bug in absorption rate calculation introduced in v0.2.3 which overwrote the main processors transition form factors when computing the self energies. v0.2.3 Calculation of the dielectric for targets with spin-dependent wave functions is now supported. Added routine to time the dielectric calculation. Added spin_degen which accounts for the spin degeneracy factor of the initial (valence) states. Added scalar_LO absorption calculation mode to just compute the leading order contribution for scalar DM absorption. Generalized vector/pseudoscalar DM absorption calculation for anisotropic targets. Self-energy, Pi_vi_vj, is now computed along with the other self energies. Implemented routine to rigorously find maximum magnitude of q for which an FFT will give consistent results across meshes. See find_q_max_FFT routine in FFT_util . Updated install.md v0.2.2 Improvements to absorption module. Initial support for spin-dependent wave functions. More general transition form factors can be computed. Parallelization of velocity integral LAPACK and BLAS are now required. Additional installation instructions have been added to the ubuntu-gnu build. q_s_FFT has been removed as a numerics input option. This is now computed directly with LAPACK routines. v0.2.1 Added a dielectric module which computes the dielectric in the scattering kinematic regime. To screen the rate with a numeric dielectric model, set screen_type = numeric . If load_dielectric_from_file = .FALSE. , the dielectric will be computed from scratch. Otherwise the screening factor will come from the dielectric matrix in the dielectric_filename file. Variables relevant for the calculation are loaded through the dielectric namelist. Check out examples in the examples/ folder. Note: the dielectric here is only used to screen. Currently only v -> c transitions are included in the loop. For now, spin-indpendent wave functions only. Added ubuntu-gnu-debug build mode to debug with. v0.2.0 Calculation of dark matter (scalar, pseudoscalar (axion-like), vector) absorption on electrons! Compute the absorption rate, self-energies, and generalized crystal form factors in the absorption limit. Setting process = 'absorption' in the input file switches the calculation to absorption mode. Check out examples in the examples/ folder. Set a variety of electron lifetime/width parameters, width = min( a + b omega , width_max ) See https://arxiv.org/abs/2106.12586 for details of the formulation. (Currently only spin-independent, valence -> conduction transitions are supported.) v0.1.3 Partial implementation of general transition form factor in module transition_form_factor . Compute scattering rates for interactions that depend on electron spin with spin-dependent electronic wave functions. Support for valence -> conduction transitions. Note : default is to compute spin-independent scattering rates Added simple testing routines which will help make sure new additions do not break old functionality. Run test with FoBiS.py rule -ex tests . To add new tests just add files to the list inside tests/run_tests.sh Updated documentation v0.1.2 Added functionality for spin dependent (two component) wave functions! Automatically detect whether input DFT data has spin dependence. Valence -> conduction transition rates can be computed with spin dependent wave functions. Added example input file for Si which has spin dependent wave functions. v0.1.1 When timer = .TRUE. a smaller version of the program will be run before the main program, and an estimate of the run time of the full program will be printed. Improved output printing. Updated Si example input files to use file paths relative to the main folder. v0.1.0 Initial beta release.","tags":"","loc":"page/changelog/index.html"},{"title":"File Specifications – EXCEED-DM","text":"Specifics about what is inside input/output files. Files : PW Data File Core Electron Configuration File EXCEED-DM Output File Namelist Input File RHF WF Data File Dielectric Data File Some of these files will be HDF5 files. The data in these files must be set/read programatically; to handle HDF5 files in python check out, https://docs.h5py.org/en/stable/index.html .","tags":"","loc":"page/file_spec/index.html"},{"title":"Core Electron Configuration File – EXCEED-DM","text":"Filetype : HDF5 Extension : .h5 , .hdf5 Example : ./examples/Si/core/Si_core_elec_config.hdf5 Holds data about the core electron configuration. Datasets n_atom - integer Number of atoms in the primitive cell. n_state - integer Total number of core electron states. Sum of individual atoms number of core electron states. eq_pos_red - real Dim : [ n_atom , 3] Equilibrium positions, , of each atom. energy - real - Dim : [ n_state ] Binding energy of each state. Z - real Dim : [ n_atom ] Proton number of each atom. config - integer [ n_state , 5] Map between each core state and the atom and standard quantum numbers it corresponds to. config(i, 1) : atom ID config(i, 2) : n config(i, 3) : l config(i, 4) : m config(i, 5) : number of spin states Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/file_spec/core_elec_config.html"},{"title":"Dielectric Data File – EXCEED-DM","text":"Filetype : HDF5 Extension : .h5 , .hdf5 Example : ./examples/Si/outputs/Si_2x2x2_dielectric.hdf5 Numerically computed dielectric. Can be used as an input file to screen scattering rate calculations. For isotropic screening only the scalar value needs to be specified in each bin. If a matrix of values is specified a dielectric matrix will be used to screen. Groups dielectric dielectric_r Dim : [ n_E , n_q , n_q_theta , n_q_phi ] ( or [ n_E , n_q , n_q_theta , n_q_phi , 3, 3] for anisotropic dielectric) Real part of the dielectric function, averaged in bins. dielectric_c Dim : [ n_E , n_q , n_q_theta , n_q_phi ] ( or [ n_E , n_q , n_q_theta , n_q_phi , 3, 3] for anisotropic dielectric) Complex part of the dielectric function, averaged in bins. bins_dielectric n_E - int Number of bins. n_q - int Number of bins. n_q_theta - int Number of bins. n_q_phi - int Number of bins. E_width - real Width of bins in . Units : q_width - real Width of bins in Units : material name - str Target material name. band_gap - real - Target material band gap. Units : eV density - real - Target material density. Units : numerics_dielectric Numerics parameters specific to the dielectric calculation. n_val_max - int Maximum number of valence bands included in the calculation. n_cond_max - int Maximum number of conduction bands included in the calculation. n_k_vec - int Dim : [3] Number of each dimension of a Monkhorst-Pack sampled 1BZ. version number - str Version number of EXCEED-DM . Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/file_spec/dielectric.html"},{"title":"namelist Input File – EXCEED-DM","text":"Filetype : text Extension : .txt Example : ./examples/Si/inputs/scatter_vc_test_input.txt A collection of Fortran namelist entries which specify the run input parameters. Each namelist has a title and some variable entries which set variables within the program. For example, &material\n    name = 'Si'\n/ sets the name of the target material to 'Si'. Namelists control process - str Physics process to compute for. Options : 'scatter', 'absorption', 'dielectric'. calc_mode - str Calculation mode. Options : 'vc', 'cc', 'cf', 'vf', 'LO'. overwrite_output - bool Flag to overwrite the output file. If .FALSE. an output filename will be generated. timer - bool Flag to time the calculation. quiet - bool Flag to shut off the printed output. io out_folder - str Output folder. run_description - str Short description of the run, will be appended to 'EXDMout_' to create the output filename. out_filename - str Specify the output filename directly. Overwrites the out_folder / run_description combo. PW_data_filename - str Filename of data holding (with an index for spin dependent wave functions ) data and corresponding metadata. core_elec_config_filename - str Filename of core electron configuration data. dielectric_filename - str Filename where dielectric data is stored to or read from. nml_input_filename - str Filename where namelist entries are. sto_data_filename - str Filename of STO coefficients and parameters for RHF wave functions. material name - str Name of the target material. band_gap - real - Band gap of the target material. Units : pc_vol_A - real - Volume of the primitive cell Units : rho_T_g_per_cm3 - real - Target density. Units : experiment E_threshold - real - Experimental energy deposited threshold. Units : n_time - int - Number of times of day data is taken. theta_E - real - Angle between the Earth's rotation axis and the DM wind. Units : m_T_kg - real - Mass of the target. Units : exposure_yr - real - Exposure time of the target. Units : dm_model particle_type - str Dark matter particle type. Options : 'scalar', 'ps', 'vector', 'fermion'. n_mX - int - Number of dark matter masses. log_mX_min - real Minimum . log_mX_max - real Maximum . n_extra_mX - int Number of 'extra' masses to compute for. Specifing this allows the user to also specify the mX_2 namelist and add masses that are not uniform logarithmically spaced to the computed mass list. n_med_FF - int - Number of mediator form factor parameters. med_FF_min - real Minimum mediator form factor parameter, ; med_FF_max - real Maximum mediator form factor parameter, ; rhoX_GeV_per_cm3 - real - Dark matter density. Units : v0_km_per_sec - real - Dark matter velocity distribution parameter. Units : vE_km_per_sec - real - Earth velocity, dark matter velocity distribution parameter. Units : vEsc_km_per_sec - real - Escape velocity, dark matter velocity distribution parameter. Units : tff_id - int Dim : [2] Transition form factor ID. bins_scatter n_q - int - Number of bins in momentum deposition. n_E - int - Number of bins in energy deposition. E_width - real - Width of the bins in energy deposition. Units : q_width - real - Width of the bins in momentum deposition. Units : numerics_s_vc Numerics parameters specific to valence to conduction scattering rate calculations. n_val_max - int - Maximum number of valence bands included in the calculation. n_cond_max - int - Maximum number of conduction bands included in the calculation. numerics_s_cc Numerics parameters specific to core to conduction scattering rate calculations. n_FFT_grid - int - Dim : [3] FFT grid size specified on input. n_cond_max - int - Maximum number of conduction bands included in the calculation. n_principal_min - int Minimum principal quantum number, , to include in the calculation. n_principal_max - int Maximum principal quantum number, , to include in the calculation. numerics_s_vf n_val_max - int - Maximum number of valence bands included in the calculation. n_kf_theta - int - Number of angles in the integration over n_kf_phi - int - Number of angles in the integration over n_omega - int - Number of parameters to compute for. Zeff_type - str Specify how the parameters are computed. Options : 'one' ( ), 'Eb' ( found from binding energy.  ) Ef_min - real - Minimum final electron energy. Units : numerics_s_cf Ef_min - real - Minimum final electron energy. Units : Zeff_type - str Specify how the parameters are computed. Options : 'one' ( ), 'Eb' ( found from binding energy.  ) ki_min - real - Minimum initial electron momentum to integrate over. Units : ki_s - real - Scale parameter of maximum initial electron momentum to integrate over, n_kf_theta - int - Number of angles in the integration over n_kf_phi - int - Number of angles in the integration over n_ki - int - Number of points in to integrate over. n_ki_theta - int - Number of angles in the integration over n_ki_phi - int - Number of angles in the integration over n_principal_min - int Minimum principal quantum number, , to include in the calculation. n_principal_max - int Maximum principal quantum number, , to include in the calculation. n_omega - int - Number of parameters to compute for. widths Width parameters, . n_a - int - Number of parameters. n_b - int - Number of parameters. n_m - int - Number of parameters. a_min - real Minimum value of . Units : eV a_max - real Maximum value of . Units : eV log_b_min - real Minimum value of . log_b_max - real Maximum value of . m_min - real Minimum value of . Units : eV m_max - real Maximum value of . Units : eV sigma - real Off resonance parameter, only include points with . numerics_abs Numerics parameters specific to DM absorption calculations. n_val_max - int Maximum number of valence bands included in the calculation. n_cond_max - int Maximum number of conduction bands included in the calculation. n_v - int Number of points in the integration over n_v_theta - int Number of points in the integration over n_v_phi - int Number of points in the integration over save_tran_form - bool Flag to save the transition form factors. bins_dielectric Binning for the dielectric calculation. n_E - int Number of bins for numeric screening. n_q - int Number of bins for numeric screening. n_q_theta - int Number of bins for numeric screening. n_q_phi - int Number of bins for numeric screening. E_width - real Width of bins in . Units : q_width - real Width of bins in . Units : numerics_dielectric n_val_max - int Maximum number of valence bands included in the calculation. n_cond_max - int Maximum number of conduction bands included in the calculation. n_k_vec - int Dim : [3] Number of each dimension of a Monkhorst-Pack sampled 1BZ. in_med_scr include_screen - bool Flag to include screening effects. type - str Screening type. Options : 'analytic', 'numeric' alpha - real shape parameter for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 e0 - real Static dielectric parameter for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 q_tf - real Thomas Fermi momentum for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : omega_p - real Plasma frequency for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units :","tags":"","loc":"page/file_spec/nml_input.html"},{"title":"EXCEED-DM Output File – EXCEED-DM","text":"Filetype : HDF5 Extension : .h5 , .hdf5 All of the output data from an EXCEED-DM run. Groups control calc_mode - str Calculation mode. process - str Physical process to calculate. io PW_data_filename - str Filename of data holding (with an index for spin dependent wave functions ) data and corresponding metadata. core_elec_config_filename - str Filename of core electron configuration data. dielectric_filename - str Filename where dielectric data is stored to or read from. nml_input_filename - str Filename where namelist entries are. sto_data_filename - str Filename of STO coefficients and parameters for RHF wave functions. material name - str Target material name. band_gap - real - Target material band gap. Units: density - real - Target material density. Units : pc_vol - real - Volume of the primitive cell. Units : dm_model particle_type - str Dark matter particle type, e.g. 'fermion'. mX - real - Dim : [ n_mX ] Dark matter masses. Units : med_FF - real - Dim : [ n_med_FF ] Mediator form factor parameters, ; n_mX - int Number of dark matter masses. n_med_FF - int Number of mediator form factor parameters. v0 - real - Dark matter velocity distribution parameter. Units : vE - real - Earth velocity, dark matter velocity distribution parameter. Units : vEsc - real - Escape velocity, dark matter velocity distribution parameter. Units : tff_id - int Dim : [2] Transition form factor ID. rhoX - real - Dark matter density Units : experiment E_threshold - real - Experimental energy deposited threshold. Units : n_time - int Number of times of day data is taken. times - real Dim : [ n_time ] Times of the day data is taken. Units : vE_direction - real - Dim: [ n_time , 3] Direction of the Earth velocity in the galactic frame at all the times of the day. m_T - real Mass of the target. Units : exposure - real Exposure time of the target. Units : FFT N - integer - Number of points in the FFT. n_grid - integer Dim : [3] Number of points in the FFT in each dimension. q_max - real - Maximum the FFT is consistent for. Units : PW_dataset n_k - int - Number of points. n_G - int Number of points. n_val - int - Number of valence bands in the dataset. n_cond - int - Number of conduction bands in the dataset. n_bands - int - Total number of bands in the dataset. q_cut - real - Plane wave expansion parameter, . Units : E_cut - real - Plane wave expansion parameter, Units : Ef_max - real - All conduction bands included in the calculation cross below Units : k_red_to_xyz - real Converts between reciprocal reduced coordinates to physical coordinates. The i'th column is the i'th reciprcal lattice vector, Units : red_to_xyz - real Converts between reduced coordinates to physical coordinates. The i'th column is the i'th lattice vector, Units : spin_degen - real Spin degeneracy of each states, for spin independent (dependent) wave functions. q_max_1BZ - real - All transitions with q_max_1BZ are restricted to be within the 1BZ. Units : core_electron n_atom - int Number of atoms in the primitive cell. n_state - int Number of core states. eq_pos_red - real Dim : [ n_atom , 3] Equilibrium position of each atom in the primitive cell in reduced coordinates. Units : None Z - int Dim : [ n_atom ] Proton number of each atom in the primitive cell. energy - real Dim : [ n_state ] Energy of each of the core electron states. config - int Dim : [ n_state , 5] Core electron configuration. A map from a state to the [atom id, n, l, m, n_s] information about each core state, where atom id is the index of the atom in the primitive cell, are the standard quantum numbers, and n_s is the number of spin states STO/n_j - int Dim : [ n_state ] Number of STO functions used to model the core electronic state STO/max_n_j - int The maximum value of the array at STO/n_j STO/n_lj - int Dim : [ n_state , STO/max_n_j ] parameters used to compute the RHF wave functions from the STO's. STO/Z_lj - real Dim : [ n_state , STO/max_n_j ] parameters used to compute the RHF wave functions from the STO's. STO/N0_lj - real Dim : [ n_state , STO/max_n_j ] parameters used to compute the RHF wave functions from the STO's. STO/C_nlj - real Dim : [ n_state , STO/max_n_j ] parameters used to compute the RHF wave functions from the STO's. bins_scatter n_q - int Number of bins in momentum deposition. n_E - int Number of bins in energy deposition. E_width - real Width of the bins in energy deposition. Units : q_width - real Width of the bins in momentum deposition. Units : numerics_scatter_vc Numerics parameters specific to valence to conduction scattering rate calculations. n_val_max - int Maximum number of valence bands included in the calculation. n_cond_max - int Maximum number of conduction bands included in the calculation. numerics_scatter_cc Numerics parameters specific to core to conduction scattering rate calculations. core_id_list - int List of the core electron states that the rate was computed using. core_electron/config(core_id_list(i)) is the configuration of the i th core state included in the calculation. n_FFT_grid_goal - int Dim : [3] FFT grid size specified on input. n_cond_max - int Maximum number of conduction bands included in the calculation. n_principal_min - int Minimum principal quantum number, , to include in the calculation. n_principal_max - int Maximum principal quantum number, , to include in the calculation. numerics_scatter_vf n_val_max - int Maximum number of valence bands included in the calculation. n_kf_theta - int Number of angles in the integration over n_kf_phi - int Number of angles in the integration over n_omega - int Number of parameters to compute for. omega_list - real Dim : [`n_omega'] List of parameters is computed for. Units : Zeff - real Dim: [ n_state , n_k ] parameters used in the Fermi form factor. Units : None numerics_scatter_cf Ef_min - real Minimum final electron energy. Units : Zeff - real Dim : [ n_state , n_k ] parameters used in the Fermi form factor. Units : None core_id_list - int List of the core electron states that the rate was computed using. core_electron/config(core_id_list(i)) is the configuration of the i th core state included in the calculation. ki_min - real Minimum initial electron momentum to integrate over. Units : ki_s - real Scale parameter of maximum initial electron momentum to integrate over, n_kf_theta - int Number of angles in the integration over n_kf_phi - int Number of angles in the integration over n_ki - int Number of points in to integrate over. n_ki_theta - int Number of angles in the integration over n_ki_phi - int Number of angles in the integration over omega_list - real Dim: [`n_omega'] List of parameters is computed for. Units: eV n_principal_min - int Minimum principal quantum number, , to include in the calculation. n_principal_max - int Maximum principal quantum number, , to include in the calculation. numerics_abs Numerics parameters specific to DM absorption calculations. n_val_max - int Maximum number of valence bands included in the calculation. n_cond_max - int Maximum number of conduction bands included in the calculation. n_v - int Number of points in the integration over n_v_theta - int Number of points in the integration over n_v_phi - int Number of points in the integration over widths Width parameters, . n_a - int Number of parameters. n_b - int Number of parameters. n_m - int Number of parameters. n - int Total number of width parameters, . a_min - real Minimum value of . Units : eV a_max - real Maximum value of . Units : eV log_b_min - real Minimum value of . log_b_max - real Maximum value of . m_min - real Minimum value of . Units : eV m_max - real Maximum value of . Units : eV sigma - real Off resonance parameter, only include points with . info - real Dim : [ n , 3] List of the width parameters, each entry lists scatter_rates Binned and total scattering rates, per cross section, for each time, mediator form factor, and DM mass, indexed by, t , f , m respectively. Rates from a given initial state are inside the /init_() subgroup. () should be replaced with integers which fall into the appropriate range, e.g. if dm_model/n_mX = 5 then m_5 is the last subgroup. t_()/f_()/m_()/total - real Total scattering rate, summed over initial states. Units : t_()/f_()/m_()/total_binned - real Dim : [ n_q , n_E ] Total binned scattering rate, summed over initial states. Units : t_()/f_()/m_()/init_()/binned_i - real Dim : [ n_q , n_E ] Binned scattering rate, from the i th initial state. Units : abs_rates Absorption rates, assuming DM-electron coupling, for each time, indexed by t and width. t_()/width_() - real Dim : [ n_mX ] Total absorption rate at each . Units : None self_energies Self energies, , where the 's are specified as the entry subscripts. width_()/pi_v2_v2_r - real Dim : [ n_mX ] Real part of . Units : width_()/pi_v2_v2_c - real Dim : [ n_mX ] Complex part of . Units : width_()/pi_1_1_mat_r - real Dim : [3, 3, n_mX ] Real part of , defined such that . Units : width_()/pi_1_1_mat_c - real Dim : [3, 3, n_mX ] Complex part of , defined such that . Units : width_()/pi_vi_vj_r - real Dim : [3, 3, n_mX ] Real part of . Units : width_()/pi_vi_vj_c - real Dim : [3, 3, n_mX ] Complex part of . Units : abs_tran_form Transition form factors, for absorption calculation, indexed by initial state, init , and final state, fin . init_()/fin_()/tran_form_v2_c Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Complex part of for all . Units : None init_()/fin_()/tran_form_v2_r Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Real part of for all . Units : None init_()/fin_()/tran_form_v_c Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Complex part of for all . Units : None init_()/fin_()/tran_form_v_r Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Real part of for all . Units : None init_()/fin_()/tran_form_1_r Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Real part of for all . (Note: not written if wave functions are spin independent, since this is trivially 0 in that case.) Units : None init_()/fin_()/tran_form_1_c Dim : [ n_k ] ([ n_k , 2, 2] if wave functions are spin dependent) Complex part of for all . (Note: not written if wave functions are spin independent, since this is trivially 0 in that case.) Units : None screening type - str Screening type. alpha - real shape parameter for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 e0 - real Static dielectric parameter for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 q_tf - real Thomas Fermi momentum for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : omega_p - real Plasma frequency for analytic screening. in Eq 6 from https://journals.aps.org/prb/pdf/10.1103/PhysRevB.47.9892 Units : n_E - int Number of bins for numeric screening. n_q - int Number of bins for numeric screening. n_q_theta - int Number of bins for numeric screening. n_q_phi - int Number of bins for numeric screening. E_width - real Width of bins in . Units : q_width - real Width of bins in . Units : version number - str Version number of EXCEED-DM . Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/file_spec/output.html"},{"title":"PW Data File – EXCEED-DM","text":"Filetype : HDF5 Extension : .h5 , .hdf5 Example : ./examples/Si/dft/Si_2x2x2_AE.hdf5 Holds data about the Bloch wave function coefficients, in the Fourier basis, , where denotes the component in the basis. Spin dependence is optional. Datasets n_k - integer - Number of points. n_val - integer - Number of valence bands. n_cond - integer - Number of conduction bands. n_G - integer Number of points. Ef_max - real - Only conduction bands which reach below Ef_max are included in the calculation of the band structure. Relative to Fermi surface/valence band maximum. Units : eV G_grid_red - integer Dim : [ n_G , 3] vectors in reduced coordinates. a_vecs_A - real - Dim : [3, 3] Primitive lattice vectors. Formatted such that a_vecs_A(i, :) is the ith primitive lattice vector, . Units: b_vecs_A - real  - Dim : [3, 3] Reciprocal lattice vectors. Formatted such that b_vecs_A(i, :) is the ith reciprocal lattice vector, . Units: k_weight - real - Dim : [ n_k ] Weight associated with each point for integration over the 1BZ. Units: None k_grid_red - real Dim : [ n_k , 3] vectors in reduced coordinates. Units: None energy_bands - real - Dim : [ n_k , n_bands ] n_bands = n_val + n_cond Energy of each band, for each point. Groups wfc_FT_r wfc_FT_r/i_<band number> wfc_FT_r/i_<band number>/k_<k number> Dim : [ n_G ] ([ n_G , 2] if spin dependent wave functions) Real part of the Bloch wave function coefficients for the i th band and k th k point, . and . wfc_FT_c wfc_FT_c/i_<band number> wfc_FT_c/i_<band number>/k_<k number> Dim : [ n_G ] ([ n_G , 2] if spin dependent wave functions) Imaginary part of the Bloch wave function coefficients for the i th band and k th k point, . and . Notes Orthogonality of lattice vectors, . Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/file_spec/pw_data_file.html"},{"title":"RHF WF Data File – EXCEED-DM","text":"Filetype : HDF5 Extension : .h5 , .hdf5 Example : ./examples/RHF_wf_data.hdf5 RHF wave function coefficients, , which semi-analytically model the atomic wave functions, where is the Bohr radius. The data inside examples/RHF_wf_data.hdf5 are the tabulated coefficients for all atoms with and can be found here . Groups Z_()/n_()/l_()/C_lnj - real Dim : [ nj ] STO coefficients to compute the RHF wave functions for an atom with proton number, , and quantum numbers, . Z_()/n_()/l_()/N_lj - real Dim : [ nj ] STO coefficients to compute the RHF wave functions for an atom with proton number, , and quantum numbers, . Z_()/n_()/l_()/Z_lj - real Dim : [ nj ] STO coefficients to compute the RHF wave functions for an atom with proton number, , and quantum numbers, . Z_()/n_()/l_()/n_lj - real Dim : [ nj ] STO coefficients to compute the RHF wave functions for an atom with proton number, , and quantum numbers, . Z_()/n_()/l_()/nj - real Dim : [ nj ] number of STO coefficients to compute the RHF wave functions for an atom with proton number, , and quantum numbers, . Z_()/n_()/l_()/energy - real Energy of state with proton number, , and quantum numbers, . Units : eV Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/file_spec/rhf_wf_data.html"},{"title":"Installation – EXCEED-DM","text":"Installation Instuctions on how to setup, and check the setup of, EXCEED-DM using CMake. Build To build EXCEED-DM to /your/path/EXCEED-DM with CMake, > tar -xvzf EXCEED-DM-vX.Y.Z.tar.gz -C /your/path/EXCEED-DM\n> cd /your/path/EXCEED-DM\n> mkdir build\n> cd build\n> cmake ..\n> make Build Options CMake allows the user to change many of the build parameters at the command line. Simply append these options to the cmake .. command in the previous section. To specify a different Fortran compiler, -DCMAKE_Fortran_COMPILER=<your compiler> To specify a build mode, -DCMAKE_BUILD_TYPE=<build-type> Options are: Release , Debug Cluster/Supercomputer Large computing systems should have a way to load the pre-requisite software, e.g. module load openmpi . Once all of the prerequisites are loaded cmake should automatically find the correct file locations. Notes: You might have to specify the compiler directly with a build option. Your version of HDF5 should have been compiled with the same compiler you're using. There seems to be some wiggle room with different versions of the same compiler, but expect errors if you compiled HDF5 with GNU Fortran and want to compile the main program with an Intel compiler. Check Build To check that the program was built run mpirun -np 2 ./build/exdm from the main folder. Clean Build To remove the current build of the program, run cmake --build . --target clean from the build/ folder, or simply remove the build directory, rm -r build from the main folder. Pre-requisites Fortran compiler OpenMPI FFTW3 HDF5 LAPACK BLAS CMake (v>=3.16) Fortran90 compiler Linux Install sudo apt install gfortran Check Install gfortran --version Mac Install Check Install gfortran --version Note: attempt compiling a seperate test program, if an error about -lSystem shows up try brew reinstall gcc OpenMPI Linux Install sudo apt install libopenmpi-dev Check Install mpirun --version Mac Install Follow the instructions at https://www.open-mpi.org/faq/?category=building#easy-build . Check Install mpirun --version FFTW3 Linux Install sudo apt install libfftw3-dev Check Install sudo find / -name libfftw3* Should return a list of libraries, but could take a while. Try checking likely folders first like /usr . Mac Install brew install fftw Check Install sudo find / -name \"libfftw3*\" HDF5 Linux Install sudo apt install libhdf5-dev Check Install h5fc -showconfig Mac Install Download the latest release of HDF5 from https://www.hdfgroup.org/downloads/hdf5/ . Unzip the file with gunzip < hdf5-X.Y.Z.tar.gz | tar xf -       # replace X.Y.Z with the release number Then, to install HDF5 at location /usr/local/hdf5, run cd hdf5-X.Y.Z           # replace X.Y.Z with the release number\n./configure --prefix=/usr/local/hdf5 --enable-fortran\nmake\nmake check              # optional\nmake install \nmake check-install      # optional Check Install h5fc -showconfig CMake Linux Install sudo apt install cmake Check Install cmake --version","tags":"","loc":"page/install/index.html"},{"title":"README – EXCEED-DM","text":"EXCEED-DM (EXtended Calculation of Electronic Excitations for Direct detection of Dark Matter) NOTICE: This program is in active development and the code, as well as required inputs and outputs, are subject to change. Star and watch the repository to stay up to date! EXCEED-DM is an OpenMPI Fortran program that computes Dark Matter (DM) induced electronic transition rates for any gapped crystal target. Home Documentation Features EXCEED-DM provides a complete framework for computing DM-electron interaction rates. Scattering : Given a range of DM masses, mediator form factors, and times of day, EXCEED-DM computes the scattering rate per kg-year binned in energy and momentum deposition. All kinematically allowed transitions are included. In addition to transitions near the Fermi surface, where density functional theory (DFT) calculations are a necessary component of the calculation, electronic states further below, and above, are modeled semi-analytically and included in the scattering rate calculation. Daily and annual modulation signals : No assumptions about the isotropy of the target are made, allowing one to study the daily modulation signal, and the DM velocity distribution parameters can be changed very easily to compute annual modulation. Spin-dependent wave functions : Some targets, such as those with spin-orbit coupling, will have electronic states which are not eigenstates of the spin operator. This means the wave functions have two components instead of one, and particle physics couplings to the spin operator are no longer trivial to compute. EXCEED-DM can perform these spin-dependent scattering rate calculations. Note: currently (v >= 0.2.0) only valence to conduction transitions are supported. Calculate the dielectric : For some processes the dielectric will screen the interaction rate. The complex dielectric/screening factor can now be computed and used in scattering rate calculations. Absorption : Given a range of DM masses and times of day, EXCEED-DM computes the absorption rate, electronic self energies, and generalized crystal form factors, needed to compute the DM absorption rate. Scalar, pseudoscalar, and vector DM : compute the absorption rate from these bosonic DM candidates. Note: currently (v >= 0.2.0) only valence to conduction transitions are supported. EXCEED-DM is : fast - Being parallelized with OpenMPI means that EXCEED-DM can take full advantage of large computing clusters. DFT calculator independent - EXCEED-DM depends only on the output of DFT calculations, which means that any DFT calculator can be used to compute the targets electronic properties and then used as input. An example converter for VASP output can be found in the utilities folder. This also allows for modular work flows where particle physicists don't have to worry about DFT details, and material scientists don't have to worry about particle physics details. and has more features on the way! Extras Inside the utilities folder are other programs meant to aid in using EXCEED-DM : vasp_converter/ - python program to convert the output files from VASP calculations to the input files needed for EXCEED-DM . Performs the all electron reconstruction with pawpyseed . binned_wfc/ - Fortran program to compute the square magnitudes of the Bloch wave functions, binned in momentum transfer. post_analysis/ - python scripts and example notebooks for post-processing the output of EXCEED-DM . core_elec_config/ - Calculations involving core electrons require a 'core electron configuration' file that depends on the target material. These files can be generated with the notebook in core_elec_config/ by simply passing the Materials Project ID. Getting Started Follow these instructions to compile and run EXCEED-DM on a fresh Linux distribution. For installation on other systems, or if something goes wrong, see install-cmake.md for more detailed instructions. 1) Install preliminary software Fortran compiler ( sudo apt install gfortran ) OpenMPI ( sudo apt install libopenmpi-dev ) fftw3 ( sudo apt install libfftw3-dev ) hdf5 ( sudo apt install libhdf5-serial-dev ) LAPACK ( sudo apt install liblapack-dev ) BLAS ( sudo apt install libblas-dev ) CMake ( sudo apt install cmake ) Note : It's recommended to run sudo apt update before, and on a completely fresh Linux distribution. 2) Download, then extact the latest release with > tar -xvzf EXCEED-DM-vX.Y.Z.tar.gz -C /your/specific/path/ 3) Compile the main program, exdm , > cd /your/specific/path\n    > mkdir build\n    > cd build\n    > cmake ..\n    > make 4) Test the installation from `/your/specific/path', > mpirun -np 2 ./build/exdm ./examples/Si/inputs/scatter_vc_test_input.txt If installed correctly you should see something similar to, ---------------------------------------------------------------------- EXCEED - DM - v0 . 2 . 8 Running on 2 processors Compiled with GCC version 9 . 3 . 0 ---------------------------------------------------------------------- Loading control parameters ... ---------------------------------------------------------------------- ------- Control ------- Support Installation instructions can be found in install-cmake.md . More detailed usage intstructions can be found in the user manual ( in preparation ). Input files needed for example calculations can be found in examples/ . Output files of example calculations can be found in examples/<material name>/outputs/ and here: Si/Ge - Documentation can be found here , as well as the docs/ folder. Larger DFT input files can be found here: Si/Ge - Papers using EXCEED-DM A. Mitridate, T. Trickle, Z. Zhang, K. M. Zurek, Dark Matter Absorption via Electronic Excitations S. M. Griffin, K. Inzani, T. Trickle, Z. Zhang and K. M. Zurek, Extended Calculation of Dark Matter-Electron Scattering in Crystal Targets T. Trickle, Z. Zhang, K. M. Zurek, K. Inzani and S. Griffin, Multi-Channel Direct Detection of Light Dark Matter: Theoretical Framework S. M. Griffin, K. Inzani, T. Trickle, Z. Zhang and K. M. Zurek, Multichannel direct detection of light dark matter: Target comparison Attribution If you use EXCEED-DM in your work, please cite, along with, @article { Griffin : 2021 znd , author = \"Griffin, Sin\\'ead M. and Inzani, Katherine and Trickle, Tanner and Zhang, Zhengkang and Zurek, Kathryn M.\" , title = \"{Extended Calculation of Dark Matter-Electron Scattering in Crystal Targets}\" , eprint = \"2105.05253\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , month = \"5\" , year = \"2021\" }","tags":"","loc":"page/readme/index.html"},{"title":"Utilities – EXCEED-DM","text":"Information about how to build and run the utilities inside the utilities folder.","tags":"","loc":"page/utilities/index.html"},{"title":"Binned Wave Function Coefficients (wfc) – EXCEED-DM","text":"Bin the wave function coefficients in momentum space. To build, standard cmake procedure: > mkdir build && cd build\n> cmake ..\n> make To run: > ./build/binned_wfc_PW <q bin width> <n q bins> <PW dataset filename> <output filename> Output File Groups PW_dataset See EXCEED-DM Output File documentation. Datasets binned_wfc_FT_sq - real - Dim: [ n_val + n_cond , n_q_bins ] PW wave function coefficients binned in momentum transfer. Warnings Fortran is a column-major order language, which affects how HDF5 datasets are read in. For example, python is a row-major order language, and therefore for an matrix to be read in to Fortran , it must be saved from python as a matrix.","tags":"","loc":"page/utilities/binned_wfc.html"}]}